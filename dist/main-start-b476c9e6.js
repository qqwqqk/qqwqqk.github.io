/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/script/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=script&lang=js&":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/vue/main.vue?vue&type=script&lang=js& ***!
  \*************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vuescroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vuescroll */ \"./node_modules/vuescroll/dist/vuescroll.js\");\n/* harmony import */ var vuescroll__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vuescroll__WEBPACK_IMPORTED_MODULE_0__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: \"app\",\n  components: {\n    VueScroll: (vuescroll__WEBPACK_IMPORTED_MODULE_0___default())\n  },\n  data: function () {\n    return {\n      ops: {\n        vueScroll: {\n          mode: 'native',\n          sizeStrategy: 'percent',\n          detectResize: true\n        },\n        scrollPanel: {\n          initialScrollY: false,\n          initialScrollX: false,\n          scrollingX: true,\n          scrollingY: true,\n          speed: 300,\n          easing: undefined,\n          verticalNativeBarPos: 'right'\n        },\n        rail: {\n          background: 'transparent',\n          opacity: 0,\n          size: '6px',\n          specifyBorderRadius: false,\n          gutterOfEnds: null,\n          gutterOfSide: '2px',\n          keepShow: false\n        },\n        bar: {\n          showDelay: 500,\n          onlyShowBarOnScroll: true,\n          keepShow: false,\n          background: '#66CCFF',\n          opacity: 1,\n          hoverStyle: false,\n          specifyBorderRadius: false,\n          minSize: false,\n          size: '6px',\n          disable: false\n        }\n      },\n      link_qqwqqk: {\n        \"title\": \"五月钦铭\",\n        \"show\": \"src/images/usericon1.jpg\",\n        \"href\": \"#\"\n      },\n      link_QQ: {\n        \"title\": \"QQ\",\n        \"show\": \"src/images/usericon2.jpg\",\n        \"href\": \"#\"\n      },\n      link_WeChat: {\n        \"title\": \"WeChat\",\n        \"show\": \"src/images/usericon3.jpg\",\n        \"href\": \"#\"\n      },\n      sites: [],\n      index: -1,\n      site: {}\n    };\n  },\n  computed: {\n    siteFormLength: function () {\n      let formLength = this.sites.length * 170;\n      return String(formLength) + 'px';\n    }\n  },\n  methods: {\n    browse_old: function () {\n      let url = \"https://qqwqqk.github.io/old_qqwqqk.github.io/\";\n      window.open(url);\n    },\n    isActive: function (message) {\n      return message === this.site;\n    },\n    moveLeft: function () {\n      let temp = this.index - 1;\n\n      if (temp < 0) {\n        temp = temp + this.sites.length;\n      }\n\n      this.index = temp;\n      this.site = this.sites[temp];\n      this.$refs['vs'].scrollIntoView('#item_' + temp, 500);\n    },\n    moveRight: function () {\n      let temp = this.index + 1;\n\n      if (temp >= this.sites.length) {\n        temp = temp - this.sites.length;\n      }\n\n      this.index = temp;\n      this.site = this.sites[temp];\n      this.$refs['vs'].scrollIntoView('#item_' + temp, 500);\n    },\n    clickItem: function (item, index) {\n      this.site = item;\n      this.index = index;\n      this.$refs['vs'].scrollIntoView('#item_' + index, 500);\n    }\n  },\n  created: function () {\n    let url = \"./src/analog_interface/site_list.json\";\n    fetch(url).then(res => res.json()).then(data => {\n      this.sites = data.site_list;\n\n      if (this.sites.length > 0) {\n        this.index = 0;\n        this.site = this.sites[0];\n      }\n    }).catch(e => console.log(\"loading site_list.json error ! \\n \" + e));\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3Z1ZS9tYWluLnZ1ZT8yYjA5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9EQTtBQUNBO0FBQ0EsYUFEQTtBQUVBO0FBQUE7QUFBQSxHQUZBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQURBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBRkE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FIQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUpBLE9BREE7QUFPQTtBQUNBLHVCQURBO0FBRUEsMENBRkE7QUFHQTtBQUhBLE9BUEE7QUFZQTtBQUNBLHFCQURBO0FBRUEsMENBRkE7QUFHQTtBQUhBLE9BWkE7QUFpQkE7QUFDQSx5QkFEQTtBQUVBLDBDQUZBO0FBR0E7QUFIQSxPQWpCQTtBQXNCQSxlQXRCQTtBQXVCQSxlQXZCQTtBQXdCQTtBQXhCQTtBQTBCQSxHQTlCQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsR0EvQkE7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUpBO0FBS0E7QUFDQTtBQUNBLEtBUEE7QUFRQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQWRBO0FBZUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FyQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQSxHQXJDQTtBQWlFQTtBQUNBO0FBQ0EsdUNBQ0EsSUFEQSxDQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQVBBLEVBUUEsS0FSQSxDQVFBLDBEQVJBO0FBU0E7QUE1RUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvdnVlL21haW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG48dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGlkPWNvbnRlbnQ+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlclwiPjwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzaG93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW1hZ2VfYm94XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cImJvcmRlclwiIHYtYmluZDpzcmM9XCJzaXRlLnNob3dcIiB1c2VtYXA9XCIjaW1nbGlua1wiLz5cclxuICAgICAgICAgICAgICAgICAgICA8bWFwIG5hbWU9XCJpbWdsaW5rXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhcmVhIGNsYXNzPVwibWFwX2FyZWFcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI1MCw1MCw0NjAsMzAwXCIgdGFyZ2V0PVwiX2JsYW5rXCIgdi1iaW5kOmhyZWY9XCJzaXRlLmhyZWZcIiB2LWJpbmQ6dGl0bGU9XCJzaXRlLnRpdGxlXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L21hcD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImluZm9fYm94XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVzZXJfaW5mb1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXNlcl9pY29uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSB2LWJpbmQ6aHJlZj1cImxpbmtfcXF3cXFrLmhyZWZcIiB2LWJpbmQ6dGl0bGU9XCJsaW5rX3Fxd3Fxay50aXRsZVwiPjxpbWcgY2xhc3M9XCJ1c2VyX2ljb25fY3NzXCIgdi1iaW5kOnNyYz1cImxpbmtfcXF3cXFrLnNob3dcIj48L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInVzZXJfbmFtZVwiPnt7bGlua19xcXdxcWsudGl0bGV9fTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVzZXJfbGlua3NcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIHYtYmluZDpocmVmPVwibGlua19RUS5ocmVmXCIgdi1iaW5kOnRpdGxlPVwibGlua19RUS50aXRsZVwiPjxpbWcgdi1iaW5kOnNyYz1cImxpbmtfUVEuc2hvd1wiIGNsYXNzPVwidXNlcl9saW5rX2Nzc1wiPjwvYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIHYtYmluZDpocmVmPVwibGlua19XZUNoYXQuaHJlZlwiIHYtYmluZDp0aXRsZT1cImxpbmtfV2VDaGF0LnRpdGxlXCI+PGltZyB2LWJpbmQ6c3JjPVwibGlua19XZUNoYXQuc2hvd1wiIGNsYXNzPVwidXNlcl9saW5rX2Nzc1wiPjwvYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvbGRfaW5mb1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0bl9vbGRcIiB2LW9uOmNsaWNrPVwiYnJvd3NlX29sZCgpXCI+b2xkIHZlcnNpb248L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICBcclxuICAgICAgICAgICAgPGltZyBjbGFzcz0nbW92ZV9sZWZ0JyBzcmM9J3NyYy9pbWFnZXMvbGVmdC5wbmcnIHYtb246Y2xpY2s9J21vdmVMZWZ0KCknLz5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxpc3RcIj5cclxuICAgICAgICAgICAgICAgIDxWdWVTY3JvbGwgOm9wcyA9IFwib3BzXCIgcmVmPVwidnNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdF9mb3JtXCIgdi1iaW5kOnN0eWxlPVwieyB3aWR0aDogc2l0ZUZvcm1MZW5ndGggfVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGVtcGxhdGUgdi1mb3I9XCIoaXRlbSwgaW5kZXgpIGluIHNpdGVzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHYtYmluZDppZD1cIidpdGVtXycraW5kZXhcIiBjbGFzcz1cInNpdGVfYm94XCIgOmtleT1cImluZGV4XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cInNpdGVfaWNvblwiIHYtYmluZDpzcmM9XCJpdGVtLmljb25cIiB2LW9uOmNsaWNrPVwiY2xpY2tJdGVtKGl0ZW0sIGluZGV4KVwiLz48YnIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cInNpdGVfbmFtZVwiIHR5cGU9XCJpbnB1dFwiIHYtYmluZDp2YWx1ZT1cIml0ZW0udGl0bGVcIiB2LWJpbmQ6c3R5bGU9XCJ7IGJhY2tncm91bmRDb2xvcjogaXNBY3RpdmUoaXRlbSkgPyAnIzY2Y2NmZicgOiAnd2hpdGUnIH1cIiByZWFkb25seS8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZW1wbGF0ZT5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvVnVlU2Nyb2xsPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGltZyBjbGFzcz0nbW92ZV9yaWdodCcgc3JjPSdzcmMvaW1hZ2VzL3JpZ2h0LnBuZycgdi1vbjpjbGljaz0nbW92ZVJpZ2h0KCknLz5cclxuICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvb3RlclwiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gICAgaW1wb3J0IFZ1ZVNjcm9sbCBmcm9tICd2dWVzY3JvbGwnO1xyXG4gICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIG5hbWU6IFwiYXBwXCIsXHJcbiAgICAgICAgY29tcG9uZW50czogeyBWdWVTY3JvbGwgfSxcclxuICAgICAgICBkYXRhOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm57XHJcbiAgICAgICAgICAgICAgICBvcHM6IHtcclxuICAgICAgICAgICAgICAgICAgICB2dWVTY3JvbGw6IHsgbW9kZTogJ25hdGl2ZScsIHNpemVTdHJhdGVneTogJ3BlcmNlbnQnLCBkZXRlY3RSZXNpemU6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFBhbmVsOiB7IGluaXRpYWxTY3JvbGxZOiBmYWxzZSwgaW5pdGlhbFNjcm9sbFg6IGZhbHNlLCBzY3JvbGxpbmdYOiB0cnVlLCBzY3JvbGxpbmdZOiB0cnVlLCBzcGVlZDogMzAwLCBlYXNpbmc6IHVuZGVmaW5lZCwgdmVydGljYWxOYXRpdmVCYXJQb3M6ICdyaWdodCd9LFxyXG4gICAgICAgICAgICAgICAgICAgIHJhaWw6IHsgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50Jywgb3BhY2l0eTogMCwgc2l6ZTogJzZweCcsIHNwZWNpZnlCb3JkZXJSYWRpdXM6IGZhbHNlLCBndXR0ZXJPZkVuZHM6IG51bGwsIGd1dHRlck9mU2lkZTogJzJweCcsIGtlZXBTaG93OiBmYWxzZX0sXHJcbiAgICAgICAgICAgICAgICAgICAgYmFyOiB7IHNob3dEZWxheTogNTAwLCBvbmx5U2hvd0Jhck9uU2Nyb2xsOiB0cnVlLCBrZWVwU2hvdzogZmFsc2UsIGJhY2tncm91bmQ6ICcjNjZDQ0ZGJywgb3BhY2l0eTogMSwgaG92ZXJTdHlsZTogZmFsc2UsIHNwZWNpZnlCb3JkZXJSYWRpdXM6IGZhbHNlLCBtaW5TaXplOiBmYWxzZSwgc2l6ZTogJzZweCcsIGRpc2FibGU6IGZhbHNlfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxpbmtfcXF3cXFrOntcclxuICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6XCLkupTmnIjpkqbpk61cIixcclxuICAgICAgICAgICAgICAgICAgICBcInNob3dcIjpcInNyYy9pbWFnZXMvdXNlcmljb24xLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaHJlZlwiOlwiI1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGlua19RUTp7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0aXRsZVwiOlwiUVFcIixcclxuICAgICAgICAgICAgICAgICAgICBcInNob3dcIjpcInNyYy9pbWFnZXMvdXNlcmljb24yLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaHJlZlwiOlwiI1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGlua19XZUNoYXQ6e1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGl0bGVcIjpcIldlQ2hhdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic2hvd1wiOlwic3JjL2ltYWdlcy91c2VyaWNvbjMuanBnXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJocmVmXCI6XCIjXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzaXRlczogW10sXHJcbiAgICAgICAgICAgICAgICBpbmRleDogLTEsXHJcbiAgICAgICAgICAgICAgICBzaXRlOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDp7XHJcbiAgICAgICAgICAgIHNpdGVGb3JtTGVuZ3RoOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvcm1MZW5ndGggPSB0aGlzLnNpdGVzLmxlbmd0aCAqIDE3MDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoZm9ybUxlbmd0aCkgKyAncHgnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgICAgIGJyb3dzZV9vbGQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdXJsPVwiaHR0cHM6Ly9xcXdxcWsuZ2l0aHViLmlvL29sZF9xcXdxcWsuZ2l0aHViLmlvL1wiO1xyXG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4odXJsKTsgXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzQWN0aXZlOmZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSA9PT0gdGhpcy5zaXRlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb3ZlTGVmdDpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSB0aGlzLmluZGV4IC0gMTtcclxuICAgICAgICAgICAgICAgIGlmKHRlbXAgPCAwKXt0ZW1wID0gdGVtcCArIHRoaXMuc2l0ZXMubGVuZ3RoO31cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaXRlID0gdGhpcy5zaXRlc1t0ZW1wXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnNbJ3ZzJ10uc2Nyb2xsSW50b1ZpZXcoJyNpdGVtXycgKyB0ZW1wLCA1MDApO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb3ZlUmlnaHQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gdGhpcy5pbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBpZih0ZW1wID49IHRoaXMuc2l0ZXMubGVuZ3RoKXt0ZW1wID0gdGVtcCAtIHRoaXMuc2l0ZXMubGVuZ3RoO31cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaXRlID0gdGhpcy5zaXRlc1t0ZW1wXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnNbJ3ZzJ10uc2Nyb2xsSW50b1ZpZXcoJyNpdGVtXycgKyB0ZW1wLCA1MDApO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbGlja0l0ZW06IGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaXRlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnNbJ3ZzJ10uc2Nyb2xsSW50b1ZpZXcoJyNpdGVtXycgKyBpbmRleCwgNTAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlZDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgbGV0IHVybCA9IFwiLi9zcmMvYW5hbG9nX2ludGVyZmFjZS9zaXRlX2xpc3QuanNvblwiO1xyXG4gICAgICAgICAgICBmZXRjaCh1cmwpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l0ZXMgPSBkYXRhLnNpdGVfbGlzdDtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnNpdGVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNpdGUgPSB0aGlzLnNpdGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IGNvbnNvbGUubG9nKFwibG9hZGluZyBzaXRlX2xpc3QuanNvbiBlcnJvciAhIFxcbiBcIiArIGUpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgc2NvcGVkPlxyXG4gICAgLmNvbnRlbnR7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IG1hcmdpbjogYXV0bzsgfVxyXG4gICAgLmhlYWRlcnsgd2lkdGg6IDgwMHB4OyBoZWlnaHQ6IDgwcHg7IG1hcmdpbjogYXV0bzsgfVxyXG4gICAgLnNlY3Rpb257IHdpZHRoOiA4MDBweDtoZWlnaHQ6IDY0MHB4OyBtYXJnaW46IGF1dG87IGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7IH1cclxuICAgIC5mb290ZXJ7IHdpZHRoOiA4MDBweDsgaGVpZ2h0OiA4MHB4OyBtYXJnaW46IGF1dG87fVxyXG5cclxuICAgIC5zaG93eyB3aWR0aDogODAwcHg7IGhlaWdodDogNDYwcHg7IG1hcmdpbjogYXV0bzt9XHJcbiAgICAuaW1hZ2VfYm94eyB3aWR0aDogNTYwcHg7IGhlaWdodDogNDIwcHg7IGZsb2F0OmxlZnQ7IG1hcmdpbjogMjBweCAxMHB4IDIwcHggMjBweDsgYm9yZGVyLXJhZGl1czogMTBweDsgYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDsgb3ZlcmZsb3c6aGlkZGVuO31cclxuICAgIC5tYXBfYXJlYXsgb3V0bGluZTogbm9uZTt9XHJcbiAgICAuYm9yZGVyeyB3aWR0aDogNTYwcHg7IGhlaWdodDogNDAwcHg7IG1hcmdpbjogMTBweCAwO31cclxuXHJcbiAgICAuaW5mb19ib3h7IHdpZHRoOiAxODBweDsgaGVpZ2h0OiA0MjBweDsgZmxvYXQ6IHJpZ2h0OyBtYXJnaW46IDIwcHggMjBweCAyMHB4IDEwcHg7IGJvcmRlci1yYWRpdXM6IDI0cHg7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ5LDIzMywxOTUsMC42KTt9XHJcbiAgICAudXNlcl9pbmZveyB3aWR0aDogMTQwcHg7IGhlaWdodDogMjIwcHg7IG1hcmdpbjogMjBweDsgZmxvYXQ6IGxlZnQ7fVxyXG4gICAgLnVzZXJfaWNvbnsgd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDEwMHB4OyBtYXJnaW46IDIwcHggMjBweCA1cHggMjBweDt9XHJcbiAgICAudXNlcl9uYW1leyB3aWR0aDogMTAwcHg7IGhlaWdodDogMzBweDsgbWFyZ2luOiAwIDIwcHg7IHRleHQtYWxpZ246Y2VudGVyOyBsaW5lLWhlaWdodDogMzBweDt9XHJcbiAgICAudXNlcl9saW5rc3sgd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG1hcmdpbjogNXB4IDIwcHggMTBweCAyMHB4OyBmb250LXNpemU6IDA7fVxyXG4gICAgLnVzZXJfaWNvbl9jc3N7IHdpZHRoOiAxMDBweDsgaGVpZ2h0OiAxMDBweDsgYm9yZGVyLXJhZGl1czogNTBweDsgYm9yZGVyOiBub25lO31cclxuICAgIC51c2VyX2xpbmtfY3NzeyB3aWR0aDogNDBweDsgaGVpZ2h0OiA0MHB4OyBtYXJnaW46IDVweDsgYm9yZGVyLXJhZGl1czogMjBweDsgYm9yZGVyOiBub25lO31cclxuXHJcbiAgICAub2xkX2luZm97IHdpZHRoOiAxNDBweDsgaGVpZ2h0OiAxMjBweDsgbWFyZ2luOiAyMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IGZsb2F0OiBsZWZ0O31cclxuICAgIC5idG5fb2xkeyAgd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDQwcHg7IG1hcmdpbjogYXV0bzsgb3V0bGluZTogbm9uZTsgYmFja2dyb3VuZC1jb2xvcjogZGVlcHNreWJsdWU7IGJvcmRlcjogbm9uZTsgYm9yZGVyLXJhZGl1czogOHB4OyAtd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb246IDAuNHM7IHRyYW5zaXRpb24tZHVyYXRpb246IDAuNHM7fVxyXG4gICAgLmJ0bl9vbGQ6aG92ZXJ7IGJhY2tncm91bmQtY29sb3I6ICM2NmNjZmY7fVxyXG5cclxuICAgIC5tb3ZlX2xlZnR7IHdpZHRoOjQwcHg7IGhlaWdodDoxMjBweDsgZmxvYXQ6IGxlZnQ7IG91dGxpbmU6IG5vbmU7IGJvcmRlcjogbm9uZTsgbWFyZ2luOjIwcHggNXB4OyBvcGFjaXR5OiAwLjg7fVxyXG4gICAgLm1vdmVfcmlnaHR7IHdpZHRoOjQwcHg7IGhlaWdodDoxMjBweDsgZmxvYXQ6IGxlZnQ7IG91dGxpbmU6IG5vbmU7IGJvcmRlcjogbm9uZTsgbWFyZ2luOjIwcHggNXB4OyBvcGFjaXR5OiAwLjg7fVxyXG4gICAgLmxpc3R7IHdpZHRoOjY4MHB4OyBoZWlnaHQ6IDE2MHB4OyBmbG9hdDogbGVmdDsgbWFyZ2luOjEwcHg7IGZvbnQtc2l6ZTogMDt9XHJcbiAgICAubGlzdF9mb3JteyB3aWR0aDogNjgwcHg7IGhlaWdodDogMTYwcHg7IGZvbnQtc2l6ZTogMDsgd2hpdGUtc3BhY2UgOm5vd3JhcDt9XHJcbiAgICAuc2l0ZV9ib3h7IHdpZHRoOiAxNTBweDsgaGVpZ2h0OiAxNDBweDsgbWFyZ2luOiAwIDEwcHg7IGZsb2F0OiBsZWZ0OyBib3JkZXItcmFkaXVzOiAyMHB4OyBib3JkZXI6IDVweCBzb2xpZCByZ2JhKDIyMCwyMjAsMjIwLDAuNSk7IG92ZXJmbG93OiBoaWRkZW47IGZvbnQtc2l6ZTogMDt9XHJcbiAgICAuc2l0ZV9pY29ueyB3aWR0aDogMTQwcHg7IGhlaWdodDogMTAwcHg7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyBib3JkZXI6IG5vbmU7fVxyXG4gICAgLnNpdGVfbmFtZXsgd2lkdGg6IDE0MHB4OyBoZWlnaHQ6IDMwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgYm9yZGVyOiBub25lOyBvdXRsaW5lOm5vbmU7fVxyXG48L3N0eWxlPiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib??vue-loader-options!./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css& ***!
  \************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"\\n.content[data-v-1adb287b]{ width: 100%; height: 100%; margin: auto;\\n}\\n.header[data-v-1adb287b]{ width: 800px; height: 80px; margin: auto;\\n}\\n.section[data-v-1adb287b]{ width: 800px;height: 640px; margin: auto; background-color:transparent;\\n}\\n.footer[data-v-1adb287b]{ width: 800px; height: 80px; margin: auto;}\\n.show[data-v-1adb287b]{ width: 800px; height: 460px; margin: auto;}\\n.image_box[data-v-1adb287b]{ width: 560px; height: 420px; float:left; margin: 20px 10px 20px 20px; border-radius: 10px; background-color:transparent; overflow:hidden;}\\n.map_area[data-v-1adb287b]{ outline: none;}\\n.border[data-v-1adb287b]{ width: 560px; height: 400px; margin: 10px 0;}\\n.info_box[data-v-1adb287b]{ width: 180px; height: 420px; float: right; margin: 20px 20px 20px 10px; border-radius: 24px; background-color: rgba(249,233,195,0.6);}\\n.user_info[data-v-1adb287b]{ width: 140px; height: 220px; margin: 20px; float: left;}\\n.user_icon[data-v-1adb287b]{ width: 100px; height: 100px; margin: 20px 20px 5px 20px;}\\n.user_name[data-v-1adb287b]{ width: 100px; height: 30px; margin: 0 20px; text-align:center; line-height: 30px;}\\n.user_links[data-v-1adb287b]{ width: 100px; height: 50px; margin: 5px 20px 10px 20px; font-size: 0;}\\n.user_icon_css[data-v-1adb287b]{ width: 100px; height: 100px; border-radius: 50px; border: none;}\\n.user_link_css[data-v-1adb287b]{ width: 40px; height: 40px; margin: 5px; border-radius: 20px; border: none;}\\n.old_info[data-v-1adb287b]{ width: 140px; height: 120px; margin: 20px; text-align: center; float: left;}\\n.btn_old[data-v-1adb287b]{  width: 100px; height: 40px; margin: auto; outline: none; background-color: deepskyblue; border: none; border-radius: 8px; -webkit-transition-duration: 0.4s; transition-duration: 0.4s;}\\n.btn_old[data-v-1adb287b]:hover{ background-color: #66ccff;}\\n.move_left[data-v-1adb287b]{ width:40px; height:120px; float: left; outline: none; border: none; margin:20px 5px; opacity: 0.8;}\\n.move_right[data-v-1adb287b]{ width:40px; height:120px; float: left; outline: none; border: none; margin:20px 5px; opacity: 0.8;}\\n.list[data-v-1adb287b]{ width:680px; height: 160px; float: left; margin:10px; font-size: 0;}\\n.list_form[data-v-1adb287b]{ width: 680px; height: 160px; font-size: 0; white-space :nowrap;}\\n.site_box[data-v-1adb287b]{ width: 150px; height: 140px; margin: 0 10px; float: left; border-radius: 20px; border: 5px solid rgba(220,220,220,0.5); overflow: hidden; font-size: 0;}\\n.site_icon[data-v-1adb287b]{ width: 140px; height: 100px; background-color: transparent; border: none;}\\n.site_name[data-v-1adb287b]{ width: 140px; height: 30px; text-align: center; border: none; outline:none;}\\n\", \"\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlL21haW4udnVlP2ZiMDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsd0dBQW1EO0FBQ3RGO0FBQ0EsY0FBYyxRQUFTLCtCQUErQixhQUFhLGNBQWMsY0FBYyxHQUFHLDJCQUEyQixjQUFjLGNBQWMsY0FBYyxHQUFHLDRCQUE0QixjQUFjLGNBQWMsY0FBYyw4QkFBOEIsR0FBRywyQkFBMkIsY0FBYyxjQUFjLGVBQWUseUJBQXlCLGNBQWMsZUFBZSxlQUFlLDhCQUE4QixjQUFjLGVBQWUsWUFBWSw2QkFBNkIscUJBQXFCLDhCQUE4QixrQkFBa0IsNkJBQTZCLGdCQUFnQiwyQkFBMkIsY0FBYyxlQUFlLGlCQUFpQiw2QkFBNkIsY0FBYyxlQUFlLGNBQWMsNkJBQTZCLHFCQUFxQiwwQ0FBMEMsOEJBQThCLGNBQWMsZUFBZSxjQUFjLGNBQWMsOEJBQThCLGNBQWMsZUFBZSw2QkFBNkIsOEJBQThCLGNBQWMsY0FBYyxnQkFBZ0IsbUJBQW1CLG9CQUFvQiwrQkFBK0IsY0FBYyxjQUFjLDRCQUE0QixlQUFlLGtDQUFrQyxjQUFjLGVBQWUscUJBQXFCLGVBQWUsa0NBQWtDLGFBQWEsY0FBYyxhQUFhLHFCQUFxQixlQUFlLDZCQUE2QixjQUFjLGVBQWUsY0FBYyxvQkFBb0IsY0FBYyw0QkFBNEIsZUFBZSxjQUFjLGNBQWMsZUFBZSwrQkFBK0IsY0FBYyxvQkFBb0IsbUNBQW1DLDRCQUE0QixrQ0FBa0MsNEJBQTRCLDhCQUE4QixZQUFZLGNBQWMsYUFBYSxlQUFlLGNBQWMsaUJBQWlCLGVBQWUsK0JBQStCLFlBQVksY0FBYyxhQUFhLGVBQWUsY0FBYyxpQkFBaUIsZUFBZSx5QkFBeUIsYUFBYSxlQUFlLGFBQWEsYUFBYSxlQUFlLDhCQUE4QixjQUFjLGVBQWUsY0FBYyxzQkFBc0IsNkJBQTZCLGNBQWMsZUFBZSxnQkFBZ0IsYUFBYSxxQkFBcUIseUNBQXlDLGtCQUFrQixlQUFlLDhCQUE4QixjQUFjLGVBQWUsK0JBQStCLGVBQWUsOEJBQThCLGNBQWMsY0FBYyxvQkFBb0IsY0FBYyxlQUFlIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vc3JjL3Z1ZS9tYWluLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFhZGIyODdiJnNjb3BlZD10cnVlJmxhbmc9Y3NzJi5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmNvbnRlbnRbZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgbWFyZ2luOiBhdXRvO1xcbn1cXG4uaGVhZGVyW2RhdGEtdi0xYWRiMjg3Yl17IHdpZHRoOiA4MDBweDsgaGVpZ2h0OiA4MHB4OyBtYXJnaW46IGF1dG87XFxufVxcbi5zZWN0aW9uW2RhdGEtdi0xYWRiMjg3Yl17IHdpZHRoOiA4MDBweDtoZWlnaHQ6IDY0MHB4OyBtYXJnaW46IGF1dG87IGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XFxufVxcbi5mb290ZXJbZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDgwMHB4OyBoZWlnaHQ6IDgwcHg7IG1hcmdpbjogYXV0bzt9XFxuLnNob3dbZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDgwMHB4OyBoZWlnaHQ6IDQ2MHB4OyBtYXJnaW46IGF1dG87fVxcbi5pbWFnZV9ib3hbZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDU2MHB4OyBoZWlnaHQ6IDQyMHB4OyBmbG9hdDpsZWZ0OyBtYXJnaW46IDIwcHggMTBweCAyMHB4IDIwcHg7IGJvcmRlci1yYWRpdXM6IDEwcHg7IGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7IG92ZXJmbG93OmhpZGRlbjt9XFxuLm1hcF9hcmVhW2RhdGEtdi0xYWRiMjg3Yl17IG91dGxpbmU6IG5vbmU7fVxcbi5ib3JkZXJbZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDU2MHB4OyBoZWlnaHQ6IDQwMHB4OyBtYXJnaW46IDEwcHggMDt9XFxuLmluZm9fYm94W2RhdGEtdi0xYWRiMjg3Yl17IHdpZHRoOiAxODBweDsgaGVpZ2h0OiA0MjBweDsgZmxvYXQ6IHJpZ2h0OyBtYXJnaW46IDIwcHggMjBweCAyMHB4IDEwcHg7IGJvcmRlci1yYWRpdXM6IDI0cHg7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ5LDIzMywxOTUsMC42KTt9XFxuLnVzZXJfaW5mb1tkYXRhLXYtMWFkYjI4N2JdeyB3aWR0aDogMTQwcHg7IGhlaWdodDogMjIwcHg7IG1hcmdpbjogMjBweDsgZmxvYXQ6IGxlZnQ7fVxcbi51c2VyX2ljb25bZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDEwMHB4OyBtYXJnaW46IDIwcHggMjBweCA1cHggMjBweDt9XFxuLnVzZXJfbmFtZVtkYXRhLXYtMWFkYjI4N2JdeyB3aWR0aDogMTAwcHg7IGhlaWdodDogMzBweDsgbWFyZ2luOiAwIDIwcHg7IHRleHQtYWxpZ246Y2VudGVyOyBsaW5lLWhlaWdodDogMzBweDt9XFxuLnVzZXJfbGlua3NbZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG1hcmdpbjogNXB4IDIwcHggMTBweCAyMHB4OyBmb250LXNpemU6IDA7fVxcbi51c2VyX2ljb25fY3NzW2RhdGEtdi0xYWRiMjg3Yl17IHdpZHRoOiAxMDBweDsgaGVpZ2h0OiAxMDBweDsgYm9yZGVyLXJhZGl1czogNTBweDsgYm9yZGVyOiBub25lO31cXG4udXNlcl9saW5rX2Nzc1tkYXRhLXYtMWFkYjI4N2JdeyB3aWR0aDogNDBweDsgaGVpZ2h0OiA0MHB4OyBtYXJnaW46IDVweDsgYm9yZGVyLXJhZGl1czogMjBweDsgYm9yZGVyOiBub25lO31cXG4ub2xkX2luZm9bZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDE0MHB4OyBoZWlnaHQ6IDEyMHB4OyBtYXJnaW46IDIwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgZmxvYXQ6IGxlZnQ7fVxcbi5idG5fb2xkW2RhdGEtdi0xYWRiMjg3Yl17ICB3aWR0aDogMTAwcHg7IGhlaWdodDogNDBweDsgbWFyZ2luOiBhdXRvOyBvdXRsaW5lOiBub25lOyBiYWNrZ3JvdW5kLWNvbG9yOiBkZWVwc2t5Ymx1ZTsgYm9yZGVyOiBub25lOyBib3JkZXItcmFkaXVzOiA4cHg7IC13ZWJraXQtdHJhbnNpdGlvbi1kdXJhdGlvbjogMC40czsgdHJhbnNpdGlvbi1kdXJhdGlvbjogMC40czt9XFxuLmJ0bl9vbGRbZGF0YS12LTFhZGIyODdiXTpob3ZlcnsgYmFja2dyb3VuZC1jb2xvcjogIzY2Y2NmZjt9XFxuLm1vdmVfbGVmdFtkYXRhLXYtMWFkYjI4N2JdeyB3aWR0aDo0MHB4OyBoZWlnaHQ6MTIwcHg7IGZsb2F0OiBsZWZ0OyBvdXRsaW5lOiBub25lOyBib3JkZXI6IG5vbmU7IG1hcmdpbjoyMHB4IDVweDsgb3BhY2l0eTogMC44O31cXG4ubW92ZV9yaWdodFtkYXRhLXYtMWFkYjI4N2JdeyB3aWR0aDo0MHB4OyBoZWlnaHQ6MTIwcHg7IGZsb2F0OiBsZWZ0OyBvdXRsaW5lOiBub25lOyBib3JkZXI6IG5vbmU7IG1hcmdpbjoyMHB4IDVweDsgb3BhY2l0eTogMC44O31cXG4ubGlzdFtkYXRhLXYtMWFkYjI4N2JdeyB3aWR0aDo2ODBweDsgaGVpZ2h0OiAxNjBweDsgZmxvYXQ6IGxlZnQ7IG1hcmdpbjoxMHB4OyBmb250LXNpemU6IDA7fVxcbi5saXN0X2Zvcm1bZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDY4MHB4OyBoZWlnaHQ6IDE2MHB4OyBmb250LXNpemU6IDA7IHdoaXRlLXNwYWNlIDpub3dyYXA7fVxcbi5zaXRlX2JveFtkYXRhLXYtMWFkYjI4N2JdeyB3aWR0aDogMTUwcHg7IGhlaWdodDogMTQwcHg7IG1hcmdpbjogMCAxMHB4OyBmbG9hdDogbGVmdDsgYm9yZGVyLXJhZGl1czogMjBweDsgYm9yZGVyOiA1cHggc29saWQgcmdiYSgyMjAsMjIwLDIyMCwwLjUpOyBvdmVyZmxvdzogaGlkZGVuOyBmb250LXNpemU6IDA7fVxcbi5zaXRlX2ljb25bZGF0YS12LTFhZGIyODdiXXsgd2lkdGg6IDE0MHB4OyBoZWlnaHQ6IDEwMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgYm9yZGVyOiBub25lO31cXG4uc2l0ZV9uYW1lW2RhdGEtdi0xYWRiMjg3Yl17IHdpZHRoOiAxNDBweDsgaGVpZ2h0OiAzMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IGJvcmRlcjogbm9uZTsgb3V0bGluZTpub25lO31cXG5cIiwgXCJcIl0pO1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/main.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/main.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"/* main.css */\\r\\nhtml {\\r\\n    box-sizing: border-box;\\r\\n    -ms-text-size-adjust: 100%;\\r\\n    -webkit-text-size-adjust: 100%;\\r\\n}\\r\\n\\r\\n*, *:before, *:after {\\r\\n    box-sizing: inherit;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    background-color: lightblue;\\r\\n    margin: 0;\\r\\n    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;\\r\\n}\\r\\n\\r\\nh1, h2, h3, h4, h5, h6, p, ul {\\r\\n    margin: 0;\\r\\n    padding: 0;\\r\\n}\", \"\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGUvbWFpbi5jc3M/OGVjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyx3R0FBbUQ7QUFDdEY7QUFDQSxjQUFjLFFBQVMsMkJBQTJCLCtCQUErQixtQ0FBbUMsdUNBQXVDLEtBQUssOEJBQThCLDRCQUE0QixLQUFLLGNBQWMsb0NBQW9DLGtCQUFrQixvRUFBb0UsS0FBSyx1Q0FBdUMsa0JBQWtCLG1CQUFtQixLQUFLIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvc3R5bGUvbWFpbi5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIG1haW4uY3NzICovXFxyXFxuaHRtbCB7XFxyXFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICAgIC1tcy10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcclxcbiAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbiosICo6YmVmb3JlLCAqOmFmdGVyIHtcXHJcXG4gICAgYm94LXNpemluZzogaW5oZXJpdDtcXHJcXG59XFxyXFxuXFxyXFxuYm9keSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0Ymx1ZTtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICBmb250LWZhbWlseTogJ0hlbHZldGljYSBOZXVlJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXHJcXG59XFxyXFxuXFxyXFxuaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCwgdWwge1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxuICAgIHBhZGRpbmc6IDA7XFxyXFxufVwiLCBcIlwiXSk7XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./src/style/main.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJwdXNoIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VSb290IiwiY29uY2F0Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSJdLCJtYXBwaW5ncyI6IkFBQWE7QUFFYjs7OztBQUlBOztBQUNBQSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsVUFBVUMsWUFBVixFQUF3QjtBQUN2QyxNQUFJQyxJQUFJLEdBQUcsRUFBWCxDQUR1QyxDQUN4Qjs7QUFFZkEsTUFBSSxDQUFDQyxRQUFMLEdBQWdCLFNBQVNBLFFBQVQsR0FBb0I7QUFDbEMsV0FBTyxLQUFLQyxHQUFMLENBQVMsVUFBVUMsSUFBVixFQUFnQjtBQUM5QixVQUFJQyxPQUFPLEdBQUdDLHNCQUFzQixDQUFDRixJQUFELEVBQU9KLFlBQVAsQ0FBcEM7O0FBRUEsVUFBSUksSUFBSSxDQUFDLENBQUQsQ0FBUixFQUFhO0FBQ1gsZUFBTyxZQUFZQSxJQUFJLENBQUMsQ0FBRCxDQUFoQixHQUFzQixHQUF0QixHQUE0QkMsT0FBNUIsR0FBc0MsR0FBN0M7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPQSxPQUFQO0FBQ0Q7QUFDRixLQVJNLEVBUUpFLElBUkksQ0FRQyxFQVJE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LEdBQUcsaUVBQWlFTCxNQUE1RTtBQUNBLFNBQU8sU0FBU0ssSUFBVCxHQUFnQixLQUF2QjtBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiAnQG1lZGlhICcgKyBpdGVtWzJdICsgJ3snICsgY29udGVudCArICd9JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW2ldOyAvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuICAgICAgLy8gd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuICAgICAgLy8gSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXG4gICAgICBpZiAoaXRlbVswXSA9PSBudWxsIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSAnKCcgKyBpdGVtWzJdICsgJykgYW5kICgnICsgbWVkaWFRdWVyeSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJztcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcbiAgcmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSUEsT0FBTyxHQUFHQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsRUFBL0IsQyxDQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlDLGdCQUFKO0FBQ0EsSUFBSUMsa0JBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsUUFBTSxJQUFJQyxLQUFKLENBQVUs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LEdBQVIsR0FBY0osSUFBZDtBQUNBM0MsT0FBTyxDQUFDZ0QsY0FBUixHQUF5QkwsSUFBekI7QUFDQTNDLE9BQU8sQ0FBQ2lELGtCQUFSLEdBQTZCTixJQUE3QjtBQUNBM0MsT0FBTyxDQUFDa0QsSUFBUixHQUFlUCxJQUFmO0FBQ0EzQyxPQUFPLENBQUNtRCxlQUFSLEdBQTBCUixJQUExQjtBQUNBM0MsT0FBTyxDQUFDb0QsbUJBQVIsR0FBOEJULElBQTlCOztBQUVBM0MsT0FBTyxDQUFDcUQsU0FBUixHQUFvQixVQUFVQyxJQUFWLEVBQWdCO0FBQUUsU0FBTyxFQUFQO0FBQVcsQ0FBakQ7O0FBRUF0RCxPQUFPLENBQUN1RCxPQUFSLEdBQWtCLFVBQVVELElBQVYsRUFBZ0I7QUFDOUIsUUFBTSxJQUFJaEQsS0FBSixDQUFVLGtDQUFWLENBQU47QUFDSCxDQUZEOztBQUlBTixPQUFPLENBQUN3RCxHQUFSLEdBQWMsWUFBWTtBQUFFLFNBQU8sR0FBUDtBQUFZLENBQXhDOztBQUNBeEQsT0FBTyxDQUFDeUQsS0FBUixHQUFnQixVQUFVQyxHQUFWLEVBQWU7QUFDM0IsUUFBTSxJQUFJcEQsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxDQUZEOztBQUdBTixPQUFPLENBQUMyRCxLQUFSLEdBQWdCLFlBQVc7QUFBRSxTQUFPLENBQVA7QUFBVyxDQUF4QyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  \"use strict\";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== \"function\") {\n      callback = new Function(\"\" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n    // So if we're currently running a task, we'll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // \"too much recursion\" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function (handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can't be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage(\"\", \"*\");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n    var onGlobalMessage = function (event) {\n      if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n      global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n\n    registerImmediate = function (handle) {\n      global.postMessage(messagePrefix + handle, \"*\");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function (handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function (handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var script = doc.createElement(\"script\");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function (handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === \"[object process]\") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n    // For IE 6–8\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbImdsb2JhbCIsInVuZGVmaW5lZCIsInNldEltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwiZG9jdW1lbnQiLCJyZWdpc3RlckltbWVkaWF0ZSIsImNhbGxiYWNrIiwiRnVuY3Rpb24iLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuIiwiYXBwbHkiLCJydW5JZlByZXNlbnQiLCJzZXRUaW1lb3V0IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJNYXRoIiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiZXZlbnQiLCJzb3VyY2UiLCJkYXRhIiwiaW5kZXhPZiIsInNsaWNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwidG9TdHJpbmciLCJjYWxsIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUMsa0VBQVVBLE1BQVYsRUFBa0JDLFNBQWxCLEVBQTZCO0FBQzFCOztBQUVBLE1BQUlELE1BQU0sQ0FBQ0UsWUFBWCxFQUF5QjtBQUNyQjtBQUNIOztBQUVELE1BQUlDLFVBQVUsR0FBRyxDQUFqQixDQVAwQixDQU9OOztBQUNwQixNQUFJQyxhQUFhLEdBQUcsRUFBcEI7QUFDQSxNQUFJQyxxQkFBcUIsR0FBRyxLQUE1QjtBQUNBLE1BQUlDLEdBQUcsR0FBR04sTUFBTSxDQUFDTyxRQUFqQjtBQUNBLE1BQUlDLGlCQUFKOztBQUVBLFdBQVNOLFlBQVQsQ0FBc0JPLFFBQXRCLEVBQWdDO0FBQzlCO0FBQ0EsUUFBSSxPQUFPQSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDQSxjQUFRLEdBQUcsSUFBSUMsUUFBSixDQUFhLEtBQUtELFFBQWxCLENBQVg7QUFDRCxLQUo2QixDQUs5Qjs7O0FBQ0EsUUFBSUUsSUFBSSxHQUFHLElBQUlDLEtBQUosQ0FBVUMsU0FBUyxDQUFDQyxNQUFWLEdBQW1CLENBQTdCLENBQVg7O0FBQ0EsU0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSixJQUFJLENBQUNHLE1BQXpCLEVBQWlDQyxDQUFDLEVBQWxDLEVBQXNDO0FBQ2xDSixVQUFJLENBQUNJLENBQUQsQ0FBSixHQUFVRixTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFMLENBQW5CO0FBQ0gsS0FUNkIsQ0FVOUI7OztBQUNBLFFBQUlDLElBQUksR0FBRztBQUFFUCxjQUFRLEVBQUVBLFFBQVo7QUFBc0JFLFVBQUksRUFBRUE7QUFBNUIsS0FBWDtBQUNBUCxpQkFBYSxDQUFDRCxVQUFELENBQWIsR0FBNEJhLElBQTVCO0FBQ0FSLHFCQUFpQixDQUFDTCxVQUFELENBQWpCO0FBQ0EsV0FBT0EsVUFB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eUxDLE9BQU84QyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCLE9BQU8vRCxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLElBQWhDLEdBQXVDQSxNQUFyRSxHQUE4RStELElBekwvRSxDQUFELEMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib??vue-loader-options!./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css& ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib??vue-loader-options!./main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css& */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlL21haW4udnVlPzliYTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw2YkFBNk87O0FBRW5RLDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxzR0FBbUQ7O0FBRXhFOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3NyYy92dWUvbWFpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xYWRiMjg3YiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbWFpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xYWRiMjg3YiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL21haW4udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWFkYjI4N2Imc2NvcGVkPXRydWUmbGFuZz1jc3MmXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbWFpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xYWRiMjg3YiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx1REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  } // blank or null?\n\n\n  if (!css || typeof css !== \"string\") {\n    return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\"); // convert each url(...)\n\n  /*\n  This regular expression is just a way to recursively match brackets within\n  a string.\n  \t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n     (  = Start a capturing group\n       (?:  = Start a non-capturing group\n           [^)(]  = Match anything that isn't a parentheses\n           |  = OR\n           \\(  = Match a start parentheses\n               (?:  = Start another non-capturing groups\n                   [^)(]+  = Match anything that isn't a parentheses\n                   |  = OR\n                   \\(  = Match a start parentheses\n                       [^)(]*  = Match anything that isn't a parentheses\n                   \\)  = Match a end parentheses\n               )  = End Group\n               *\\) = Match anything and then a close parens\n           )  = Close non-capturing group\n           *  = Match anything\n        )  = Close capturing group\n   \\)  = Match a close parens\n  \t /gi  = Get all matches, not the first.  Be case insensitive.\n   */\n\n  var fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function (fullMatch, origUrl) {\n    // strip quotes (if they exist)\n    var unquotedOrigUrl = origUrl.trim().replace(/^\"(.*)\"$/, function (o, $1) {\n      return $1;\n    }).replace(/^'(.*)'$/, function (o, $1) {\n      return $1;\n    }); // already a full url? no change\n\n    if (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n      return fullMatch;\n    } // convert the url to a full url\n\n\n    var newUrl;\n\n    if (unquotedOrigUrl.indexOf(\"//\") === 0) {\n      //TODO: should we add protocol?\n      newUrl = unquotedOrigUrl;\n    } else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n      // path should be relative to the base url\n      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n    } else {\n      // path should be relative to current directory\n      newUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n    } // send back the fixed url(...)\n\n\n    return \"url(\" + JSON.stringify(newUrl) + \")\";\n  }); // send back the fixed css\n\n  return fixedCss;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImNzcyIsImxvY2F0aW9uIiwid2luZG93IiwiRXJyb3IiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwiY3VycmVudERpciIsInBhdGhuYW1lIiwicmVwbGFjZSIsImZpeGVkQ3NzIiwiZnVsbE1hdGNoIiwib3JpZ1VybCIsInVucXVvdGVkT3JpZ1VybCIsInRyaW0iLCJvIiwiJDEiLCJ0ZXN0IiwibmV3VXJsIiwiaW5kZXhPZiIsIkpTT04iLCJzdHJpbmdpZnkiXSwibWFwcGluZ3MiOiJBQUNBOzs7Ozs7Ozs7Ozs7QUFhQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFVBQVVDLEdBQVYsRUFBZTtBQUM5QjtBQUNBLE1BQUlDLFFBQVEsR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFNLENBQUNELFFBQXZEOztBQUVBLE1BQUksQ0FBQ0EsUUFBTCxFQUFlO0FBQ2IsVUFBTSxJQUFJRSxLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUNELEdBTjZCLENBUS9COzs7QUFDQSxNQUFJLENBQUNILEdBQUQsSUFBUSxPQUFPQSxHQUFQLEtBQWUsUUFBM0IsRUFBcUM7QUFDbkMsV0FBT0EsR0FBUDtBQUNBOztBQUVELE1BQUlJLE9BQU8sR0FBR0gsUUFBUSxDQUFDSSxRQUFULEdBQW9CLElBQXBCLEdBQTJCSixRQUFRLENBQUNLLElBQWxEO0FBQ0EsTUFBSUMsVUFBVSxHQUFHSCxPQUFPLEdBQUdILFFBQVEsQ0FBQ08sUUFBVCxDQUFrQkMsT0FBbEIsQ0FBMEIsV0FBMUIsRUFBdUMsR0FBdkMsQ0FBM0IsQ0FkOEIsQ0FnQi9COztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkEsTUFBSUMsUUFBUSxHQUFHVixHQUFHLENBQUNTLE9BQUosQ0FBWSxxREFBWixFQUFtRSxVQUFTRSxTQUFULEVBQW9CQyxPQUFwQixFQUE2QjtBQUM5RztBQUNBLFFBQUlDLGVBQWUsR0FBR0QsT0FBTyxDQUMzQkUsSUFEb0IsR0FFcEJMLE9BRm9CLENBRVosVUFGWSxFQUVBLFVBQVNNLENBQVQsRUFBWUMsRUFBWixFQUFlO0FBQUUsYUFBT0EsRUFBUDtBQUFZLEtBRjdCLEVBR3BCUCxPQUhvQixDQUdaLFVBSFksRUFHQSxVQUFTTSxDQUFULEVBQVlDLEVBQVosRUFBZTtBQUFFLGFBQU9BLEVBQVA7QUFBWSxLQUg3QixDQUF0QixDQUY4RyxDQU85Rzs7QUFDQSxRQUFJLG9EQUFvREMsSUFBcEQsQ0FBeURKLGVBQXpELENBQUosRUFBK0U7QUFDN0UsYUFBT0YsU0FBUDtBQUNELEtBVjZHLENBWTlHOzs7QUFDQSxRQUFJTyxNQUFKOztBQUVBLFFBQUlMLGVBQWUsQ0FBQ00sT0FBaEIsQ0FBd0IsSUFBeEIsTUFBa0MsQ0FBdEMsRUFBeUM7QUFDdEM7QUFDRkQsWUFBTSxHQUFHTCxlQUFUO0FBQ0EsS0FIRCxNQUdPLElBQUlBLGVBQWUsQ0FBQ00sT0FBaEIsQ0FBd0IsR0FBeEIsTUFBaUMsQ0FBckMsRUFBd0M7QUFDOUM7QUFDQUQsWUFBTSxHQUFHZCxPQUFPLEdBQUdTLGVBQW5CLENBRjhDLENBRVY7QUFDcEMsS0FITSxNQUdBO0FBQ047QUFDQUssWUFBTSxHQUFHWCxVQUFVLEdBQUdNLGVBQWUsQ0FBQ0osT0FBaEIsQ0FBd0IsT0FBeEIsRUFBaUMsRUFBakMsQ0FBdEIsQ0FGTSxDQUVzRDtBQUM1RCxLQXhCNkcsQ0EwQjlHOzs7QUFDQSxXQUFPLFNBQVNXLElBQUksQ0FBQ0MsU0FBTCxDQUFlSCxNQUFmLENBQVQsR0FBa0MsR0FBekM7QUFDQSxHQTVCYyxDQUFmLENBMUMrQixDQXdFL0I7O0FBQ0EsU0FBT1IsUUFBUDtBQUNBLENBMUVEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\"); // On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbInNjb3BlIiwiZ2xvYmFsIiwic2VsZiIsIndpbmRvdyIsImFwcGx5IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJleHBvcnRzIiwic2V0VGltZW91dCIsIlRpbWVvdXQiLCJjYWxsIiwiYXJndW1lbnRzIiwiY2xlYXJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidGltZW91dCIsImNsb3NlIiwiaWQiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIml0ZW0iLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwicmVxdWlyZSIsInNldEltbWVkaWF0ZSIsImNsZWFySW1tZWRpYXRlIl0sIm1hcHBpbmdzIjoiQUFBQSxrREFBSUEsS0FBSyxHQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE1BQWxDLElBQ0MsT0FBT0MsSUFBUCxLQUFnQixXQUFoQixJQUErQkEsSUFEaEMsSUFFQUMsTUFGWjtBQUdBLElBQUlDLEtBQUssR0FBR0MsUUFBUSxDQUFDQyxTQUFULENBQW1CRixLQUEvQixDLENBRUE7O0FBRUFHLE9BQU8sQ0FBQ0MsVUFBUixHQUFxQixZQUFXO0FBQzlCLFNBQU8sSUFBSUMsT0FBSixDQUFZTCxLQUFLLENBQUNNLElBQU4sQ0FBV0YsVUFBWCxFQUF1QlIsS0FBdkIsRUFBOEJXLFNBQTlCLENBQVosRUFBc0RDLFlBQXRELENBQVA7QUFDRCxDQUZEOztBQUdBTCxPQUFPLENBQUNNLFdBQVIsR0FBc0IsWUFBVztBQUMvQixTQUFPLElBQUlKLE9BQUosQ0FBWUwsS0FBSyxDQUFDTSxJQUFOLENBQVdHLFdBQVgsRUFBd0JiLEtBQXhCLEVBQStCVyxTQUEvQixDQUFaLEVBQXVERyxhQUF2RCxDQUFQO0FBQ0QsQ0FGRDs7QUFHQVAsT0FBTyxDQUFDSyxZQUFSLEdBQ0FMLE9BQU8sQ0FBQ08sYUFBUixHQUF3QixVQUFTQyxPQUFULEVBQWtCO0FBQ3hDLE1BQUlBLE9BQUosRUFBYTtBQUNYQSxXQUFPLENBQUNDLEtBQVI7QUFDRDtBQUNGLENBTEQ7O0FBT0EsU0FBU1AsT0FBVCxDQUFpQlEsRUFBakIsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzVCLE9BQUtDLEdBQUwsR0FBV0YsRUFBWDtBQUNBLE9BQUtHLFFBQUwsR0FBZ0JGLE9BQWhCO0FBQ0Q7O0FBQ0RULE9BQU8sQ0FBQ0gsU0FBUixDQUFrQmUsS0FBbEIsR0FBMEJaLE9BQU8sQ0FBQ0gsU0FBUixDQUFrQmdCLEdBQWxCLEdBQXdCLFlBQVcsQ0FBRSxDQUEvRDs7QUFDQWIsT0FBTyxDQUFDSCxTQUFSLENBQWtCVSxLQUFsQixHQUEwQixZQUFXO0FBQ25DLE9BQUtJLFFBQUwsQ0FBY1YsSUFBZCxDQUFtQlYsS0FBbkIsRUFBMEIsS0FBS21CLEdBQS9CO0FBQ0QsQ0FGRCxDLENBSUE7OztBQUNBWixPQUFPLENBQUNnQixNQUFSLEdBQWlCLFVBQVNDLElBQVQsRUFBZUMsS0FBZixFQUFzQjtBQUNyQ2IsY0FBWSxDQUFDWSxJQUFJLENBQUNFLGNBQU4sQ0FBWjtBQUNBRixNQUFJLENBQUNHLFlBQUwsR0FBb0JGLEtBQXBCO0FBQ0QsQ0FIRDs7QUFLQWxCLE9BQU8sQ0FBQ3FCLFFBQVIsR0FBbUIsVUFBU0osSUFBVCxFQUFlO0FBQ2hDWixjQUFZLENBQUNZLElBQUksQ0FBQ0UsY0FBTixDQUFaO0FBQ0FGLE1BQUksQ0FBQ0csWUFBTCxHQUFvQixDQUFDLENBQXJCO0FBQ0QsQ0FIRDs7QUFLQXBCLE9BQU8sQ0FBQ3NCLFlBQVIsR0FBdUJ0QixPQUFPLENBQUN1QixNQUFSLEdBQWlCLFVBQVNOLElBQVQsRUFBZTtBQUNyRFosY0FBWSxDQUFDWSxJQUFJLENBQUNFLGNBQU4sQ0FBWjtBQUVBLE1BQUlELEtBQUssR0FBR0QsSUFBSSxDQUFDRyxZQUFqQjs7QUFDQSxNQUFJRixLQUFLLElBQUksQ0FBYixFQUFnQjtBQUNkRCxRQUFJLENBQUNFLGNBQUwsR0FBc0JsQixVQUFVLENBQUMsU0FBU3VCLFNBQVQsR0FBcUI7QUFDcEQsVUFBSVAsSUFBSSxDQUFDUSxVQUFULEVBQ0VSLElBQUksQ0FBQ1EsVUFBTDtBQUNILEtBSCtCLEVBRzdCUCxLQUg2QixDQUFoQztBQUlEO0FBQ0YsQ0FWRCxDLENBWUE7OztBQUNBUSxtQkFBTyxDQUFDLGlFQUFELENBQVAsQyxDQUNBO0FBQ0E7QUFDQTs7O0FBQ0ExQixPQUFPLENBQUMyQixZQUFSLEdBQXdCLE9BQU9oQyxJQUFQLEtBQWdCLFdBQWhCLElBQStCQSxJQUFJLENBQUNnQyxZQUFyQyxJQUNDLE9BQU9qQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFNLENBQUNpQyxZQUR6QyxJQUVDLFFBQVEsS0FBS0EsWUFGckM7QUFHQTNCLE9BQU8sQ0FBQzRCLGNBQVIsR0FBMEIsT0FBT2pDLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLElBQUksQ0FBQ2lDLGNBQXJDLElBQ0MsT0FBT2xDLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE1BQU0sQ0FBQ2tDLGNBRHpDLElBRUMsUUFBUSxLQUFLQSxjQUZ2QyxDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=template&id=1adb287b&scoped=true&":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/vue/main.vue?vue&type=template&id=1adb287b&scoped=true& ***!
  \***************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { attrs: { id: \"content\" } }, [\n    _c(\"div\", { staticClass: \"header\" }),\n    _vm._v(\" \"),\n    _c(\"div\", { staticClass: \"section\" }, [\n      _c(\"div\", { staticClass: \"show\" }, [\n        _c(\"div\", { staticClass: \"image_box\" }, [\n          _c(\"img\", {\n            staticClass: \"border\",\n            attrs: { src: _vm.site.show, usemap: \"#imglink\" }\n          }),\n          _vm._v(\" \"),\n          _c(\"map\", { attrs: { name: \"imglink\" } }, [\n            _c(\"area\", {\n              staticClass: \"map_area\",\n              attrs: {\n                shape: \"rect\",\n                coords: \"50,50,460,300\",\n                target: \"_blank\",\n                href: _vm.site.href,\n                title: _vm.site.title\n              }\n            })\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"info_box\" }, [\n          _c(\"div\", { staticClass: \"user_info\" }, [\n            _c(\"div\", { staticClass: \"user_icon\" }, [\n              _c(\n                \"a\",\n                {\n                  attrs: {\n                    href: _vm.link_qqwqqk.href,\n                    title: _vm.link_qqwqqk.title\n                  }\n                },\n                [\n                  _c(\"img\", {\n                    staticClass: \"user_icon_css\",\n                    attrs: { src: _vm.link_qqwqqk.show }\n                  })\n                ]\n              )\n            ]),\n            _vm._v(\" \"),\n            _c(\"p\", { staticClass: \"user_name\" }, [\n              _vm._v(_vm._s(_vm.link_qqwqqk.title))\n            ]),\n            _vm._v(\" \"),\n            _c(\"div\", { staticClass: \"user_links\" }, [\n              _c(\n                \"a\",\n                { attrs: { href: _vm.link_QQ.href, title: _vm.link_QQ.title } },\n                [\n                  _c(\"img\", {\n                    staticClass: \"user_link_css\",\n                    attrs: { src: _vm.link_QQ.show }\n                  })\n                ]\n              ),\n              _vm._v(\" \"),\n              _c(\n                \"a\",\n                {\n                  attrs: {\n                    href: _vm.link_WeChat.href,\n                    title: _vm.link_WeChat.title\n                  }\n                },\n                [\n                  _c(\"img\", {\n                    staticClass: \"user_link_css\",\n                    attrs: { src: _vm.link_WeChat.show }\n                  })\n                ]\n              )\n            ])\n          ]),\n          _vm._v(\" \"),\n          _c(\"div\", { staticClass: \"old_info\" }, [\n            _c(\n              \"button\",\n              {\n                staticClass: \"btn_old\",\n                attrs: { type: \"button\" },\n                on: {\n                  click: function($event) {\n                    return _vm.browse_old()\n                  }\n                }\n              },\n              [_vm._v(\"old version\")]\n            )\n          ])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"img\", {\n        staticClass: \"move_left\",\n        attrs: { src: \"src/images/left.png\" },\n        on: {\n          click: function($event) {\n            return _vm.moveLeft()\n          }\n        }\n      }),\n      _vm._v(\" \"),\n      _c(\n        \"div\",\n        { staticClass: \"list\" },\n        [\n          _c(\"VueScroll\", { ref: \"vs\", attrs: { ops: _vm.ops } }, [\n            _c(\n              \"div\",\n              {\n                staticClass: \"list_form\",\n                style: { width: _vm.siteFormLength }\n              },\n              [\n                _vm._l(_vm.sites, function(item, index) {\n                  return [\n                    _c(\n                      \"div\",\n                      {\n                        key: index,\n                        staticClass: \"site_box\",\n                        attrs: { id: \"item_\" + index }\n                      },\n                      [\n                        _c(\"img\", {\n                          staticClass: \"site_icon\",\n                          attrs: { src: item.icon },\n                          on: {\n                            click: function($event) {\n                              return _vm.clickItem(item, index)\n                            }\n                          }\n                        }),\n                        _c(\"br\"),\n                        _vm._v(\" \"),\n                        _c(\"input\", {\n                          staticClass: \"site_name\",\n                          style: {\n                            backgroundColor: _vm.isActive(item)\n                              ? \"#66ccff\"\n                              : \"white\"\n                          },\n                          attrs: { type: \"input\", readonly: \"\" },\n                          domProps: { value: item.title }\n                        })\n                      ]\n                    )\n                  ]\n                })\n              ],\n              2\n            )\n          ])\n        ],\n        1\n      ),\n      _vm._v(\" \"),\n      _c(\"img\", {\n        staticClass: \"move_right\",\n        attrs: { src: \"src/images/right.png\" },\n        on: {\n          click: function($event) {\n            return _vm.moveRight()\n          }\n        }\n      })\n    ]),\n    _vm._v(\" \"),\n    _c(\"div\", { staticClass: \"footer\" })\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlL21haW4udnVlPzE0NjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxnQkFBZ0IsRUFBRTtBQUMvQyxlQUFlLHdCQUF3QjtBQUN2QztBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGlCQUFpQixzQkFBc0I7QUFDdkMsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFdBQVc7QUFDWDtBQUNBLHFCQUFxQixTQUFTLGtCQUFrQixFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDLHFCQUFxQiwyQkFBMkI7QUFDaEQsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUyxtREFBbUQsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBLDJCQUEyQixvQkFBb0IsZUFBZSxFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixrQ0FBa0MsOEJBQThCO0FBQ2hFLHFDQUFxQztBQUNyQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvdnVlL21haW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFhZGIyODdiJnNjb3BlZD10cnVlJi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJjb250ZW50XCIgfSB9LCBbXG4gICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJoZWFkZXJcIiB9KSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwic2VjdGlvblwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwic2hvd1wiIH0sIFtcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJpbWFnZV9ib3hcIiB9LCBbXG4gICAgICAgICAgX2MoXCJpbWdcIiwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYm9yZGVyXCIsXG4gICAgICAgICAgICBhdHRyczogeyBzcmM6IF92bS5zaXRlLnNob3csIHVzZW1hcDogXCIjaW1nbGlua1wiIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwibWFwXCIsIHsgYXR0cnM6IHsgbmFtZTogXCJpbWdsaW5rXCIgfSB9LCBbXG4gICAgICAgICAgICBfYyhcImFyZWFcIiwge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtYXBfYXJlYVwiLFxuICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHNoYXBlOiBcInJlY3RcIixcbiAgICAgICAgICAgICAgICBjb29yZHM6IFwiNTAsNTAsNDYwLDMwMFwiLFxuICAgICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICBocmVmOiBfdm0uc2l0ZS5ocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBfdm0uc2l0ZS50aXRsZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImluZm9fYm94XCIgfSwgW1xuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidXNlcl9pbmZvXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ1c2VyX2ljb25cIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IF92bS5saW5rX3Fxd3Fxay5ocmVmLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogX3ZtLmxpbmtfcXF3cXFrLnRpdGxlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfYyhcImltZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInVzZXJfaWNvbl9jc3NcIixcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgc3JjOiBfdm0ubGlua19xcXdxcWsuc2hvdyB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJwXCIsIHsgc3RhdGljQ2xhc3M6IFwidXNlcl9uYW1lXCIgfSwgW1xuICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5saW5rX3Fxd3Fxay50aXRsZSkpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInVzZXJfbGlua3NcIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgICAgICAgIHsgYXR0cnM6IHsgaHJlZjogX3ZtLmxpbmtfUVEuaHJlZiwgdGl0bGU6IF92bS5saW5rX1FRLnRpdGxlIH0gfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfYyhcImltZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInVzZXJfbGlua19jc3NcIixcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgc3JjOiBfdm0ubGlua19RUS5zaG93IH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImFcIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBfdm0ubGlua19XZUNoYXQuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IF92bS5saW5rX1dlQ2hhdC50aXRsZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX2MoXCJpbWdcIiwge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ1c2VyX2xpbmtfY3NzXCIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHNyYzogX3ZtLmxpbmtfV2VDaGF0LnNob3cgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm9sZF9pbmZvXCIgfSwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJidG5fb2xkXCIsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uYnJvd3NlX29sZCgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbX3ZtLl92KFwib2xkIHZlcnNpb25cIildXG4gICAgICAgICAgICApXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW1nXCIsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwibW92ZV9sZWZ0XCIsXG4gICAgICAgIGF0dHJzOiB7IHNyYzogXCJzcmMvaW1hZ2VzL2xlZnQucG5nXCIgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3ZtLm1vdmVMZWZ0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImxpc3RcIiB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJWdWVTY3JvbGxcIiwgeyByZWY6IFwidnNcIiwgYXR0cnM6IHsgb3BzOiBfdm0ub3BzIH0gfSwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJsaXN0X2Zvcm1cIixcbiAgICAgICAgICAgICAgICBzdHlsZTogeyB3aWR0aDogX3ZtLnNpdGVGb3JtTGVuZ3RoIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF92bS5fbChfdm0uc2l0ZXMsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJzaXRlX2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwiaXRlbV9cIiArIGluZGV4IH1cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiaW1nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwic2l0ZV9pY29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHNyYzogaXRlbS5pY29uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5jbGlja0l0ZW0oaXRlbSwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInNpdGVfbmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogX3ZtLmlzQWN0aXZlKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiIzY2Y2NmZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwid2hpdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcImlucHV0XCIsIHJlYWRvbmx5OiBcIlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBpdGVtLnRpdGxlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJpbWdcIiwge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJtb3ZlX3JpZ2h0XCIsXG4gICAgICAgIGF0dHJzOiB7IHNyYzogXCJzcmMvaW1hZ2VzL3JpZ2h0LnBuZ1wiIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF92bS5tb3ZlUmlnaHQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdKSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZm9vdGVyXCIgfSlcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=template&id=1adb287b&scoped=true&\n");

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzPzI4NzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n\n/*  */\nvar emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\n\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n/**\n * Check if value is primitive.\n */\n\n\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n  typeof value === 'symbol' || typeof value === 'boolean';\n}\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\n\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\n\n\nvar _toString = Object.prototype.toString;\n\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\n\n\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n/**\n * Check if val is a valid array index.\n */\n\n\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\n\nfunction isPromise(val) {\n  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n}\n/**\n * Convert a value to a string that is actually rendered.\n */\n\n\nfunction toString(val) {\n  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n}\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\n\n\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\n\n\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n/**\n * Check if a tag is a built-in tag.\n */\n\n\nvar isBuiltInTag = makeMap('slot,component', true);\n/**\n * Check if an attribute is a reserved attribute.\n */\n\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n/**\n * Remove an item from an array.\n */\n\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n/**\n * Check whether an object has the property.\n */\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n/**\n * Create a cached version of a pure function.\n */\n\n\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n/**\n * Camelize a hyphen-delimited string.\n */\n\n\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n/**\n * Capitalize a string.\n */\n\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n/**\n * Hyphenate a camelCase string.\n */\n\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\n\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n}\n\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\n/**\n * Convert an Array-like object to a real Array.\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n\n  return ret;\n}\n/**\n * Mix properties into target object.\n */\n\n\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n\n  return to;\n}\n/**\n * Merge an Array of Objects into a single Object.\n */\n\n\nfunction toObject(arr) {\n  var res = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n\n  return res;\n}\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\n\n\nfunction noop(a, b, c) {}\n/**\n * Always return false.\n */\n\n\nvar no = function (a, b, c) {\n  return false;\n};\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\n\n\nvar identity = function (_) {\n  return _;\n};\n/**\n * Generate a string containing static keys from compiler modules.\n */\n\n\nfunction genStaticKeys(modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(',');\n}\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\n\n\nfunction looseEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i]);\n        });\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key]);\n        });\n      } else {\n        /* istanbul ignore next */\n        return false;\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\n\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Ensure a function is called only once.\n */\n\n\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nvar SSR_ATTR = 'data-server-rendered';\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\nvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"development\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\n\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n/**\n * Check if a string starts with $ or _\n */\n\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n/**\n * Define a property.\n */\n\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n/**\n * Parse simple path.\n */\n\n\nvar bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n\n      obj = obj[segments[i]];\n    }\n\n    return obj;\n  };\n}\n/*  */\n// can we use __proto__?\n\n\nvar hasProto = '__proto__' in {}; // Browser environment sniffing\n\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n\nvar nativeWatch = {}.watch;\nvar supportsPassive = false;\n\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n} // this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\n\n\nvar _isServer;\n\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n\n  return _isServer;\n}; // detect devtools\n\n\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n/* istanbul ignore next */\n\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */\n// $flow-disable-line\n\n\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set =\n  /*@__PURE__*/\n  function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n/*  */\n\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = noop; // work around flow check\n\nvar formatComponentName = noop;\n\nif (true) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n\n  var classify = function (str) {\n    return str.replace(classifyRE, function (c) {\n      return c.toUpperCase();\n    }).replace(/[-_]/g, '');\n  };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && !config.silent) {\n      console.error(\"[Vue warn]: \" + msg + trace);\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n\n    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n\n    while (n) {\n      if (n % 2 === 1) {\n        res += str;\n      }\n\n      if (n > 1) {\n        str += str;\n      }\n\n      n >>= 1;\n    }\n\n    return res;\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue;\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n\n      return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n        return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n      }).join('\\n');\n    } else {\n      return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n    }\n  };\n}\n/*  */\n\n\nvar uid = 0;\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\n\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n\n  if ( true && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) {\n      return a.id - b.id;\n    });\n  }\n\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n}; // The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\n\n\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget() {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n/*  */\n\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = {\n  child: {\n    configurable: true\n  }\n}; // DEPRECATED: alias for componentInstance for backwards compat.\n\n/* istanbul ignore next */\n\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function (text) {\n  if (text === void 0) text = '';\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n} // optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\n\n\nfunction cloneVNode(vnode) {\n  var cloned = new VNode(vnode.tag, vnode.data, // #7975\n  // clone children array to avoid mutating original in case of cloning\n  // a child.\n  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned;\n}\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\nvar methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n/**\n * Intercept mutating methods and emit events\n */\n\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n\n    if (inserted) {\n      ob.observeArray(inserted);\n    } // notify change\n\n\n    ob.dep.notify();\n    return result;\n  });\n});\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\n\nvar shouldObserve = true;\n\nfunction toggleObserving(value) {\n  shouldObserve = value;\n}\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\n\n\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\n\n\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n/**\n * Observe a list of Array items.\n */\n\n\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n}; // helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\n\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n\n/* istanbul ignore next */\n\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n\n\nfunction observe(value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return;\n  }\n\n  var ob;\n\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n\n  return ob;\n}\n/**\n * Define a reactive property on an Object.\n */\n\n\nfunction defineReactive$$1(obj, key, val, customSetter, shallow) {\n  var dep = new Dep();\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n\n  if (property && property.configurable === false) {\n    return;\n  } // cater for pre-defined getter/setters\n\n\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n\n      if (Dep.target) {\n        dep.depend();\n\n        if (childOb) {\n          childOb.dep.depend();\n\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n\n\n      if ( true && customSetter) {\n        customSetter();\n      } // #7981: for accessor properties without setter\n\n\n      if (getter && !setter) {\n        return;\n      }\n\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\n\n\nfunction set(target, key, val) {\n  if ( true && (isUndef(target) || isPrimitive(target))) {\n    warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n  }\n\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val;\n  }\n\n  var ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n     true && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n/**\n * Delete a property and trigger change if necessary.\n */\n\n\nfunction del(target, key) {\n  if ( true && (isUndef(target) || isPrimitive(target))) {\n    warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n  }\n\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return;\n  }\n\n  var ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n     true && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n\n  if (!hasOwn(target, key)) {\n    return;\n  }\n\n  delete target[key];\n\n  if (!ob) {\n    return;\n  }\n\n  ob.dep.notify();\n}\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\n\n\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\n\n\nvar strats = config.optionMergeStrategies;\n/**\n * Options with restrictions\n */\n\nif (true) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n    }\n\n    return defaultStrat(parent, child);\n  };\n}\n/**\n * Helper that recursively merges two data objects together.\n */\n\n\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n\n  var key, toVal, fromVal;\n  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i]; // in case the object is already observed...\n\n    if (key === '__ob__') {\n      continue;\n    }\n\n    toVal = to[key];\n    fromVal = from[key];\n\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n\n  return to;\n}\n/**\n * Data\n */\n\n\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n\n    if (!parentVal) {\n      return childVal;\n    } // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n\n\n    return function mergedDataFn() {\n      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n    };\n  } else {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n}\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       true && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n\n    return mergeDataOrFn(parentVal, childVal);\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm);\n};\n/**\n * Hooks and props are merged as arrays.\n */\n\n\nfunction mergeHook(parentVal, childVal) {\n  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  return res ? dedupeHooks(res) : res;\n}\n\nfunction dedupeHooks(hooks) {\n  var res = [];\n\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n\n  return res;\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets(parentVal, childVal, vm, key) {\n  var res = Object.create(parentVal || null);\n\n  if (childVal) {\n     true && assertObjectType(key, childVal, vm);\n    return extend(res, childVal);\n  } else {\n    return res;\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch = function (parentVal, childVal, vm, key) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) {\n    parentVal = undefined;\n  }\n\n  if (childVal === nativeWatch) {\n    childVal = undefined;\n  }\n  /* istanbul ignore if */\n\n\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n\n  if (true) {\n    assertObjectType(key, childVal, vm);\n  }\n\n  if (!parentVal) {\n    return childVal;\n  }\n\n  var ret = {};\n  extend(ret, parentVal);\n\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n\n    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n  }\n\n  return ret;\n};\n/**\n * Other object hashes.\n */\n\n\nstrats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n  if (childVal && \"development\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n\n  if (!parentVal) {\n    return childVal;\n  }\n\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n\n  if (childVal) {\n    extend(ret, childVal);\n  }\n\n  return ret;\n};\n\nstrats.provide = mergeDataOrFn;\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n/**\n * Validate component names\n */\n\n\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName(name) {\n  if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n    warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n  }\n\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n  }\n}\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\n\n\nfunction normalizeProps(options, vm) {\n  var props = options.props;\n\n  if (!props) {\n    return;\n  }\n\n  var res = {};\n  var i, val, name;\n\n  if (Array.isArray(props)) {\n    i = props.length;\n\n    while (i--) {\n      val = props[i];\n\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = {\n          type: null\n        };\n      } else if (true) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : {\n        type: val\n      };\n    }\n  } else if (true) {\n    warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n  }\n\n  options.props = res;\n}\n/**\n * Normalize all injections into Object-based format\n */\n\n\nfunction normalizeInject(options, vm) {\n  var inject = options.inject;\n\n  if (!inject) {\n    return;\n  }\n\n  var normalized = options.inject = {};\n\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = {\n        from: inject[i]\n      };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val) ? extend({\n        from: key\n      }, val) : {\n        from: val\n      };\n    }\n  } else if (true) {\n    warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n  }\n}\n/**\n * Normalize raw function directives into object format.\n */\n\n\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n\n      if (typeof def$$1 === 'function') {\n        dirs[key] = {\n          bind: def$$1,\n          update: def$$1\n        };\n      }\n    }\n  }\n}\n\nfunction assertObjectType(name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n  }\n}\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\n\n\nfunction mergeOptions(parent, child, vm) {\n  if (true) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child); // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n\n  for (key in parent) {\n    mergeField(key);\n  }\n\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n\n  return options;\n}\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\n\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n\n  var assets = options[type]; // check local registration variations first\n\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n\n  var camelizedId = camelize(id);\n\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n\n  var PascalCaseId = capitalize(camelizedId);\n\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  } // fallback to prototype chain\n\n\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n  if ( true && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key]; // boolean casting\n\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  } // check default value\n\n\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n    // make sure to observe it.\n\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n\n  if (true) {\n    assertProp(prop, key, value, vm, absent);\n  }\n\n  return value;\n}\n/**\n * Get the default value of a prop.\n */\n\n\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n\n  var def = prop.default; // warn against non-factory defaults for Object & Array\n\n  if ( true && isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  } // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n\n\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  } // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n\n\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n/**\n * Assert whether a prop is valid.\n */\n\n\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n\n  if (value == null && !prop.required) {\n    return;\n  }\n\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n    return;\n  }\n\n  var validator = prop.validator;\n\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType = getType(type);\n\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\n\n\nfunction getType(fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : '';\n}\n\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\n\nfunction getTypeIndex(type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value\n\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n\n  message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n\n  return message;\n}\n\nfunction styleValue(value, type) {\n  if (type === 'String') {\n    return \"\\\"\" + value + \"\\\"\";\n  } else if (type === 'Number') {\n    return \"\" + Number(value);\n  } else {\n    return \"\" + value;\n  }\n}\n\nfunction isExplicable(value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) {\n    return value.toLowerCase() === elem;\n  });\n}\n\nfunction isBoolean() {\n  var args = [],\n      len = arguments.length;\n\n  while (len--) args[len] = arguments[len];\n\n  return args.some(function (elem) {\n    return elem.toLowerCase() === 'boolean';\n  });\n}\n/*  */\n\n\nfunction handleError(err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n\n  try {\n    if (vm) {\n      var cur = vm;\n\n      while (cur = cur.$parent) {\n        var hooks = cur.$options.errorCaptured;\n\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n\n              if (capture) {\n                return;\n              }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\n  var res;\n\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) {\n        return handleError(e, vm, info + \" (Promise/async)\");\n      }); // issue #9511\n      // avoid catch triggering multiple times when nested calls\n\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n\n  return res;\n}\n\nfunction globalHandleError(err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info);\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n\n  logError(err, vm, info);\n}\n\nfunction logError(err, vm, info) {\n  if (true) {\n    warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n  }\n  /* istanbul ignore else */\n\n\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err;\n  }\n}\n/*  */\n\n\nvar isUsingMicroTask = false;\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks() {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n} // Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\n\n\nvar timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n\n/* istanbul ignore next, $flow-disable-line */\n\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n\n  timerFunc = function () {\n    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n    if (isIOS) {\n      setTimeout(noop);\n    }\n  };\n\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\nMutationObserver.toString() === '[object MutationObserverConstructor]')) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick(cb, ctx) {\n  var _resolve;\n\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  } // $flow-disable-line\n\n\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    });\n  }\n}\n/*  */\n\n\nvar mark;\nvar measure;\n\nif (true) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n\n  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n    mark = function (tag) {\n      return perf.mark(tag);\n    };\n\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag); // perf.clearMeasures(name)\n    };\n  }\n}\n/* not type checking this file because flow doesn't play well with Proxy */\n\n\nvar initProxy;\n\nif (true) {\n  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);\n  };\n\n  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has(target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n      if (!has && !isAllowed) {\n        if (key in target.$data) {\n          warnReservedPrefix(target, key);\n        } else {\n          warnNonPresent(target, key);\n        }\n      }\n\n      return has || !isAllowed;\n    }\n  };\n  var getHandler = {\n    get: function get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) {\n          warnReservedPrefix(target, key);\n        } else {\n          warnNonPresent(target, key);\n        }\n      }\n\n      return target[key];\n    }\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n/*  */\n\n\nvar seenObjects = new _Set();\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\n\nfunction traverse(val) {\n  _traverse(val, seenObjects);\n\n  seenObjects.clear();\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n\n  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n    return;\n  }\n\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n\n    if (seen.has(depId)) {\n      return;\n    }\n\n    seen.add(depId);\n  }\n\n  if (isA) {\n    i = val.length;\n\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n/*  */\n\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  };\n});\n\nfunction createFnInvoker(fns, vm) {\n  function invoker() {\n    var arguments$1 = arguments;\n    var fns = invoker.fns;\n\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n    }\n  }\n\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n  var name, def$$1, cur, old, event;\n\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n\n    if (isUndef(cur)) {\n       true && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n/*  */\n\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n/*  */\n\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n\n  if (isUndef(propOptions)) {\n    return;\n  }\n\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n\n      if (true) {\n        var keyInLowerCase = key.toLowerCase();\n\n        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n          tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n        }\n      }\n\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n\n      if (!preserve) {\n        delete hash[key];\n      }\n\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n\n      if (!preserve) {\n        delete hash[altKey];\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n/*  */\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\n\n\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n\n  return children;\n} // 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\n\n\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n\n    if (isUndef(c) || typeof c === 'boolean') {\n      continue;\n    }\n\n    lastIndex = res.length - 1;\n    last = res[lastIndex]; //  nested\n\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + c[0].text);\n          c.shift();\n        }\n\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n\n        res.push(c);\n      }\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (true) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n        });\n      } else {}\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]; // #6574 in case the inject object is observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      var provideKey = inject[key].from;\n      var source = vm;\n\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break;\n        }\n\n        source = source.$parent;\n      }\n\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n        } else if (true) {\n          warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\n\n\nfunction resolveSlots(children, context) {\n  if (!children || !children.length) {\n    return {};\n  }\n\n  var slots = {};\n\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    } // named slots should only be respected if the vnode was rendered in the\n    // same context.\n\n\n    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n      var name = data.slot;\n      var slot = slots[name] || (slots[name] = []);\n\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  } // ignore slots that contains only whitespace\n\n\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment && !node.asyncFactory || node.text === ' ';\n}\n/*  */\n\n\nfunction normalizeScopedSlots(slots, normalSlots, prevSlots) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized;\n  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots;\n  } else {\n    res = {};\n\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  } // expose normal slots on scopedSlots\n\n\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  } // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n\n\n  if (slots && Object.isExtensible(slots)) {\n    slots._normalized = res;\n  }\n\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res;\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode\n    : normalizeChildren(res);\n    return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658\n    ) ? undefined : res;\n  }; // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n\n\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n\n  return normalized;\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () {\n    return slots[key];\n  };\n}\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\n\n\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n\n  if (!isDef(ret)) {\n    ret = [];\n  }\n\n  ret._isVList = true;\n  return ret;\n}\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\n\n\nfunction renderSlot(name, fallback, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n\n    if (bindObject) {\n      if ( true && !isObject(bindObject)) {\n        warn('slot v-bind without argument expects an Object', this);\n      }\n\n      props = extend(extend({}, bindObject), props);\n    }\n\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n\n  if (target) {\n    return this.$createElement('template', {\n      slot: target\n    }, nodes);\n  } else {\n    return nodes;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\n\n\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n/*  */\n\n\nfunction isKeyNotMatch(expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1;\n  } else {\n    return expect !== actual;\n  }\n}\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\n\n\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName);\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\n\n\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n  if (value) {\n    if (!isObject(value)) {\n       true && warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n\n      var hash;\n\n      var loop = function (key) {\n        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n\n            on[\"update:\" + key] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop(key);\n    }\n  }\n\n  return data;\n}\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\n\n\nfunction renderStatic(index, isInFor) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n\n  if (tree && !isInFor) {\n    return tree;\n  } // otherwise, render a fresh tree.\n\n\n  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n  );\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\n\n\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n/*  */\n\n\nfunction bindObjectListeners(data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       true && warn('v-on without argument expects an Object value', this);\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n\n  return data;\n}\n/*  */\n\n\nfunction resolveScopedSlots(fns, // see flow/vnode\nres, // the following are added in 2.6\nhasDynamicKeys, contentHashKey) {\n  res = res || {\n    $stable: !hasDynamicKeys\n  };\n\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n\n      res[slot.key] = slot.fn;\n    }\n  }\n\n  if (contentHashKey) {\n    res.$key = contentHashKey;\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction bindDynamicKeys(baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if ( true && key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n    }\n  }\n\n  return baseObj;\n} // helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\n\n\nfunction prependModifier(value, symbol) {\n  return typeof value === 'string' ? symbol + value : value;\n}\n/*  */\n\n\nfunction installRenderHelpers(target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n/*  */\n\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n  var this$1 = this;\n  var options = Ctor.options; // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n\n  var contextVm;\n\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent); // $flow-disable-line\n\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent; // $flow-disable-line\n\n    parent = parent._original;\n  }\n\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n    }\n\n    return this$1.$slots;\n  };\n\n  Object.defineProperty(this, 'scopedSlots', {\n    enumerable: true,\n    get: function get() {\n      return normalizeScopedSlots(data.scopedSlots, this.slots());\n    }\n  }); // support for compiled functional template\n\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options; // pre-resolve slots for renderSlot()\n\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n\n      return vnode;\n    };\n  } else {\n    this._c = function (a, b, c, d) {\n      return createElement(contextVm, a, b, c, d, needNormalization);\n    };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) {\n      mergeProps(props, data.attrs);\n    }\n\n    if (isDef(data.props)) {\n      mergeProps(props, data.props);\n    }\n  }\n\n  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n\n    return res;\n  }\n}\n\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n\n  if (true) {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n\n  return clone;\n}\n\nfunction mergeProps(to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n// inline hooks to be invoked on component VNodes during patch\n\n\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating) {\n    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n  insert: function insert(vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  },\n  destroy: function destroy(vnode) {\n    var componentInstance = vnode.componentInstance;\n\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  }\n};\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  } // if at this stage it's not a constructor or an async component factory,\n  // reject.\n\n\n  if (typeof Ctor !== 'function') {\n    if (true) {\n      warn(\"Invalid Component definition: \" + String(Ctor), context);\n    }\n\n    return;\n  } // async component\n\n\n  var asyncFactory;\n\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n    }\n  }\n\n  data = data || {}; // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n\n  resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  } // extract props\n\n\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  } // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n\n\n  var listeners = data.on; // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n    // work around flow\n    var slot = data.slot;\n    data = {};\n\n    if (slot) {\n      data.slot = slot;\n    }\n  } // install component management hooks onto the placeholder node\n\n\n  installComponentHooks(data); // return a placeholder vnode\n\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n    Ctor: Ctor,\n    propsData: propsData,\n    listeners: listeners,\n    tag: tag,\n    children: children\n  }, asyncFactory);\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\nparent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  }; // check inline-template render functions\n\n  var inlineTemplate = vnode.data.inlineTemplate;\n\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n\n  return new vnode.componentOptions.Ctor(options);\n}\n\nfunction installComponentHooks(data) {\n  var hooks = data.hook || (data.hook = {});\n\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1(f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n\n  merged._merged = true;\n  return merged;\n} // transform component v-model info (value and callback) into\n// prop and event handler respectively.\n\n\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';\n  (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n\n  if (isDef(existing)) {\n    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n/*  */\n\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n// without getting yelled at by flow\n\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n     true && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  } // object syntax in v-bind\n\n\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  } // warn against non-primitive key\n\n\n  if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n    {\n      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n    }\n  } // support single function children as default scoped slot\n\n\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = {\n      default: children[0]\n    };\n    children.length = 0;\n  }\n\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n\n  var vnode, ns;\n\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n\n  if (Array.isArray(vnode)) {\n    return vnode;\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) {\n      applyNS(vnode, ns);\n    }\n\n    if (isDef(data)) {\n      registerDeepBindings(data);\n    }\n\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns, force) {\n  vnode.ns = ns;\n\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n} // ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\n\n\nfunction registerDeepBindings(data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n/*  */\n\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n\n  vm._staticTrees = null; // v-once cached trees\n\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  }; // normalization is always applied for the public version, used in\n  // user-written render functions.\n\n\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  }; // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n\n\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n\n  if (true) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {}\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin(Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n    } // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n\n\n    vm.$vnode = _parentVnode; // render self\n\n    var vnode;\n\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\"); // return error render result,\n      // or previous vnode to prevent render error causing blank component\n\n      /* istanbul ignore else */\n\n      if ( true && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    } // if the returned array contains only a single node, allow it\n\n\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    } // return empty vnode in case the render function errored out\n\n\n    if (!(vnode instanceof VNode)) {\n      if ( true && Array.isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n\n      vnode = createEmptyVNode();\n    } // set parent\n\n\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n}\n/*  */\n\n\nfunction ensureCtor(comp, base) {\n  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n    comp = comp.default;\n  }\n\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = {\n    data: data,\n    context: context,\n    children: children,\n    tag: tag\n  };\n  return node;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  var owner = currentRenderingInstance;\n\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null;\n    owner.$on('hook:destroyed', function () {\n      return remove(owners, owner);\n    });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        owners[i].$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n    var reject = once(function (reason) {\n       true && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n\n            if (isUndef(factory.resolved)) {\n              reject( true ? \"timeout (\" + res.timeout + \"ms)\" : undefined);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false; // return in case resolved synchronously\n\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n/*  */\n\n\nfunction isAsyncPlaceholder(node) {\n  return node.isComment && node.asyncFactory;\n}\n/*  */\n\n\nfunction getFirstComponentChild(children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c;\n      }\n    }\n  }\n}\n/*  */\n\n/*  */\n\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false; // init parent attached events\n\n  var listeners = vm.$options._parentListeners;\n\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler(event, fn) {\n  var _target = target;\n  return function onceHandler() {\n    var res = fn.apply(null, arguments);\n\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  };\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this; // all\n\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    } // array of events\n\n\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n\n      return vm;\n    } // specific event\n\n\n    var cbs = vm._events[event];\n\n    if (!cbs) {\n      return vm;\n    }\n\n    if (!fn) {\n      vm._events[event] = null;\n      return vm;\n    } // specific handler\n\n\n    var cb;\n    var i = cbs.length;\n\n    while (i--) {\n      cb = cbs[i];\n\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n\n    if (true) {\n      var lowerCaseEvent = event.toLowerCase();\n\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n      }\n    }\n\n    var cbs = vm._events[event];\n\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n\n    return vm;\n  };\n}\n/*  */\n\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  };\n}\n\nfunction initLifecycle(vm) {\n  var options = vm.$options; // locate first non-abstract parent\n\n  var parent = options.parent;\n\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n  vm.$children = [];\n  vm.$refs = {};\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n      /* removeOnly */\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n\n    restoreActiveInstance(); // update __vue__ reference\n\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    } // if parent is an HOC, update its $el as well\n\n\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    } // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true; // remove self from parent\n\n    var parent = vm.$parent;\n\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    } // teardown watchers\n\n\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n\n    var i = vm._watchers.length;\n\n    while (i--) {\n      vm._watchers[i].teardown();\n    } // remove reference from data ob\n    // frozen object may not have observer.\n\n\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    } // call the last hook...\n\n\n    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n    vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n    callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n    vm.$off(); // remove __vue__ reference\n\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    } // release circular reference (#6759)\n\n\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n\n    if (true) {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n\n  callHook(vm, 'beforeMount');\n  var updateComponent;\n  /* istanbul ignore if */\n\n  if ( true && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n      mark(startTag);\n\n      var vnode = vm._render();\n\n      mark(endTag);\n      measure(\"vue \" + name + \" render\", startTag, endTag);\n      mark(startTag);\n\n      vm._update(vnode, hydrating);\n\n      mark(endTag);\n      measure(\"vue \" + name + \" patch\", startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  } // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n\n\n  new Watcher(vm, updateComponent, noop, {\n    before: function before() {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true\n  /* isRenderWatcher */\n  );\n  hydrating = false; // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  if (true) {\n    isUpdatingChildComponent = true;\n  } // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n\n\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n\n  var needsForceUpdate = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  hasDynamicScopedSlot);\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n\n  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject; // update props\n\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n\n    toggleObserving(true); // keep a copy of raw propsData\n\n    vm.$options.propsData = propsData;\n  } // update listeners\n\n\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (true) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n\n  if (!vm._inactive) {\n    vm._inactive = true;\n\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n\n  popTarget();\n}\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n/**\n * Reset the scheduler's state.\n */\n\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n\n  if (true) {\n    circular = {};\n  }\n\n  waiting = flushing = false;\n} // Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\n\n\nvar currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\nvar getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\n\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n\n  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () {\n      return performance.now();\n    };\n  }\n}\n/**\n * Flush both queues and run the watchers.\n */\n\n\nfunction flushSchedulerQueue() {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id; // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  }); // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n\n    if (watcher.before) {\n      watcher.before();\n    }\n\n    id = watcher.id;\n    has[id] = null;\n    watcher.run(); // in dev build, check and stop circular updates.\n\n    if ( true && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n        break;\n      }\n    }\n  } // keep copies of post queues before resetting state\n\n\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n  resetSchedulerState(); // call component updated and activated hooks\n\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue); // devtool hook\n\n  /* istanbul ignore if */\n\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks(queue) {\n  var i = queue.length;\n\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\n\n\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true\n    /* true */\n    );\n  }\n}\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\n\n\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n\n  if (has[id] == null) {\n    has[id] = true;\n\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n\n      queue.splice(i + 1, 0, watcher);\n    } // queue the flush\n\n\n    if (!waiting) {\n      waiting = true;\n\n      if ( true && !config.async) {\n        flushSchedulerQueue();\n        return;\n      }\n\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n/*  */\n\n\nvar uid$2 = 0;\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\n\nvar Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n  this.vm = vm;\n\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n\n  vm._watchers.push(this); // options\n\n\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  true ? expOrFn.toString() : undefined; // parse expression for getter\n\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n\n    if (!this.getter) {\n      this.getter = noop;\n       true && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n    }\n  }\n\n  this.value = this.lazy ? undefined : this.get();\n};\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\n\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    } else {\n      throw e;\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n\n    popTarget();\n    this.cleanupDeps();\n  }\n\n  return value;\n};\n/**\n * Add a dependency to this directive.\n */\n\n\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n/**\n * Clean up for dependency collection.\n */\n\n\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var i = this.deps.length;\n\n  while (i--) {\n    var dep = this.deps[i];\n\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\n\n\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\n\n\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n\n    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\n\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n/**\n * Depend on all deps collected by this watcher.\n */\n\n\nWatcher.prototype.depend = function depend() {\n  var i = this.deps.length;\n\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n/**\n * Remove self from all dependencies' subscriber list.\n */\n\n\nWatcher.prototype.teardown = function teardown() {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n\n    this.active = false;\n  }\n};\n/*  */\n\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true\n    /* asRootData */\n    );\n  }\n\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent; // root instance props should be converted\n\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n\n  var loop = function (key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n\n    if (true) {\n      var hyphenatedKey = hyphenate(key);\n\n      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n        warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n      }\n\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n        }\n      });\n    } else {} // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n\n\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop(key);\n\n  toggleObserving(true);\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n  if (!isPlainObject(data)) {\n    data = {};\n     true && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  } // proxy data on instance\n\n\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n\n  while (i--) {\n    var key = keys[i];\n\n    if (true) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n      }\n    }\n\n    if (props && hasOwn(props, key)) {\n       true && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  } // observe data\n\n\n  observe(data, true\n  /* asRootData */\n  );\n}\n\nfunction getData(data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n\n  try {\n    return data.call(vm, vm);\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {};\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = {\n  lazy: true\n};\n\nfunction initComputed(vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n    if ( true && getter == null) {\n      warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n    } // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n\n\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (true) {\n      if (key in vm.$data) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  var shouldCache = !isServerRendering();\n\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n\n  if ( true && sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n    };\n  }\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n\n      if (Dep.target) {\n        watcher.depend();\n      }\n\n      return watcher.value;\n    }\n  };\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter() {\n    return fn.call(this, this);\n  };\n}\n\nfunction initMethods(vm, methods) {\n  var props = vm.$options.props;\n\n  for (var key in methods) {\n    if (true) {\n      if (typeof methods[key] !== 'function') {\n        warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + typeof methods[key] + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n      }\n\n      if (key in vm && isReserved(key)) {\n        warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n      }\n    }\n\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, expOrFn, handler, options) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n\n  return vm.$watch(expOrFn, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n\n  dataDef.get = function () {\n    return this._data;\n  };\n\n  var propsDef = {};\n\n  propsDef.get = function () {\n    return this._props;\n  };\n\n  if (true) {\n    dataDef.set = function () {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options);\n    }\n\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\");\n      }\n    }\n\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n/*  */\n\n\nvar uid$3 = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this; // a uid\n\n    vm._uid = uid$3++;\n    var startTag, endTag;\n    /* istanbul ignore if */\n\n    if ( true && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + vm._uid;\n      endTag = \"vue-perf-end:\" + vm._uid;\n      mark(startTag);\n    } // a flag to avoid this being observed\n\n\n    vm._isVue = true; // merge options\n\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n\n\n    if (true) {\n      initProxy(vm);\n    } else {} // expose real self\n\n\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n\n    callHook(vm, 'created');\n    /* istanbul ignore if */\n\n    if ( true && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n\n      modified[key] = latest[key];\n    }\n  }\n\n  return modified;\n}\n\nfunction Vue(options) {\n  if ( true && !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this;\n    } // additional parameters\n\n\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n\n    installedPlugins.push(plugin);\n    return this;\n  };\n}\n/*  */\n\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n/*  */\n\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n  /**\n   * Class inheritance\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n\n    if ( true && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    } // allow further extension/mixin/plugin usage\n\n\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use; // create asset registers, so extended classes\n    // can have their private assets too.\n\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    }); // enable recursive self-lookup\n\n    if (name) {\n      Sub.options.components[name] = Sub;\n    } // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n\n\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n/*  */\n\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if ( true && type === 'component') {\n          validateComponentName(id);\n        }\n\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = {\n            bind: definition,\n            update: definition\n          };\n        }\n\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n/*  */\n\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1;\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n\n\n  return false;\n}\n\nfunction pruneCache(keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n\n  for (var key in cache) {\n    var cachedNode = cache[key];\n\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(cache, key, keys, current) {\n  var cached$$1 = cache[key];\n\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n  created: function created() {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n  destroyed: function destroyed() {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n  mounted: function mounted() {\n    var this$1 = this;\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) {\n        return matches(val, name);\n      });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) {\n        return !matches(val, name);\n      });\n    });\n  },\n  render: function render() {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n\n      if ( // not included\n      include && (!name || !matches(include, name)) || // excluded\n      exclude && name && matches(exclude, name)) {\n        return vnode;\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key); // prune oldest entry\n\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n\n    return vnode || slot && slot[0];\n  }\n};\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n\n  configDef.get = function () {\n    return config;\n  };\n\n  if (true) {\n    configDef.set = function () {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n\n  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj;\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  }); // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n\n  Vue.options._base = Vue;\n  extend(Vue.options.components, builtInComponents);\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get() {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext;\n  }\n}); // expose FunctionalRenderContext for ssr runtime helper installation\n\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\nVue.version = '2.6.10';\n/*  */\n// these are reserved for web because they are directly compiled away\n// during template compilation\n\nvar isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\nvar acceptValue = makeMap('input,textarea,option,select,progress');\n\nvar mustUseProp = function (tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n};\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false;\n};\n/*  */\n\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n\n  return renderClass(data.staticClass, data.class);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction renderClass(staticClass, dynamicClass) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value);\n  }\n\n  if (isObject(value)) {\n    return stringifyObject(value);\n  }\n\n  if (typeof value === 'string') {\n    return value;\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction stringifyArray(value) {\n  var res = '';\n  var stringified;\n\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) {\n        res += ' ';\n      }\n\n      res += stringified;\n    }\n  }\n\n  return res;\n}\n\nfunction stringifyObject(value) {\n  var res = '';\n\n  for (var key in value) {\n    if (value[key]) {\n      if (res) {\n        res += ' ';\n      }\n\n      res += key;\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\n\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isPreTag = function (tag) {\n  return tag === 'pre';\n};\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  } // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n\n\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\n\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n\n  if (isReservedTag(tag)) {\n    return false;\n  }\n\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n\n  var el = document.createElement(tag);\n\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n\n    if (!selected) {\n       true && warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n\n    return selected;\n  } else {\n    return el;\n  }\n}\n/*  */\n\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n\n  if (tagName !== 'select') {\n    return elm;\n  } // false or null will remove the attribute but undefined will not\n\n\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope(node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps =\n/*#__PURE__*/\nObject.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n\n  if (!isDef(key)) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\n\nvar emptyNode = new VNode('', {}, []);\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n}\n\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') {\n    return true;\n  }\n\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove$$1() {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n\n    remove$$1.listeners = listeners;\n    return remove$$1;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1(vnode, inVPre) {\n    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n    })) && config.isUnknownElement(vnode.tag);\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n\n    if (isDef(tag)) {\n      if (true) {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n      /* istanbul ignore if */\n\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if ( true && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false\n        /* hydrating */\n        );\n      } // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n\n\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n\n    vnode.elm = vnode.componentInstance.$el;\n\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode); // make sure to invoke the insert hook\n\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i; // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n\n    var innerNode = vnode;\n\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    } // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n\n\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (true) {\n        checkDuplicateKeys(children);\n      }\n\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n\n    i = vnode.data.hook; // Reuse variable\n\n    if (isDef(i)) {\n      if (isDef(i.create)) {\n        i.create(emptyNode, vnode);\n      }\n\n      if (isDef(i.insert)) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  } // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n\n\n  function setScope(vnode) {\n    var i;\n\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n\n        ancestor = ancestor.parent;\n      }\n    } // for slot content they should also get the scopeId from the host instance.\n\n\n    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } // recursively invoke hooks on child component root node\n\n\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n\n    var canMove = !removeOnly;\n\n    if (true) {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys(children) {\n    var seenKeys = {};\n\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld(node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n\n      if (isDef(c) && sameVnode(node, c)) {\n        return i;\n      }\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n\n      return;\n    } // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n\n    var i;\n    var data = vnode.data;\n\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (true) {\n          checkDuplicateKeys(ch);\n        }\n\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || data && data.pre;\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true;\n    } // assert node match\n\n\n    if (true) {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false;\n      }\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true\n        /* hydrating */\n        );\n      }\n\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if ( true && typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n\n              return false;\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break;\n              }\n\n              childNode = childNode.nextSibling;\n            } // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n\n\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if ( true && typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n\n              return false;\n            }\n          }\n        }\n      }\n\n      if (isDef(data)) {\n        var fullInvoke = false;\n\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) {\n        invokeDestroyHook(oldVnode);\n      }\n\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (true) {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          } // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n\n\n          oldVnode = emptyNodeAt(oldVnode);\n        } // replacing existing element\n\n\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n\n            ancestor.elm = vnode.elm;\n\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              } // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n\n\n              var insert = ancestor.data.hook.insert;\n\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n\n            ancestor = ancestor.parent;\n          }\n        } // destroy old node\n\n\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n/*  */\n\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n  var key, oldDir, dir;\n\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n\n  if (!dirs) {\n    // $flow-disable-line\n    return res;\n  }\n\n  var i, dir;\n\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  } // $flow-disable-line\n\n\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return;\n  }\n\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  } // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n  /* istanbul ignore if */\n\n\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr(el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n\n    /* istanbul ignore if */\n    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n\n      el.addEventListener('input', blocker); // $flow-disable-line\n\n      el.__ieph = true;\n      /* IE placeholder patched */\n    }\n\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode); // handle transition classes\n\n  var transitionClass = el._transitionClasses;\n\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  } // set the class\n\n\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters(exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) {\n        inSingle = false;\n      }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) {\n        inDouble = false;\n      }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) {\n        inTemplateString = false;\n      }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) {\n        inRegex = false;\n      }\n    } else if (c === 0x7C && // pipe\n    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;\n          break;\n        // \"\n\n        case 0x27:\n          inSingle = true;\n          break;\n        // '\n\n        case 0x60:\n          inTemplateString = true;\n          break;\n        // `\n\n        case 0x28:\n          paren++;\n          break;\n        // (\n\n        case 0x29:\n          paren--;\n          break;\n        // )\n\n        case 0x5B:\n          square++;\n          break;\n        // [\n\n        case 0x5D:\n          square--;\n          break;\n        // ]\n\n        case 0x7B:\n          curly++;\n          break;\n        // {\n\n        case 0x7D:\n          curly--;\n          break;\n        // }\n      }\n\n      if (c === 0x2f) {\n        // /\n        var j = i - 1;\n        var p = void 0; // find first non-whitespace prev char\n\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n\n          if (p !== ' ') {\n            break;\n          }\n        }\n\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter() {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression;\n}\n\nfunction wrapFilter(exp, filter) {\n  var i = filter.indexOf('(');\n\n  if (i < 0) {\n    // _f: resolveFilter\n    return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n  }\n}\n/*  */\n\n/* eslint-disable no-unused-vars */\n\n\nfunction baseWarn(msg, range) {\n  console.error(\"[Vue compiler]: \" + msg);\n}\n/* eslint-enable no-unused-vars */\n\n\nfunction pluckModuleFunction(modules, key) {\n  return modules ? modules.map(function (m) {\n    return m[key];\n  }).filter(function (_) {\n    return _;\n  }) : [];\n}\n\nfunction addProp(el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({\n    name: name,\n    value: value,\n    dynamic: dynamic\n  }, range));\n  el.plain = false;\n}\n\nfunction addAttr(el, name, value, range, dynamic) {\n  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n  attrs.push(rangeSetItem({\n    name: name,\n    value: value,\n    dynamic: dynamic\n  }, range));\n  el.plain = false;\n} // add a raw attr (use this in preTransforms)\n\n\nfunction addRawAttr(el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({\n    name: name,\n    value: value\n  }, range));\n}\n\nfunction addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker(symbol, name, dynamic) {\n  return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n}\n\nfunction addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n  modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n  /* istanbul ignore if */\n\n  if ( true && warn && modifiers.prevent && modifiers.passive) {\n    warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.', range);\n  } // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n\n\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  } // check capture modifier\n\n\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n\n\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({\n    value: value.trim(),\n    dynamic: dynamic\n  }, range);\n\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr(el, name) {\n  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n}\n\nfunction getBindingAttr(el, name, getStatic) {\n  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue);\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n\n    if (staticValue != null) {\n      return JSON.stringify(staticValue);\n    }\n  }\n} // note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\n\n\nfunction getAndRemoveAttr(el, name, removeFromMap) {\n  var val;\n\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n\n  return val;\n}\n\nfunction getAndRemoveAttrByRegex(el, name) {\n  var list = el.attrsList;\n\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr;\n    }\n  }\n}\n\nfunction rangeSetItem(item, range) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n\n  return item;\n}\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\n\n\nfunction genComponentModel(el, value, modifiers) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n\n  if (trim) {\n    valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n  }\n\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var assignment = genAssignmentCode(value, valueExpression);\n  el.model = {\n    value: \"(\" + value + \")\",\n    expression: JSON.stringify(value),\n    callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n  };\n}\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\n\n\nfunction genAssignmentCode(value, assignment) {\n  var res = parseModel(value);\n\n  if (res.key === null) {\n    return value + \"=\" + assignment;\n  } else {\n    return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n  }\n}\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\nfunction parseModel(val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      };\n    } else {\n      return {\n        exp: val,\n        key: null\n      };\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  };\n}\n\nfunction next() {\n  return str.charCodeAt(++index$1);\n}\n\nfunction eof() {\n  return index$1 >= len;\n}\n\nfunction isStringStart(chr) {\n  return chr === 0x22 || chr === 0x27;\n}\n\nfunction parseBracket(chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n\n  while (!eof()) {\n    chr = next();\n\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue;\n    }\n\n    if (chr === 0x5B) {\n      inBracket++;\n    }\n\n    if (chr === 0x5D) {\n      inBracket--;\n    }\n\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break;\n    }\n  }\n}\n\nfunction parseString(chr) {\n  var stringQuote = chr;\n\n  while (!eof()) {\n    chr = next();\n\n    if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n/*  */\n\n\nvar warn$1; // in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\n\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model(el, dir, _warn) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (true) {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n    return false;\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n    return false;\n  } else if (true) {\n    warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n  } // ensure runtime directive metadata\n\n\n  return true;\n}\n\nfunction genCheckboxModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n  addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n}\n\nfunction genRadioModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n  addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel(el, value, modifiers) {\n  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n\n  if (true) {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n  var valueExpression = '$event.target.value';\n\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', \"(\" + value + \")\");\n  addHandler(el, event, code, null, true);\n\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n/*  */\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\n\n\nfunction normalizeEvents(on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  } // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n  /* istanbul ignore if */\n\n\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1(event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n\n  return function onceHandler() {\n    var res = handler.apply(null, arguments);\n\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  };\n} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\n\n\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1(name, handler, capture, passive) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n\n    handler = original._wrapper = function (e) {\n      if ( // no bubbling, should always fire.\n      // this is just a safety net in case event.timeStamp is unreliable in\n      // certain weird environments...\n      e.target === e.currentTarget || // event is fired after handler attachment\n      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n      // #9681 QtWebEngine event.timeStamp is negative value\n      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n      // electron/nw.js app, since event.timeStamp will be using a different\n      // starting reference\n      e.target.ownerDocument !== document) {\n        return original.apply(this, arguments);\n      }\n    };\n  }\n\n  target$1.addEventListener(name, handler, supportsPassive ? {\n    capture: capture,\n    passive: passive\n  } : capture);\n}\n\nfunction remove$2(name, handler, capture, _target) {\n  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key]; // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n\n      if (cur === oldProps[key]) {\n        continue;\n      } // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n\n\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur; // avoid resetting cursor position when value is the same\n\n      var strCur = isUndef(cur) ? '' : String(cur);\n\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if ( // skip the update if old and new VDOM state is the same.\n    // `value` is handled separately because the DOM value may be temporarily\n    // out of sync with VDOM state due to focus, composition and modifiers.\n    // This  #4521 by skipping the unnecesarry `checked` update.\n    cur !== oldProps[key]) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n} // check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, checkVal) {\n  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n}\n\nfunction isNotInFocusAndDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true; // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n\n  try {\n    notInFocus = document.activeElement !== elm;\n  } catch (e) {}\n\n  return notInFocus && elm.value !== checkVal;\n}\n\nfunction isDirtyWithModifiers(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal);\n    }\n\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim();\n    }\n  }\n\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n}); // merge static and dynamic style data on the same vnode\n\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n} // normalize possible array / string values into Object\n\n\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n\n  return bindingStyle;\n}\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\n\n\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\n\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n\n  if (prop !== 'filter' && prop in emptyStyle) {\n    return prop;\n  }\n\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n\n    if (name in emptyStyle) {\n      return name;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n\n  for (name in newStyle) {\n    cur = newStyle[name];\n\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n/*  */\n\nvar whitespaceRE = /\\s+/;\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\n\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\n\n\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n\n    cur = cur.trim();\n\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n/*  */\n\n\nfunction resolveTransition(def$$1) {\n  if (!def$$1) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (typeof def$$1 === 'object') {\n    var res = {};\n\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n\n    extend(res, def$$1);\n    return res;\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation'; // Transition property/event sniffing\n\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\n\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n} // binding to window is necessary to make hot reload work in IE in strict mode\n\n\nvar raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n/* istanbul ignore next */\nfunction (fn) {\n  return fn();\n};\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n\n  if (!type) {\n    return cb();\n  }\n\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\n\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n/*  */\n\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm; // call leave callback now\n\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data)) {\n    return;\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration; // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if ( true && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n\n      enterHook && enterHook(el, cb);\n    });\n  } // start enter transition\n\n\n  beforeEnterHook && beforeEnterHook(el);\n\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm; // call enter callback now\n\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm();\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._leaveCb)) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if ( true && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    } // record leaving element\n\n\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n\n    beforeLeave && beforeLeave(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    leave && leave(el, cb);\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n} // only used in dev mode\n\n\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\n\n\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  }\n\n  var invokerFns = fn.fns;\n\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n/*  */\n// the directive module should be applied last, after all\n// built-in modules have been applied.\n\nvar modules = platformModules.concat(baseModules);\nvar patch = createPatchFunction({\n  nodeOps: nodeOps,\n  modules: modules\n});\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\n\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted(el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n      if (curOptions.some(function (o, i) {\n        return !looseEqual(o, prevOptions[i]);\n      })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple ? binding.value.some(function (v) {\n          return hasNoMatchingOption(v, curOptions);\n        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n\n  if (isMultiple && !Array.isArray(value)) {\n     true && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n    return;\n  }\n\n  var selected, option;\n\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n\n        return;\n      }\n    }\n  }\n\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  return options.every(function (o) {\n    return !looseEqual(o, value);\n  });\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) {\n    return;\n  }\n\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n/*  */\n// recursively search for possible transition defined inside the component root\n\n\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n    /* istanbul ignore if */\n\n    if (!value === !oldValue) {\n      return;\n    }\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n\n    if (transition$$1) {\n      vnode.data.show = true;\n\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n}; // in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\n\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options; // props\n\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  } // events.\n  // extract listeners and pass them directly to the transition methods\n\n\n  var listeners = options._parentListeners;\n\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nvar isNotTextNode = function (c) {\n  return c.tag || isAsyncPlaceholder(c);\n};\n\nvar isVShowDirective = function (d) {\n  return d.name === 'show';\n};\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n  render: function render(h) {\n    var this$1 = this;\n    var children = this.$slots.default;\n\n    if (!children) {\n      return;\n    } // filter out text nodes (possible whitespaces)\n\n\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n\n    if (!children.length) {\n      return;\n    } // warn multiple elements\n\n\n    if ( true && children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    var mode = this.mode; // warn invalid mode\n\n    if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    var rawChild = children[0]; // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    } // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    } // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n\n\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild); // mark v-show\n    // so that the transition module can hand over the control to the directive\n\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild;\n        }\n\n        var delayedLeave;\n\n        var performLeave = function () {\n          delayedLeave();\n        };\n\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\ndelete props.mode;\nvar TransitionGroup = {\n  props: props,\n  beforeMount: function beforeMount() {\n    var this$1 = this;\n    var update = this._update;\n\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;\n          (c.data || (c.data = {})).transition = transitionData;\n        } else if (true) {\n          var opts = c.componentOptions;\n          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n          warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    } // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n\n\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation); // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n\n    this._reflow = document.body.offsetHeight;\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (e && e.target !== el) {\n            return;\n          }\n\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      /* istanbul ignore if */\n\n\n      if (this._hasMove) {\n        return this._hasMove;\n      } // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n\n\n      var clone = el.cloneNode();\n\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n\n\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n/*  */\n// install platform specific utils\n\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents); // install platform patch function\n\nVue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\nVue.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n}; // devtools global hook\n\n/* istanbul ignore next */\n\n\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (true) {\n        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n      }\n    }\n\n    if ( true && config.productionTip !== false && typeof console !== 'undefined') {\n      console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n    }\n  }, 0);\n}\n/*  */\n\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\n\nfunction parseText(text, delimiters) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n  if (!tagRE.test(text)) {\n    return;\n  }\n\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n\n  while (match = tagRE.exec(text)) {\n    index = match.index; // push text token\n\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    } // tag token\n\n\n    var exp = parseFilters(match[1].trim());\n    tokens.push(\"_s(\" + exp + \")\");\n    rawTokens.push({\n      '@binding': exp\n    });\n    lastIndex = index + match[0].length;\n  }\n\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  };\n}\n/*  */\n\n\nfunction transformNode(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n\n  if ( true && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n\n    if (res) {\n      warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n    }\n  }\n\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n\n  var classBinding = getBindingAttr(el, 'class', false\n  /* getStatic */\n  );\n\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData(el) {\n  var data = '';\n\n  if (el.staticClass) {\n    data += \"staticClass:\" + el.staticClass + \",\";\n  }\n\n  if (el.classBinding) {\n    data += \"class:\" + el.classBinding + \",\";\n  }\n\n  return data;\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n/*  */\n\nfunction transformNode$1(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (true) {\n      var res = parseText(staticStyle, options.delimiters);\n\n      if (res) {\n        warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n      }\n    }\n\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false\n  /* getStatic */\n  );\n\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1(el) {\n  var data = '';\n\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + el.staticStyle + \",\";\n  }\n\n  if (el.styleBinding) {\n    data += \"style:(\" + el.styleBinding + \"),\";\n  }\n\n  return data;\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n/*  */\n\nvar decoder;\nvar he = {\n  decode: function decode(html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent;\n  }\n};\n/*  */\n\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n// (and which close themselves)\n\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n// Regular Expressions for parsing tags and attributes\n\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeRegExp.source + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp(\"^<\" + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\nvar doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page\n\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/; // Special Elements (can contain anything)\n\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992\n\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\nvar shouldIgnoreFirstNewline = function (tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n};\n\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) {\n    return decodingMap[match];\n  });\n}\n\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n\n  while (html) {\n    last = html; // Make sure we're not in a plaintext content element like script/style\n\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n\n            advance(commentEnd + 3);\n            continue;\n          }\n        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        } // Doctype:\n\n\n        var doctypeMatch = html.match(doctype);\n\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        } // End tag:\n\n\n        var endTagMatch = html.match(endTag);\n\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        } // Start tag:\n\n\n        var startTagMatch = parseStartTag();\n\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n\n          continue;\n        }\n      }\n\n      var text = void 0,\n          rest = void 0,\n          next = void 0;\n\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n\n          if (next < 0) {\n            break;\n          }\n\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text.replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n          .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n\n        if (options.chars) {\n          options.chars(text);\n        }\n\n        return '';\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n\n      if ( true && !stack.length && options.warn) {\n        options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\", {\n          start: index + html.length\n        });\n      }\n\n      break;\n    }\n  } // Clean up any remaining tags\n\n\n  parseEndTag();\n\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n\n      if ( true && options.outputSourceRange) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({\n        tag: tagName,\n        lowerCasedTag: tagName.toLowerCase(),\n        attrs: attrs,\n        start: match.start,\n        end: match.end\n      });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n\n    if (start == null) {\n      start = index;\n    }\n\n    if (end == null) {\n      end = index;\n    } // Find the closest opened tag of the same type\n\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if ( true && (i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\", {\n            start: stack[i].start,\n            end: stack[i].end\n          });\n        }\n\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      } // Remove the open elements from the stack\n\n\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n/*  */\n\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\nvar slotRE = /^v-slot(:|$)|^#/;\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\nvar decodeHTMLCached = cached(he.decode);\nvar emptySlotScopeToken = \"_empty_\"; // configurable state\n\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement(tag, attrs, parent) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  };\n}\n/**\n * Convert HTML string to AST.\n */\n\n\nfunction parse(template, options) {\n  warn$2 = options.warn || baseWarn;\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n\n  maybeComponent = function (el) {\n    return !!el.component || !isReservedTag(el.tag);\n  };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce(msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement(element) {\n    trimEndingWhitespace(element);\n\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    } // tree management\n\n\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (true) {\n          checkRootConstraints(element);\n        }\n\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (true) {\n        warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\", {\n          start: element.start\n        });\n      }\n    }\n\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"';\n          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    } // final children cleanup\n    // filter out scoped slots\n\n\n    element.children = element.children.filter(function (c) {\n      return !c.slotScope;\n    }); // remove trailing whitespace node again\n\n    trimEndingWhitespace(element); // check pre state\n\n    if (element.pre) {\n      inVPre = false;\n    }\n\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    } // apply post-transforms\n\n\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace(el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n\n      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints(el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', {\n        start: el.start\n      });\n    }\n\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start(tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n      /* istanbul ignore if */\n\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (true) {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.end = end;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated;\n          }, {});\n        }\n\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\"Invalid dynamic argument expression: attribute names cannot contain \" + \"spaces, quotes, <, >, / or =.\", {\n              start: attr.start + attr.name.indexOf(\"[\"),\n              end: attr.start + attr.name.length\n            });\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n         true && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.', {\n          start: element.start\n        });\n      } // apply pre-transforms\n\n\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n\n        if (true) {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n    end: function end(tag, start, end$1) {\n      var element = stack[stack.length - 1]; // pop stack\n\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n\n      if ( true && options.outputSourceRange) {\n        element.end = end$1;\n      }\n\n      closeElement(element);\n    },\n    chars: function chars(text, start, end) {\n      if (!currentParent) {\n        if (true) {\n          if (text === template) {\n            warnOnce('Component template requires a root element, rather than just text.', {\n              start: start\n            });\n          } else if (text = text.trim()) {\n            warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\", {\n              start: start\n            });\n          }\n        }\n\n        return;\n      } // IE textarea placeholder bug\n\n      /* istanbul ignore if */\n\n\n      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n        return;\n      }\n\n      var children = currentParent.children;\n\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n\n        var res;\n        var child;\n\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n\n        if (child) {\n          if ( true && options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment(text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n\n        if ( true && options.outputSourceRange) {\n          child.start = start;\n          child.end = end;\n        }\n\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root;\n}\n\nfunction processPre(el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs(el) {\n  var list = el.attrsList;\n  var len = list.length;\n\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement(element, options) {\n  processKey(element); // determine whether this is a plain element after\n  // removing structural attributes\n\n  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n\n  processAttrs(element);\n  return element;\n}\n\nfunction processKey(el) {\n  var exp = getBindingAttr(el, 'key');\n\n  if (exp) {\n    if (true) {\n      if (el.tag === 'template') {\n        warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\n      }\n\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\"Do not use v-for index as key on <transition-group> children, \" + \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true\n          /* tip */\n          );\n        }\n      }\n    }\n\n    el.key = exp;\n  }\n}\n\nfunction processRef(el) {\n  var ref = getBindingAttr(el, 'ref');\n\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor(el) {\n  var exp;\n\n  if (exp = getAndRemoveAttr(el, 'v-for')) {\n    var res = parseFor(exp);\n\n    if (res) {\n      extend(el, res);\n    } else if (true) {\n      warn$2(\"Invalid v-for expression: \" + exp, el.rawAttrsMap['v-for']);\n    }\n  }\n}\n\nfunction parseFor(exp) {\n  var inMatch = exp.match(forAliasRE);\n\n  if (!inMatch) {\n    return;\n  }\n\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n\n  return res;\n}\n\nfunction processIf(el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions(el, parent) {\n  var prev = findPrevElement(parent.children);\n\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (true) {\n    warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n  }\n}\n\nfunction findPrevElement(children) {\n  var i = children.length;\n\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i];\n    } else {\n      if ( true && children[i].text !== ' ') {\n        warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\", children[i]);\n      }\n\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition(el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce(el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n  if (once$$1 != null) {\n    el.once = true;\n  }\n} // handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n\n\nfunction processSlotContent(el) {\n  var slotScope;\n\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n\n    if ( true && slotScope) {\n      warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\n    }\n\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n    /* istanbul ignore if */\n    if ( true && el.attrsMap['v-for']) {\n      warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\n    }\n\n    el.slotScope = slotScope;\n  } // slot=\"xxx\"\n\n\n  var slotTarget = getBindingAttr(el, 'slot');\n\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  } // 2.6 v-slot syntax\n\n\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n\n      if (slotBinding) {\n        if (true) {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n          }\n\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\"<template v-slot> can only appear at the root level inside \" + \"the receiving the component\", el);\n          }\n        }\n\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n\n      if (slotBinding$1) {\n        if (true) {\n          if (!maybeComponent(el)) {\n            warn$2(\"v-slot can only be used on components or <template>.\", slotBinding$1);\n          }\n\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n          }\n\n          if (el.scopedSlots) {\n            warn$2(\"To avoid scope ambiguity, the default slot should also use \" + \"<template> syntax when there are other named slots.\", slotBinding$1);\n          }\n        } // add the component's children to its default slot\n\n\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true;\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now\n\n        el.children = []; // mark el non-plain so data gets generated\n\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName(binding) {\n  var name = binding.name.replace(slotRE, '');\n\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (true) {\n      warn$2(\"v-slot shorthand syntax requires a slot name.\", binding);\n    }\n  }\n\n  return dynamicArgRE.test(name) // dynamic [name]\n  ? {\n    name: name.slice(1, -1),\n    dynamic: true // static name\n\n  } : {\n    name: \"\\\"\" + name + \"\\\"\",\n    dynamic: false\n  };\n} // handle <slot/> outlets\n\n\nfunction processSlotOutlet(el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n\n    if ( true && el.key) {\n      warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\n    }\n  }\n}\n\nfunction processComponent(el) {\n  var binding;\n\n  if (binding = getBindingAttr(el, 'is')) {\n    el.component = binding;\n  }\n\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs(el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true; // modifiers\n\n      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier\n\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n\n      if (bindRE.test(name)) {\n        // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n\n        if ( true && value.trim().length === 0) {\n          warn$2(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\");\n        }\n\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n\n            if (name === 'innerHtml') {\n              name = 'innerHTML';\n            }\n          }\n\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n\n            if (!isDynamic) {\n              addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n              );\n            }\n          }\n        }\n\n        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) {\n        // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else {\n        // normal directives\n        name = name.replace(dirRE, ''); // parse arg\n\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n\n        if ( true && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (true) {\n        var res = parseText(value, delimiters);\n\n        if (res) {\n          warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n        }\n      }\n\n      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n\n      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor(el) {\n  var parent = el;\n\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true;\n    }\n\n    parent = parent.parent;\n  }\n\n  return false;\n}\n\nfunction parseModifiers(name) {\n  var match = name.match(modifierRE);\n\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) {\n      ret[m.slice(1)] = true;\n    });\n    return ret;\n  }\n}\n\nfunction makeAttrsMap(attrs) {\n  var map = {};\n\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if ( true && map[attrs[i].name] && !isIE && !isEdge) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n\n    map[attrs[i].name] = attrs[i].value;\n  }\n\n  return map;\n} // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\nfunction isTextTag(el) {\n  return el.tag === 'script' || el.tag === 'style';\n}\n\nfunction isForbiddenTag(el) {\n  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n/* istanbul ignore next */\n\nfunction guardIESVGBug(attrs) {\n  var res = [];\n\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n\n  return res;\n}\n\nfunction checkForAliasModel(el, value) {\n  var _el = el;\n\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n    }\n\n    _el = _el.parent;\n  }\n}\n/*  */\n\n\nfunction preTransformNode(el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n\n    if (!map['v-model']) {\n      return;\n    }\n\n    var typeBinding;\n\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + map['v-bind'] + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n      var branch0 = cloneASTElement(el); // process for on the main node\n\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      }); // 2. add radio else-if condition\n\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      }); // 3. other\n\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0;\n    }\n  }\n}\n\nfunction cloneASTElement(el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\nvar modules$1 = [klass$1, style$1, model$1];\n/*  */\n\nfunction text(el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n  }\n}\n/*  */\n\n\nfunction html(el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\nvar genStaticKeysCached = cached(genStaticKeys$1);\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\n\nfunction optimize(root, options) {\n  if (!root) {\n    return;\n  }\n\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n  markStatic$1(root); // second pass: mark static roots.\n\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1(keys) {\n  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n}\n\nfunction markStatic$1(node) {\n  node.static = isStatic(node);\n\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n      return;\n    }\n\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots(node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    } // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n\n\n    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n      node.staticRoot = true;\n      return;\n    } else {\n      node.staticRoot = false;\n    }\n\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic(node) {\n  if (node.type === 2) {\n    // expression\n    return false;\n  }\n\n  if (node.type === 3) {\n    // text\n    return true;\n  }\n\n  return !!(node.pre || !node.hasBindings && // no dynamic bindings\n  !node.if && !node.for && // not v-if or v-for or v-else\n  !isBuiltInTag(node.tag) && // not a built-in\n  isPlatformReservedTag(node.tag) && // not a component\n  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n}\n\nfunction isDirectChildOfTemplateFor(node) {\n  while (node.parent) {\n    node = node.parent;\n\n    if (node.tag !== 'template') {\n      return false;\n    }\n\n    if (node.for) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/*  */\n\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n}; // KeyboardEvent.key aliases\n\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n}; // #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\n\nvar genGuard = function (condition) {\n  return \"if(\" + condition + \")return null;\";\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers(events, isNative) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n\n  staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n  } else {\n    return prefix + staticHandlers;\n  }\n}\n\nfunction genHandler(handler) {\n  if (!handler) {\n    return 'function(){}';\n  }\n\n  if (Array.isArray(handler)) {\n    return \"[\" + handler.map(function (handler) {\n      return genHandler(handler);\n    }).join(',') + \"]\";\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value;\n    }\n\n    return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key]; // left/right\n\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = handler.modifiers;\n        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n          return !modifiers[keyModifier];\n        }).map(function (keyModifier) {\n          return \"$event.\" + keyModifier + \"Key\";\n        }).join('||'));\n      } else {\n        keys.push(key);\n      }\n    }\n\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n\n    var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n    return \"function($event){\" + code + handlerCode + \"}\";\n  }\n}\n\nfunction genKeyFilter(keys) {\n  return (// make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" + keys.map(genFilterCode).join('&&') + \")return null;\"\n  );\n}\n\nfunction genFilterCode(key) {\n  var keyVal = parseInt(key, 10);\n\n  if (keyVal) {\n    return \"$event.keyCode!==\" + keyVal;\n  }\n\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n}\n/*  */\n\n\nfunction on(el, dir) {\n  if ( true && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n\n  el.wrapListeners = function (code) {\n    return \"_g(\" + code + \",\" + dir.value + \")\";\n  };\n}\n/*  */\n\n\nfunction bind$1(el, dir) {\n  el.wrapData = function (code) {\n    return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n  };\n}\n/*  */\n\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n/*  */\n\nvar CodegenState = function CodegenState(options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n\n  this.maybeComponent = function (el) {\n    return !!el.component || !isReservedTag(el.tag);\n  };\n\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\nfunction generate(ast, options) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: \"with(this){return \" + code + \"}\",\n    staticRenderFns: state.staticRenderFns\n  };\n}\n\nfunction genElement(el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state);\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state);\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state);\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0';\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state);\n  } else {\n    // component or element\n    var code;\n\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n\n      if (!el.plain || el.pre && state.maybeComponent(el)) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n    } // module transforms\n\n\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n\n    return code;\n  }\n} // hoist static sub-trees out\n\n\nfunction genStatic(el, state) {\n  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n\n  var originalPreState = state.pre;\n\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n\n  state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n  state.pre = originalPreState;\n  return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n} // v-once\n\n\nfunction genOnce(el, state) {\n  el.onceProcessed = true;\n\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break;\n      }\n\n      parent = parent.parent;\n    }\n\n    if (!key) {\n       true && state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\n      return genElement(el, state);\n    }\n\n    return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n  } else {\n    return genStatic(el, state);\n  }\n}\n\nfunction genIf(el, state, altGen, altEmpty) {\n  el.ifProcessed = true; // avoid recursion\n\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n}\n\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\n  if (!conditions.length) {\n    return altEmpty || '_e()';\n  }\n\n  var condition = conditions.shift();\n\n  if (condition.exp) {\n    return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n  } else {\n    return \"\" + genTernaryExp(condition.block);\n  } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n  function genTernaryExp(el) {\n    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n  }\n}\n\nfunction genFor(el, state, altGen, altHelper) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n  if ( true && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n    state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true\n    /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n\n  return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n}\n\nfunction genData$2(el, state) {\n  var data = '{'; // directives first.\n  // directives may mutate the el's other properties before they are generated.\n\n  var dirs = genDirectives(el, state);\n\n  if (dirs) {\n    data += dirs + ',';\n  } // key\n\n\n  if (el.key) {\n    data += \"key:\" + el.key + \",\";\n  } // ref\n\n\n  if (el.ref) {\n    data += \"ref:\" + el.ref + \",\";\n  }\n\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  } // pre\n\n\n  if (el.pre) {\n    data += \"pre:true,\";\n  } // record original tag name for components using \"is\" attribute\n\n\n  if (el.component) {\n    data += \"tag:\\\"\" + el.tag + \"\\\",\";\n  } // module data generation functions\n\n\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  } // attributes\n\n\n  if (el.attrs) {\n    data += \"attrs:\" + genProps(el.attrs) + \",\";\n  } // DOM props\n\n\n  if (el.props) {\n    data += \"domProps:\" + genProps(el.props) + \",\";\n  } // event handlers\n\n\n  if (el.events) {\n    data += genHandlers(el.events, false) + \",\";\n  }\n\n  if (el.nativeEvents) {\n    data += genHandlers(el.nativeEvents, true) + \",\";\n  } // slot target\n  // only for non-scoped slots\n\n\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + el.slotTarget + \",\";\n  } // scoped slots\n\n\n  if (el.scopedSlots) {\n    data += genScopedSlots(el, el.scopedSlots, state) + \",\";\n  } // component v-model\n\n\n  if (el.model) {\n    data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n  } // inline-template\n\n\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n\n  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n  } // v-bind data wrap\n\n\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  } // v-on data wrap\n\n\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n\n  return data;\n}\n\nfunction genDirectives(el, state) {\n  var dirs = el.directives;\n\n  if (!dirs) {\n    return;\n  }\n\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n    }\n  }\n\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']';\n  }\n}\n\nfunction genInlineTemplate(el, state) {\n  var ast = el.children[0];\n\n  if ( true && (el.children.length !== 1 || ast.type !== 1)) {\n    state.warn('Inline-template components must have exactly one child element.', {\n      start: el.start\n    });\n  }\n\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n      return \"function(){\" + code + \"}\";\n    }).join(',') + \"]}\";\n  }\n}\n\nfunction genScopedSlots(el, slots, state) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    ;\n  }); // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n\n  var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n\n    while (parent) {\n      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {\n        needsForceUpdate = true;\n        break;\n      }\n\n      if (parent.if) {\n        needsKey = true;\n      }\n\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots).map(function (key) {\n    return genScopedSlot(slots[key], state);\n  }).join(',');\n  return \"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? \",null,false,\" + hash(generatedSlots) : \"\") + \")\";\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n\n  while (i) {\n    hash = hash * 33 ^ str.charCodeAt(--i);\n  }\n\n  return hash >>> 0;\n}\n\nfunction containsSlotChild(el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true;\n    }\n\n    return el.children.some(containsSlotChild);\n  }\n\n  return false;\n}\n\nfunction genScopedSlot(el, state) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\");\n  }\n\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot);\n  }\n\n  var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" + \"return \" + (el.tag === 'template' ? el.if && isLegacySyntax ? \"(\" + el.if + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\"; // reverse proxy v-slot without scope on this.$slots\n\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\";\n}\n\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n  var children = el.children;\n\n  if (children.length) {\n    var el$1 = children[0]; // optimize single v-for\n\n    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n      return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n    }\n\n    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n    var gen = altGenNode || genNode;\n    return \"[\" + children.map(function (c) {\n      return gen(c, state);\n    }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n  }\n} // determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\n\n\nfunction getNormalizationType(children, maybeComponent) {\n  var res = 0;\n\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n\n    if (el.type !== 1) {\n      continue;\n    }\n\n    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return needsNormalization(c.block);\n    })) {\n      res = 2;\n      break;\n    }\n\n    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return maybeComponent(c.block);\n    })) {\n      res = 1;\n    }\n  }\n\n  return res;\n}\n\nfunction needsNormalization(el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\n\nfunction genNode(node, state) {\n  if (node.type === 1) {\n    return genElement(node, state);\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node);\n  } else {\n    return genText(node);\n  }\n}\n\nfunction genText(text) {\n  return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n  : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n}\n\nfunction genComment(comment) {\n  return \"_e(\" + JSON.stringify(comment.text) + \")\";\n}\n\nfunction genSlot(el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {\n    return {\n      // slot props are camelized\n      name: camelize(attr.name),\n      value: attr.value,\n      dynamic: attr.dynamic\n    };\n  })) : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n\n  return res + ')';\n} // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\nfunction genComponent(componentName, el, state) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n}\n\nfunction genProps(props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n\n    if (prop.dynamic) {\n      dynamicProps += prop.name + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n    }\n  }\n\n  staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n\n  if (dynamicProps) {\n    return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n  } else {\n    return staticProps;\n  }\n} // #3895, #4268\n\n\nfunction transformSpecialNewlines(text) {\n  return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n/*  */\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\n\n\nvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\nvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\nfunction detectErrors(ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode(node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n\n        if (value) {\n          var range = node.rawAttrsMap[name];\n\n          if (name === 'v-for') {\n            checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n          } else {\n            checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n          }\n        }\n      }\n    }\n\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent(exp, text, warn, range) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n  }\n\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor(node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier(ident, type, text, warn, range) {\n  if (typeof ident === 'string') {\n    try {\n      new Function(\"var \" + ident + \"=_\");\n    } catch (e) {\n      warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n    }\n  }\n}\n\nfunction checkExpression(exp, text, warn, range) {\n  try {\n    new Function(\"return \" + exp);\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n    if (keywordMatch) {\n      warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n    } else {\n      warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n    }\n  }\n}\n/*  */\n\n\nvar range = 2;\n\nfunction generateCodeFrame(source, start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = source.length;\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) {\n          continue;\n        }\n\n        res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n        var lineLength = lines[j].length;\n\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n\n          count += lineLength + 1;\n        }\n      }\n\n      break;\n    }\n  }\n\n  return res.join('\\n');\n}\n\nfunction repeat$1(str, n) {\n  var result = '';\n\n  if (n > 0) {\n    while (true) {\n      // eslint-disable-line\n      if (n & 1) {\n        result += str;\n      }\n\n      n >>>= 1;\n\n      if (n <= 0) {\n        break;\n      }\n\n      str += str;\n    }\n  }\n\n  return result;\n}\n/*  */\n\n\nfunction createFunction(code, errors) {\n  try {\n    return new Function(code);\n  } catch (err) {\n    errors.push({\n      err: err,\n      code: code\n    });\n    return noop;\n  }\n}\n\nfunction createCompileToFunctionFn(compile) {\n  var cache = Object.create(null);\n  return function compileToFunctions(template, options, vm) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n    /* istanbul ignore if */\n\n    if (true) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n        }\n      }\n    } // check cache\n\n\n    var key = options.delimiters ? String(options.delimiters) + template : template;\n\n    if (cache[key]) {\n      return cache[key];\n    } // compile\n\n\n    var compiled = compile(template, options); // check compilation errors/tips\n\n    if (true) {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\"Error compiling template:\\n\\n\" + e.msg + \"\\n\\n\" + generateCodeFrame(template, e.start, e.end), vm);\n          });\n        } else {\n          warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n            return \"- \" + e;\n          }).join('\\n') + '\\n', vm);\n        }\n      }\n\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) {\n            return tip(e.msg, vm);\n          });\n        } else {\n          compiled.tips.forEach(function (msg) {\n            return tip(msg, vm);\n          });\n        }\n      }\n    } // turn code into functions\n\n\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors);\n    }); // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n\n    /* istanbul ignore if */\n\n    if (true) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n          var err = ref.err;\n          var code = ref.code;\n          return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n        }).join('\\n'), vm);\n      }\n    }\n\n    return cache[key] = res;\n  };\n}\n/*  */\n\n\nfunction createCompilerCreator(baseCompile) {\n  return function createCompiler(baseOptions) {\n    function compile(template, options) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if ( true && options.outputSourceRange) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = {\n              msg: msg\n            };\n\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n\n            (tip ? tips : errors).push(data);\n          };\n        } // merge custom modules\n\n\n        if (options.modules) {\n          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n        } // merge custom directives\n\n\n        if (options.directives) {\n          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n        } // copy other options\n\n\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n      var compiled = baseCompile(template.trim(), finalOptions);\n\n      if (true) {\n        detectErrors(compiled.ast, warn);\n      }\n\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled;\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    };\n  };\n}\n/*  */\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\n\n\nvar createCompiler = createCompilerCreator(function baseCompile(template, options) {\n  var ast = parse(template.trim(), options);\n\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  };\n});\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n/*  */\n// check whether current browser encodes a char inside attribute values\n\nvar div;\n\nfunction getShouldDecode(href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0;\n} // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML;\n});\nvar mount = Vue.prototype.$mount;\n\nVue.prototype.$mount = function (el, hydrating) {\n  el = el && query(el);\n  /* istanbul ignore if */\n\n  if (el === document.body || el === document.documentElement) {\n     true && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n    return this;\n  }\n\n  var options = this.$options; // resolve template/el and convert to render function\n\n  if (!options.render) {\n    var template = options.template;\n\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n\n          if ( true && !template) {\n            warn(\"Template element not found or is empty: \" + options.template, this);\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (true) {\n          warn('invalid template option:' + template, this);\n        }\n\n        return this;\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n\n    if (template) {\n      /* istanbul ignore if */\n      if ( true && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: \"development\" !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n      /* istanbul ignore if */\n\n      if ( true && config.performance && mark) {\n        mark('compile end');\n        measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n      }\n    }\n  }\n\n  return mount.call(this, el, hydrating);\n};\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\n\n\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nVue.compile = compileToFunctions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vue);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9hMDI2Il0sIm5hbWVzIjpbImVtcHR5T2JqZWN0IiwiT2JqZWN0IiwiZnJlZXplIiwiaXNVbmRlZiIsInYiLCJ1bmRlZmluZWQiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsInZhbHVlIiwiaXNPYmplY3QiLCJvYmoiLCJfdG9TdHJpbmciLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInRvUmF3VHlwZSIsImNhbGwiLCJzbGljZSIsImlzUGxhaW5PYmplY3QiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwidmFsIiwibiIsInBhcnNlRmxvYXQiLCJTdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsImlzUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsIkFycmF5IiwiaXNBcnJheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b051bWJlciIsImlzTmFOIiwibWFrZU1hcCIsInN0ciIsImV4cGVjdHNMb3dlckNhc2UiLCJtYXAiLCJjcmVhdGUiLCJsaXN0Iiwic3BsaXQiLCJpIiwibGVuZ3RoIiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0IiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJwb2x5ZmlsbEJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9sZW5ndGgiLCJuYXRpdmVCaW5kIiwiYmluZCIsIkZ1bmN0aW9uIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheUIiLCJldmVyeSIsImUiLCJEYXRlIiwiZ2V0VGltZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsImNvbmZpZyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJwcm9jZXNzIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImFzeW5jIiwiX2xpZmVjeWNsZUhvb2tzIiwidW5pY29kZVJlZ0V4cCIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJSZWdFeHAiLCJzb3VyY2UiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJ3aW5kb3ciLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJpc1BoYW50b21KUyIsImlzRkYiLCJtYXRjaCIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiZ2xvYmFsIiwiZW52IiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsIndhcm4iLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImVycm9yIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm9wdGlvbnMiLCJjaWQiLCJfaXNWdWUiLCIkb3B0aW9ucyIsImNvbnN0cnVjdG9yIiwibmFtZSIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwicHVzaCIsInVpZCIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsInRhcmdldCIsImFkZERlcCIsIm5vdGlmeSIsInNvcnQiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJwb3BUYXJnZXQiLCJwb3AiLCJWTm9kZSIsInRhZyIsImRhdGEiLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwYXJlbnQiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiY2hpbGQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJmb3JFYWNoIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJncyIsImxlbiIsInJlc3VsdCIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic2hvdWxkT2JzZXJ2ZSIsInRvZ2dsZU9ic2VydmluZyIsIk9ic2VydmVyIiwidm1Db3VudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlJCQxIiwiaXRlbXMiLCJvYnNlcnZlIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsImZyb20iLCJ0b1ZhbCIsImZyb21WYWwiLCJtZXJnZURhdGFPckZuIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiZGVkdXBlSG9va3MiLCJob29rcyIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJ0eXBlIiwia2V5JDEiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwiZGVmJCQxIiwibWVyZ2VPcHRpb25zIiwiX2Jhc2UiLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsIkJvb2xlYW4iLCJzdHJpbmdJbmRleCIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkT2JzZXJ2ZSIsImFzc2VydFByb3AiLCJkZWZhdWx0IiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsImdldEludmFsaWRUeXBlTWVzc2FnZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJ0IiwiaXNTYW1lVHlwZSIsIm1lc3NhZ2UiLCJyZWNlaXZlZFR5cGUiLCJleHBlY3RlZFZhbHVlIiwic3R5bGVWYWx1ZSIsInJlY2VpdmVkVmFsdWUiLCJpc0V4cGxpY2FibGUiLCJpc0Jvb2xlYW4iLCJOdW1iZXIiLCJleHBsaWNpdFR5cGVzIiwic29tZSIsImVsZW0iLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJlcnJvckNhcHR1cmVkIiwiY2FwdHVyZSIsImdsb2JhbEhhbmRsZUVycm9yIiwiaW52b2tlV2l0aEVycm9ySGFuZGxpbmciLCJoYW5kbGVyIiwiX2hhbmRsZWQiLCJsb2dFcnJvciIsImlzVXNpbmdNaWNyb1Rhc2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJ0aW1lckZ1bmMiLCJQcm9taXNlIiwicCIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImNoYXJhY3RlckRhdGEiLCJzZXRJbW1lZGlhdGUiLCJuZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJtYXJrIiwibWVhc3VyZSIsInBlcmYiLCJjbGVhck1hcmtzIiwiY2xlYXJNZWFzdXJlcyIsInN0YXJ0VGFnIiwiZW5kVGFnIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsIndhcm5SZXNlcnZlZFByZWZpeCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCIkZGF0YSIsImdldEhhbmRsZXIiLCJoYW5kbGVycyIsInJlbmRlciIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJzZWVuT2JqZWN0cyIsInRyYXZlcnNlIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImlzRnJvemVuIiwiZGVwSWQiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsImFyZ3VtZW50cyQxIiwidXBkYXRlTGlzdGVuZXJzIiwib24iLCJvbGRPbiIsInJlbW92ZSQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib2xkIiwiZXZlbnQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwibm9ybWFsaXplU2NvcGVkU2xvdHMiLCJub3JtYWxTbG90cyIsInByZXZTbG90cyIsImhhc05vcm1hbFNsb3RzIiwiaXNTdGFibGUiLCIkc3RhYmxlIiwiJGtleSIsIl9ub3JtYWxpemVkIiwiJGhhc05vcm1hbCIsIm5vcm1hbGl6ZVNjb3BlZFNsb3QiLCJrZXkkMiIsInByb3h5Tm9ybWFsU2xvdCIsInByb3h5IiwicmVuZGVyTGlzdCIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwiJHNjb3BlZFNsb3RzIiwibm9kZXMiLCIkc2xvdHMiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwibG9vcCIsImRvbVByb3BzIiwiY2FtZWxpemVkS2V5IiwiaHlwaGVuYXRlZEtleSIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJzdGF0aWNSZW5kZXJGbnMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljS2V5cyIsImNvbnRlbnRIYXNoS2V5IiwiYmluZER5bmFtaWNLZXlzIiwiYmFzZU9iaiIsInZhbHVlcyIsInByZXBlbmRNb2RpZmllciIsInN5bWJvbCIsImluc3RhbGxSZW5kZXJIZWxwZXJzIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsIl9nIiwiX2QiLCJfcCIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwidGhpcyQxIiwiY29udGV4dFZtIiwiX29yaWdpbmFsIiwiaXNDb21waWxlZCIsIl9jb21waWxlZCIsIm5lZWROb3JtYWxpemF0aW9uIiwibGlzdGVuZXJzIiwiaW5qZWN0aW9ucyIsInNjb3BlZFNsb3RzIiwiX3Njb3BlSWQiLCJfYyIsImQiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImNsb25lIiwiZGV2dG9vbHNNZXRhIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJoeWRyYXRpbmciLCJfaXNEZXN0cm95ZWQiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsImFjdGl2ZUluc3RhbmNlIiwiJG1vdW50Iiwib2xkVm5vZGUiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsImluc2VydCIsIl9pc01vdW50ZWQiLCJjYWxsSG9vayIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRlc3Ryb3kiLCIkZGVzdHJveSIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwiYWJzdHJhY3QiLCJpbnN0YWxsQ29tcG9uZW50SG9va3MiLCJfaXNDb21wb25lbnQiLCJfcGFyZW50Vm5vZGUiLCJpbmxpbmVUZW1wbGF0ZSIsInRvTWVyZ2UiLCJfbWVyZ2VkIiwibWVyZ2VIb29rJDEiLCJmMSIsImYyIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsIiR2bm9kZSIsInByZSIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsImluaXRSZW5kZXIiLCJfdm5vZGUiLCJwYXJlbnRWbm9kZSIsIl9yZW5kZXJDaGlsZHJlbiIsInBhcmVudERhdGEiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJfcGFyZW50TGlzdGVuZXJzIiwiY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIiwicmVuZGVyTWl4aW4iLCJWdWUiLCIkbmV4dFRpY2siLCJfcmVuZGVyIiwicmVmIiwicmVuZGVyRXJyb3IiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwidG9TdHJpbmdUYWciLCJmYWN0b3J5IiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJvd25lciIsIm93bmVycyIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsInN5bmMiLCJ0aW1lckxvYWRpbmciLCJ0aW1lclRpbWVvdXQiLCIkb24iLCJmb3JjZVJlbmRlciIsInJlbmRlckNvbXBsZXRlZCIsIiRmb3JjZVVwZGF0ZSIsImNsZWFyVGltZW91dCIsInJlamVjdCIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCJyZW1vdmUkMSIsIiRvZmYiLCJfdGFyZ2V0Iiwib25jZUhhbmRsZXIiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsIiRvbmNlIiwiaSQxIiwiY2JzIiwiJGVtaXQiLCJsb3dlckNhc2VFdmVudCIsInNldEFjdGl2ZUluc3RhbmNlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsInJlc3RvcmVBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9fdnVlX18iLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIldhdGNoZXIiLCJiZWZvcmUiLCJyZW5kZXJDaGlsZHJlbiIsIm5ld1Njb3BlZFNsb3RzIiwib2xkU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljU2NvcGVkU2xvdCIsIm5lZWRzRm9yY2VVcGRhdGUiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCJpc0luSW5hY3RpdmVUcmVlIiwiZGlyZWN0IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiY3VycmVudEZsdXNoVGltZXN0YW1wIiwiZ2V0Tm93Iiwibm93IiwiY3JlYXRlRXZlbnQiLCJ0aW1lU3RhbXAiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInJ1biIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwiZW1pdCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlR2V0dGVySW52b2tlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJpbml0VXNlIiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsIm1peGluIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwia2VlcEFsaXZlSW5zdGFuY2UiLCJmaWx0ZXIiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiY3VycmVudCIsImNhY2hlZCQkMSIsInBhdHRlcm5UeXBlcyIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsIm1vdW50ZWQiLCJyZWYkMSIsInBhcnNlSW50IiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlZmluZVJlYWN0aXZlIiwiZGVsZXRlIiwib2JzZXJ2YWJsZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSIsImNvbnZlcnRFbnVtZXJhdGVkVmFsdWUiLCJpc0ZhbHN5QXR0clZhbHVlIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmeUFycmF5Iiwic3RyaW5naWZ5T2JqZWN0Iiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJpc1ByZVRhZyIsInVua25vd25FbGVtZW50Q2FjaGUiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInNldFN0eWxlU2NvcGUiLCJzY29wZUlkIiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwiaWdub3JlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJuZXN0ZWQiLCJvd25lckFycmF5Iiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJpJDIiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsIm9sZEFyZyIsImFyZyIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsImJhc2VTZXRBdHRyIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInJhbmdlIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJkeW5hbWljIiwicmFuZ2VTZXRJdGVtIiwicGxhaW4iLCJhZGRBdHRyIiwiZHluYW1pY0F0dHJzIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiaXNEeW5hbWljQXJnIiwicHJlcGVuZE1vZGlmaWVyTWFya2VyIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRSYXdCaW5kaW5nQXR0ciIsInJhd0F0dHJzTWFwIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwidmFsdWUkMSIsInR5cGVCaW5kaW5nIiwiYmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciQxIiwicmVtb3ZlJDIiLCJ1c2VNaWNyb3Rhc2tGaXgiLCJhZGQkMSIsImF0dGFjaGVkVGltZXN0YW1wIiwiX3dyYXBwZXIiLCJjdXJyZW50VGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsInVwZGF0ZURPTUxpc3RlbmVycyIsInN2Z0NvbnRhaW5lciIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJoIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsImlzTm90VGV4dE5vZGUiLCJpc1ZTaG93RGlyZWN0aXZlIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJiZWZvcmVNb3VudCIsImtlcHQiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93IiwiYm9keSIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsInJhd1Rva2VucyIsInRva2VuVmFsdWUiLCJleGVjIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQxIiwic3R5bGUkMSIsImRlY29kZXIiLCJoZSIsImRlY29kZSIsImh0bWwiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJhdHRyaWJ1dGUiLCJkeW5hbWljQXJnQXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsInJlIiwicGFyc2VIVE1MIiwic3RhY2siLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwib3V0cHV0U291cmNlUmFuZ2UiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJkeW5hbWljQXJnUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJzbG90UkUiLCJsaW5lQnJlYWtSRSIsIndoaXRlc3BhY2VSRSQxIiwiaW52YWxpZEF0dHJpYnV0ZVJFIiwiZGVjb2RlSFRNTENhY2hlZCIsImVtcHR5U2xvdFNjb3BlVG9rZW4iLCJ3YXJuJDIiLCJ0cmFuc2Zvcm1zIiwicHJlVHJhbnNmb3JtcyIsInBvc3RUcmFuc2Zvcm1zIiwicGxhdGZvcm1Jc1ByZVRhZyIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsIm1heWJlQ29tcG9uZW50IiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInBhcnNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwid2hpdGVzcGFjZU9wdGlvbiIsIndoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJlbGVtZW50IiwidHJpbUVuZGluZ1doaXRlc3BhY2UiLCJwcm9jZXNzZWQiLCJwcm9jZXNzRWxlbWVudCIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImNoZWNrUm9vdENvbnN0cmFpbnRzIiwiYWRkSWZDb25kaXRpb24iLCJibG9jayIsImZvcmJpZGRlbiIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJzbG90U2NvcGUiLCJzbG90VGFyZ2V0IiwibGFzdE5vZGUiLCJjb21tZW50cyIsInN0YXJ0JDEiLCJndWFyZElFU1ZHQnVnIiwiY3VtdWxhdGVkIiwiaXNGb3JiaWRkZW5UYWciLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwiZW5kJDEiLCJpc1RleHRUYWciLCJwcm9jZXNzS2V5IiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90Q29udGVudCIsInByb2Nlc3NTbG90T3V0bGV0IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImZvciIsIml0ZXJhdG9yMiIsIml0ZXJhdG9yMSIsImNoZWNrSW5Gb3IiLCJwYXJzZUZvciIsImluTWF0Y2giLCJhbGlhcyIsIml0ZXJhdG9yTWF0Y2giLCJmaW5kUHJldkVsZW1lbnQiLCJjb25kaXRpb24iLCJpZkNvbmRpdGlvbnMiLCJzbG90VGFyZ2V0RHluYW1pYyIsInNsb3RCaW5kaW5nIiwiZ2V0U2xvdE5hbWUiLCJzbG90QmluZGluZyQxIiwiZHluYW1pYyQxIiwic2xvdENvbnRhaW5lciIsInNsb3ROYW1lIiwic3luY0dlbiIsImlzRHluYW1pYyIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiY2hlY2tGb3JBbGlhc01vZGVsIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJfZWwiLCJwcmVUcmFuc2Zvcm1Ob2RlIiwiaWZDb25kaXRpb24iLCJpZkNvbmRpdGlvbkV4dHJhIiwiaGFzRWxzZSIsImVsc2VJZkNvbmRpdGlvbiIsImJyYW5jaDAiLCJjbG9uZUFTVEVsZW1lbnQiLCJicmFuY2gxIiwiYnJhbmNoMiIsIm1vZGVsJDEiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJiYXNlT3B0aW9ucyIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwibCQxIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290IiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwiZm5JbnZva2VSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsInByZWZpeCIsInN0YXRpY0hhbmRsZXJzIiwiZHluYW1pY0hhbmRsZXJzIiwiaGFuZGxlckNvZGUiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0Z1bmN0aW9uSW52b2NhdGlvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJvbmNlSWQiLCJnZW5lcmF0ZSIsImFzdCIsInN0YXRlIiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEkMiIsIm9yaWdpbmFsUHJlU3RhdGUiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImNvbnRhaW5zU2xvdENoaWxkIiwibmVlZHNLZXkiLCJnZW5lcmF0ZWRTbG90cyIsImdlblNjb3BlZFNsb3QiLCJpc0xlZ2FjeVN5bnRheCIsInJldmVyc2VQcm94eSIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsIm5vcm1hbGl6YXRpb25UeXBlJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwic3RhdGljUHJvcHMiLCJkeW5hbWljUHJvcHMiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwiY291bnQiLCJyZXBlYXQkMSIsImxpbmVMZW5ndGgiLCJwYWQiLCJsZW5ndGgkMSIsIm1pbiIsImNyZWF0ZUZ1bmN0aW9uIiwiZXJyb3JzIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJ3YXJuJCQxIiwiY29tcGlsZWQiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiZmluYWxPcHRpb25zIiwibGVhZGluZ1NwYWNlTGVuZ3RoIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaHJlZiIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFLQTtBQUVBLElBQUlBLFdBQVcsR0FBR0MsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxDQUFsQixDLENBRUE7QUFDQTs7QUFDQSxTQUFTQyxPQUFULENBQWtCQyxDQUFsQixFQUFxQjtBQUNuQixTQUFPQSxD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VixTQUFTLENBQUN0ckIsU0FBakI7QUFDRDtBQUNGOztBQUVEOVYsR0FBRyxDQUFDaWdDLE9BQUosR0FBY0Msa0JBQWQ7QUFFZWxnQyxrRUFBZixFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5lc20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjEwXG4gKiAoYykgMjAxNC0yMDE5IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIChcbiAgICBpc0RlZih2YWwpICYmXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAqL1xudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xudmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG52YXIgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgIC8vIG9yZGVyXG4gICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmIChoYXNQcm90bykge1xuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICApIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHZhciByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qJFwiKSkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcyksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlIChuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICB2YXIgbWVzc2FnZSA9IFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKTtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIHZhciByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICB2YXIgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcbiAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBcIiB3aXRoIHZhbHVlIFwiICsgZXhwZWN0ZWRWYWx1ZTtcbiAgfVxuICBtZXNzYWdlICs9IFwiLCBnb3QgXCIgKyByZWNlaXZlZFR5cGUgKyBcIiBcIjtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gXCJ3aXRoIHZhbHVlIFwiICsgcmVjZWl2ZWRWYWx1ZSArIFwiLlwiO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIChcIlwiICsgKE51bWJlcih2YWx1ZSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgdmFyIGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4gKCkge1xuICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHJldHVybiBhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nOyB9KVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgLy8gRGVhY3RpdmF0ZSBkZXBzIHRyYWNraW5nIHdoaWxlIHByb2Nlc3NpbmcgZXJyb3IgaGFuZGxlciB0byBhdm9pZCBwb3NzaWJsZSBpbmZpbml0ZSByZW5kZXJpbmcuXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZXgvaXNzdWVzLzE1MDVcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIGlmICh2bSkge1xuICAgICAgdmFyIGN1ciA9IHZtO1xuICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgaGFuZGxlcixcbiAgY29udGV4dCxcbiAgYXJncyxcbiAgdm0sXG4gIGluZm9cbikge1xuICB2YXIgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykgJiYgIXJlcy5faGFuZGxlZCkge1xuICAgICAgcmVzLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyArIFwiIChQcm9taXNlL2FzeW5jKVwiKTsgfSk7XG4gICAgICAvLyBpc3N1ZSAjOTUxMVxuICAgICAgLy8gYXZvaWQgY2F0Y2ggdHJpZ2dlcmluZyBtdWx0aXBsZSB0aW1lcyB3aGVuIG5lc3RlZCBjYWxsc1xuICAgICAgcmVzLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSB0aHJvd3MgdGhlIG9yaWdpbmFsIGVycm9yIGluIHRoZSBoYW5kbGVyLFxuICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXG4vLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbi8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4vLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbi8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cbi8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXG4vLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbnZhciB0aW1lckZ1bmM7XG5cbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbikpIHtcbiAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgdmFyIGNvdW50ZXIgPSAxO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgLy8gVGVjaGluaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIHdhcm5SZXNlcnZlZFByZWZpeCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXFxcIiRkYXRhLlwiICsga2V5ICsgXCJcXFwiIGJlY2F1c2UgXCIgK1xuICAgICAgJ3Byb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCBcIiRcIiBvciBcIl9cIiBhcmUgbm90IHByb3hpZWQgaW4gdGhlIFZ1ZSBpbnN0YW5jZSB0byAnICtcbiAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cyQxLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgdmFyIHNsb3RzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzLFxuICBwcmV2U2xvdHNcbikge1xuICB2YXIgcmVzO1xuICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICBpZiAoIXNsb3RzKSB7XG4gICAgcmVzID0ge307XG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgfSBlbHNlIGlmIChcbiAgICBpc1N0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBrZXkgPT09IHByZXZTbG90cy4ka2V5ICYmXG4gICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5JDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5JDFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5JDEsIHNsb3RzW2tleSQxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkkMiBpbiByZXMpKSB7XG4gICAgICByZXNba2V5JDJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMik7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICB2YXIgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgcmV0dXJuIHJlcyAmJiAoXG4gICAgICByZXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAocmVzLmxlbmd0aCA9PT0gMSAmJiByZXNbMF0uaXNDb21tZW50KSAvLyAjOTY1OFxuICAgICkgPyB1bmRlZmluZWRcbiAgICAgIDogcmVzXG4gIH07XG4gIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcbiAgLy8gb24gdGhpcy4kc2xvdHMgYmVjYXVzZSB0aGUgdXNhZ2UgaXMgc2VtYW50aWNhbGx5IGEgbm9ybWFsIHNsb3QuXG4gIGlmIChmbi5wcm94eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICBnZXQ6IG5vcm1hbGl6ZWQsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRcbn1cblxuZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNsb3RzW2tleV07IH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXMsXG4gIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICBoYXNEeW5hbWljS2V5cyxcbiAgY29udGVudEhhc2hLZXlcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlaWNhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICkge1xuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmIGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxudmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdWVzIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb25seSBhIHNpbmdsZSBub2RlLCBhbGxvdyBpdFxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZub2RlID0gdm5vZGVbMF07XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3Jcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKG93bmVyICYmIGlzRGVmKGZhY3Rvcnkub3duZXJzKSAmJiBmYWN0b3J5Lm93bmVycy5pbmRleE9mKG93bmVyKSA9PT0gLTEpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgIHZhciBvd25lcnMgPSBmYWN0b3J5Lm93bmVycyA9IFtvd25lcl07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuICAgIHZhciB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgIHZhciB0aW1lclRpbWVvdXQgPSBudWxsXG5cbiAgICA7KG93bmVyKS4kb24oJ2hvb2s6ZGVzdHJveWVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlKG93bmVycywgb3duZXIpOyB9KTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAob3duZXJzW2ldKS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRpbWVyTG9hZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lckxvYWRpbmcpO1xuICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlICgpIHtcbiAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG5cbiAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gIHZhciBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXG4gICAgKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChvbGRTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIW9sZFNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG52YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wXG4gICkge1xuICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgIC8vIHdlbGwuXG4gICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xucmVuZGVyTWl4aW4oVnVlKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgb2JzZXJ2ZShvYmopO1xuICAgIHJldHVybiBvYmpcbiAgfTtcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjYuMTAnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG52YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChcbiAgICBvbGRWbm9kZSxcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleCxcbiAgICByZW1vdmVPbmx5XG4gICkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydtb3VzZXVwJzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG52YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxudmFyIHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc2FycnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICkge1xuICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0J1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xudmFyIG5jbmFtZSA9IFwiW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKlwiO1xudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxudmFyIGNvbW1lbnQgPSAvXjwhXFwtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnLFxuICAnJiMzOTsnOiBcIidcIlxufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5fCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YXJ0VGFnTWF0Y2gudGFnTmFtZSwgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgYWR2YW5jZSh0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0LCBpbmRleCAtIHRleHQubGVuZ3RoLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIiksIHsgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGggfSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChkeW5hbWljQXJnQXR0cmlidXRlKSB8fCBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIGF0dHIuZW5kID0gaW5kZXg7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxuICAgICAgfTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxccyovKS5sZW5ndGg7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICB7IHN0YXJ0OiBzdGFja1tpXS5zdGFydCwgZW5kOiBzdGFja1tpXS5lbmQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xudmFyIGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZztcblxudmFyIHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuXG52YXIgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xudmFyIHdoaXRlc3BhY2VSRSQxID0gL1xccysvZztcblxudmFyIGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbnZhciBlbXB0eVNsb3RTY29wZVRva2VuID0gXCJfZW1wdHlfXCI7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG52YXIgbWF5YmVDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnOiB0YWcsXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICByYXdBdHRyc01hcDoge30sXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICBtYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2csIHJhbmdlKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnLCByYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG4gICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICBlbGVtZW50ID0gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgIGlmICghc3RhY2subGVuZ3RoICYmIGVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCIsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAvLyBrZWVwIGl0IGluIHRoZSBjaGlsZHJlbiBsaXN0IHNvIHRoYXQgdi1lbHNlKC1pZikgY29uZGl0aW9ucyBjYW5cbiAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJ1xuICAgICAgICAgIDsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmFsIGNoaWxkcmVuIGNsZWFudXBcbiAgICAvLyBmaWx0ZXIgb3V0IHNjb3BlZCBzbG90c1xuICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIShjKS5zbG90U2NvcGU7IH0pO1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcblxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgIGlmICghaW5QcmUpIHtcbiAgICAgIHZhciBsYXN0Tm9kZTtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnXG4gICAgICApIHtcbiAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJyxcbiAgICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBvdXRwdXRTb3VyY2VSYW5nZTogb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5LCBzdGFydCQxLCBlbmQpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgZWxlbWVudC5yYXdBdHRyc01hcCA9IGVsZW1lbnQuYXR0cnNMaXN0LnJlZHVjZShmdW5jdGlvbiAoY3VtdWxhdGVkLCBhdHRyKSB7XG4gICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICBcInNwYWNlcywgcXVvdGVzLCA8LCA+LCAvIG9yID0uXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKHRhZywgc3RhcnQsIGVuZCQxKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQkMTtcbiAgICAgIH1cbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmICghaW5QcmUgJiYgd2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlUkUkMSwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwiRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBcIiArXG4gICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLFxuICAgICAgICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKSxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCIsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4vLyBlLmcuIDx0ZW1wbGF0ZSBzbG90PVwieHh4XCI+LCA8ZGl2IHNsb3Qtc2NvcGU9XCJ4eHhcIj5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgdmFyIHNsb3RTY29wZTtcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgfVxuXG4gIC8vIHNsb3Q9XCJ4eHhcIlxuICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgdGhlIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZiA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMgPSByZWYuZHluYW1pYztcbiAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHYtc2xvdCBvbiBjb21wb25lbnQsIGRlbm90ZXMgZGVmYXVsdCBzbG90XG4gICAgICB2YXIgc2xvdEJpbmRpbmckMSA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nJDEpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIW1heWJlQ29tcG9uZW50KGVsKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgdmFyIHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xuICAgICAgICB2YXIgcmVmJDEgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyQxKTtcbiAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgIHZhciBkeW5hbWljJDEgPSByZWYkMS5keW5hbWljO1xuICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHNsb3RzW25hbWUkMV0gPSBjcmVhdGVBU1RFbGVtZW50KCd0ZW1wbGF0ZScsIFtdLCBlbCk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWMkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGMucGFyZW50ID0gc2xvdENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90U2NvcGUgPSBzbG90QmluZGluZyQxLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNsb3ROYW1lIChiaW5kaW5nKSB7XG4gIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gIGlmICghbmFtZSkge1xuICAgIGlmIChiaW5kaW5nLm5hbWVbMF0gIT09ICcjJykge1xuICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJ2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5cIixcbiAgICAgICAgYmluZGluZ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgLy8gZHluYW1pYyBbbmFtZV1cbiAgICA/IHsgbmFtZTogbmFtZS5zbGljZSgxLCAtMSksIGR5bmFtaWM6IHRydWUgfVxuICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgOiB7IG5hbWU6IChcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiksIGR5bmFtaWM6IGZhbHNlIH1cbn1cblxuLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiLFxuICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIHZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgKFwiVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXFxcInYtYmluZDpcIiArIG5hbWUgKyBcIlxcXCJcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3AgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpO1xuICAgICAgICAgICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgKFwiXFxcInVwZGF0ZTpcXFwiKyhcIiArIG5hbWUgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldLFxuICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJvcCkgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgdHlwZUJpbmRpbmc7XG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgfVxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgIH1cblxuICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcbiAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgIGJyYW5jaDAuaWYgPSBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J2NoZWNrYm94J1wiICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxuICAgICAgICBibG9jazogYnJhbmNoMFxuICAgICAgfSk7XG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgIHZhciBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgIH0pO1xuICAgICAgLy8gMy4gb3RoZXJcbiAgICAgIHZhciBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycyxzdGFydCxlbmQscmF3QXR0cnNNYXAnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKig/OltcXHckXSspP1xccypcXCgvO1xudmFyIGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJ1teJ10qPyddfFxcW1wiW15cIl0qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKiQvO1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xudmFyIGtleU5hbWVzID0ge1xuICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cbiAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZVxuKSB7XG4gIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gIHZhciBzdGF0aWNIYW5kbGVycyA9IFwiXCI7XG4gIHZhciBkeW5hbWljSGFuZGxlcnMgPSBcIlwiO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHZhciBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcbiAgICBpZiAoZXZlbnRzW25hbWVdICYmIGV2ZW50c1tuYW1lXS5keW5hbWljKSB7XG4gICAgICBkeW5hbWljSGFuZGxlcnMgKz0gbmFtZSArIFwiLFwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljSGFuZGxlcnMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgc3RhdGljSGFuZGxlcnMgPSBcIntcIiArIChzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCJfZChcIiArIHN0YXRpY0hhbmRsZXJzICsgXCIsW1wiICsgKGR5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJdKVwiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChpc0Z1bmN0aW9uSW52b2NhdGlvbiA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSkgOiBoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIigkZXZlbnQpXCIpXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSlcbiAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgIC8vIGtleSBldmVudHMgdGhhdCBkbyBub3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5Li4uXG4gICAgXCJpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJlwiICtcbiAgICAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIlxuICApXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleUNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXksXCIgK1xuICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICBcIilcIlxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkaXIubW9kaWZpZXJzKSB7XG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uOiBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cblxuXG5cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICB0aGlzLnByZSA9IGZhbHNlO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwucGFyZW50KSB7XG4gICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XG4gIH1cblxuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcbiAgICAgICAgZGF0YSA9IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgLy8gU29tZSBlbGVtZW50cyAodGVtcGxhdGVzKSBuZWVkIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSBpbnNpZGUgb2YgYSB2LXByZVxuICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xuICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICB2YXIgb3JpZ2luYWxQcmVTdGF0ZSA9IHN0YXRlLnByZTtcbiAgaWYgKGVsLnByZSkge1xuICAgIHN0YXRlLnByZSA9IGVsLnByZTtcbiAgfVxuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ11cbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXSxcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOlwiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOlwiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSkpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICBkYXRhID0gXCJfYihcIiArIGRhdGEgKyBcIixcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIiArIChnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpKSArIFwiKVwiO1xuICB9XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlwiICsgKGRpci5pc0R5bmFtaWNBcmcgPyBkaXIuYXJnIDogKFwiXFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpKSkgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsXG4gICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgKTtcbiAgfVxuICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIGVsLFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICAvLyBieSBkZWZhdWx0IHNjb3BlZCBzbG90cyBhcmUgY29uc2lkZXJlZCBcInN0YWJsZVwiLCB0aGlzIGFsbG93cyBjaGlsZFxuICAvLyBjb21wb25lbnRzIHdpdGggb25seSBzY29wZWQgc2xvdHMgdG8gc2tpcCBmb3JjZWQgdXBkYXRlcyBmcm9tIHBhcmVudC5cbiAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAvLyBmb3IgZXhhbXBsZSBpZiB0aGUgc2xvdCBjb250YWlucyBkeW5hbWljIG5hbWVzLCBoYXMgdi1pZiBvciB2LWZvciBvbiB0aGVtLi4uXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gZWwuZm9yIHx8IE9iamVjdC5rZXlzKHNsb3RzKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgcmV0dXJuIChcbiAgICAgIHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHxcbiAgICAgIHNsb3QuaWYgfHxcbiAgICAgIHNsb3QuZm9yIHx8XG4gICAgICBjb250YWluc1Nsb3RDaGlsZChzbG90KSAvLyBpcyBwYXNzaW5nIGRvd24gc2xvdCBmcm9tIHBhcmVudCB3aGljaCBtYXkgYmUgZHluYW1pY1xuICAgIClcbiAgfSk7XG5cbiAgLy8gIzk1MzQ6IGlmIGEgY29tcG9uZW50IHdpdGggc2NvcGVkIHNsb3RzIGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJyYW5jaCxcbiAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgY29tcG9uZW50IHRvIGJlIHJldXNlZCBidXQgd2l0aCBkaWZmZXJlbnRcbiAgLy8gY29tcGlsZWQgc2xvdCBjb250ZW50LiBUbyBhdm9pZCB0aGF0LCB3ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgYmFzZWQgb25cbiAgLy8gdGhlIGdlbmVyYXRlZCBjb2RlIG9mIGFsbCB0aGUgc2xvdCBjb250ZW50cy5cbiAgdmFyIG5lZWRzS2V5ID0gISFlbC5pZjtcblxuICAvLyBPUiB3aGVuIGl0IGlzIGluc2lkZSBhbm90aGVyIHNjb3BlZCBzbG90IG9yIHYtZm9yICh0aGUgcmVhY3Rpdml0eSBtYXkgYmVcbiAgLy8gZGlzY29ubmVjdGVkIGR1ZSB0byB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIHZhcmlhYmxlKVxuICAvLyAjOTQzOCwgIzk1MDZcbiAgLy8gVE9ETzogdGhpcyBjYW4gYmUgZnVydGhlciBvcHRpbWl6ZWQgYnkgcHJvcGVybHkgYW5hbHl6aW5nIGluLXNjb3BlIGJpbmRpbmdzXG4gIC8vIGFuZCBza2lwIGZvcmNlIHVwZGF0aW5nIG9uZXMgdGhhdCBkbyBub3QgYWN0dWFsbHkgdXNlIHNjb3BlIHZhcmlhYmxlcy5cbiAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgIChwYXJlbnQuc2xvdFNjb3BlICYmIHBhcmVudC5zbG90U2NvcGUgIT09IGVtcHR5U2xvdFNjb3BlVG9rZW4pIHx8XG4gICAgICAgIHBhcmVudC5mb3JcbiAgICAgICkge1xuICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuaWYpIHtcbiAgICAgICAgbmVlZHNLZXkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2VuZXJhdGVkU2xvdHMgPSBPYmplY3Qua2V5cyhzbG90cylcbiAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoc2xvdHNba2V5XSwgc3RhdGUpOyB9KVxuICAgIC5qb2luKCcsJyk7XG5cbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIGdlbmVyYXRlZFNsb3RzICsgXCJdXCIgKyAobmVlZHNGb3JjZVVwZGF0ZSA/IFwiLG51bGwsdHJ1ZVwiIDogXCJcIikgKyAoIW5lZWRzRm9yY2VVcGRhdGUgJiYgbmVlZHNLZXkgPyAoXCIsbnVsbCxmYWxzZSxcIiArIChoYXNoKGdlbmVyYXRlZFNsb3RzKSkpIDogXCJcIikgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgdmFyIGhhc2ggPSA1MzgxO1xuICB2YXIgaSA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlKGkpIHtcbiAgICBoYXNoID0gKGhhc2ggKiAzMykgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICB9XG4gIHJldHVybiBoYXNoID4+PiAwXG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zU2xvdENoaWxkIChlbCkge1xuICBpZiAoZWwudHlwZSA9PT0gMSkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QsIFwibnVsbFwiKVxuICB9XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90KVxuICB9XG4gIHZhciBzbG90U2NvcGUgPSBlbC5zbG90U2NvcGUgPT09IGVtcHR5U2xvdFNjb3BlVG9rZW5cbiAgICA/IFwiXCJcbiAgICA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xuICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgc2xvdFNjb3BlICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgPyAoXCIoXCIgKyAoZWwuaWYpICsgXCIpP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gIC8vIHJldmVyc2UgcHJveHkgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgdmFyIHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IFwiXCIgOiBcIixwcm94eTp0cnVlXCI7XG4gIHJldHVybiAoXCJ7a2V5OlwiICsgKGVsLnNsb3RUYXJnZXQgfHwgXCJcXFwiZGVmYXVsdFxcXCJcIikgKyBcIixmbjpcIiArIGZuICsgcmV2ZXJzZVByb3h5ICsgXCJ9XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgPyBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCQxKSA/IFwiLDFcIiA6IFwiLDBcIlxuICAgICAgICA6IFwiXCI7XG4gICAgICByZXR1cm4gKFwiXCIgKyAoKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpKSArIG5vcm1hbGl6YXRpb25UeXBlKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUkMSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlJDEgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSQxKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgfSk7IH0pKVxuICAgIDogbnVsbDtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcIixcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IFwie1wiICsgKHN0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICB9XG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG5cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0LCB3YXJuKSB7XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgd2Fybik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgd2FybixcbiAgcmFuZ2Vcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgcmFuZ2UgPSAyO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZSAoXG4gIHNvdXJjZSxcbiAgc3RhcnQsXG4gIGVuZFxuKSB7XG4gIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0ID0gMDtcbiAgaWYgKCBlbmQgPT09IHZvaWQgMCApIGVuZCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICBmb3IgKHZhciBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgeyBjb250aW51ZSB9XG4gICAgICAgIHJlcy5wdXNoKChcIlwiICsgKGogKyAxKSArIChyZXBlYXQkMShcIiBcIiwgMyAtIFN0cmluZyhqICsgMSkubGVuZ3RoKSkgKyBcInwgIFwiICsgKGxpbmVzW2pdKSkpO1xuICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgIHZhciBwYWQgPSBzdGFydCAtIChjb3VudCAtIGxpbmVMZW5ndGgpICsgMTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiIFwiLCBwYWQpICsgcmVwZWF0JDEoXCJeXCIsIGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoJDEgPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XG4gICAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCJeXCIsIGxlbmd0aCQxKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpXG59XG5cbmZ1bmN0aW9uIHJlcGVhdCQxIChzdHIsIG4pIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAobiA+IDApIHtcbiAgICB3aGlsZSAodHJ1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAobiAmIDEpIHsgcmVzdWx0ICs9IHN0cjsgfVxuICAgICAgbiA+Pj49IDE7XG4gICAgICBpZiAobiA8PSAwKSB7IGJyZWFrIH1cbiAgICAgIHN0ciArPSBzdHI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcbiAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgKGUubXNnKSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGlwKGUubXNnLCB2bSk7IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0aXBzID0gW107XG5cbiAgICAgIHZhciB3YXJuID0gZnVuY3Rpb24gKG1zZywgcmFuZ2UsIHRpcCkge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgIHZhciBsZWFkaW5nU3BhY2VMZW5ndGggPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgcmFuZ2UsIHRpcCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7IG1zZzogbXNnIH07XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lbmQgPSByYW5nZS5lbmQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKGRhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUudHJpbSgpLCBmaW5hbE9wdGlvbnMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCwgd2Fybik7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59KTtcblxuLyogICovXG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlID0gcmVmJDEuY29tcGlsZTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xudmFyIGRpdjtcbmZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xuICBkaXYgPSBkaXYgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcbn1cblxuLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cbnZhciBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.esm.js\n");

/***/ }),

/***/ "./node_modules/vuescroll/dist/vuescroll.js":
/*!**************************************************!*\
  !*** ./node_modules/vuescroll/dist/vuescroll.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n    * Vuescroll v4.12.0\n    * (c) 2018-2019 Yi(Yves) Wang\n    * Released under the MIT License\n    * Github: https://github.com/YvesCoding/vuescroll\n    * Website: http://vuescrolljs.yvescoding.org/\n    */\n(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\")) : undefined;\n})(this, function (Vue) {\n  'use strict';\n\n  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;\n\n  function isIE() {\n    /* istanbul ignore if */\n    if (isServer()) return false;\n    var agent = navigator.userAgent.toLowerCase();\n    return agent.indexOf('msie') !== -1 || agent.indexOf('trident') !== -1 || agent.indexOf(' edge/') !== -1;\n  }\n\n  var isIos = function isIos() {\n    /* istanbul ignore if */\n    if (isServer()) return false;\n    var u = navigator.userAgent;\n    return !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n  };\n\n  function isSupportTouch() {\n    /* istanbul ignore if */\n    if (isServer()) return false;\n    return 'ontouchstart' in window;\n  }\n  /* istanbul ignore next */\n\n\n  var isServer = function isServer() {\n    return Vue.prototype.$isServer;\n  };\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var defineProperty = function (obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  };\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  function deepCopy(from, to, shallow) {\n    if (shallow && isUndef(to)) {\n      return from;\n    }\n\n    if (isArray(from)) {\n      to = [];\n      from.forEach(function (item, index) {\n        to[index] = deepCopy(item, to[index]);\n      });\n    } else if (from) {\n      if (!isPlainObj(from)) {\n        return from;\n      }\n\n      to = {};\n\n      for (var key in from) {\n        to[key] = _typeof(from[key]) === 'object' ? deepCopy(from[key], to[key]) : from[key];\n      }\n    }\n\n    return to;\n  }\n\n  function mergeObject(from, to, force, shallow) {\n    if (shallow && isUndef(to)) {\n      return from;\n    }\n\n    to = to || {};\n\n    if (isArray(from)) {\n      if (!isArray(to) && force) {\n        to = [];\n      }\n\n      if (isArray(to)) {\n        from.forEach(function (item, index) {\n          to[index] = mergeObject(item, to[index], force, shallow);\n        });\n      }\n    } else if (from) {\n      if (!isPlainObj(from)) {\n        if (force) {\n          to = from;\n        }\n      } else {\n        for (var key in from) {\n          if (_typeof(from[key]) === 'object') {\n            if (isUndef(to[key])) {\n              to[key] = deepCopy(from[key], to[key], shallow);\n            } else {\n              mergeObject(from[key], to[key], force, shallow);\n            }\n          } else {\n            if (isUndef(to[key]) || force) to[key] = from[key];\n          }\n        }\n      }\n    }\n\n    return to;\n  }\n\n  function defineReactive(target, key, source, souceKey) {\n    /* istanbul ignore if */\n    if (!source[key] && typeof source !== 'function') {\n      return;\n    }\n\n    souceKey = souceKey || key;\n    Object.defineProperty(target, key, {\n      get: function get$$1() {\n        return source[souceKey];\n      },\n      configurable: true\n    });\n  }\n\n  var scrollBarWidth = void 0;\n\n  function getGutter() {\n    /* istanbul ignore next */\n    if (isServer()) return 0;\n    if (scrollBarWidth !== undefined) return scrollBarWidth;\n    var outer = document.createElement('div');\n    outer.style.visibility = 'hidden';\n    outer.style.width = '100px';\n    outer.style.position = 'absolute';\n    outer.style.top = '-9999px';\n    document.body.appendChild(outer);\n    var widthNoScroll = outer.offsetWidth;\n    outer.style.overflow = 'scroll';\n    var inner = document.createElement('div');\n    inner.style.width = '100%';\n    outer.appendChild(inner);\n    var widthWithScroll = inner.offsetWidth;\n    outer.parentNode.removeChild(outer);\n    scrollBarWidth = widthNoScroll - widthWithScroll;\n    return scrollBarWidth;\n  }\n\n  function eventCenter(dom, eventName, hander) {\n    var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'on';\n    type == 'on' ? dom.addEventListener(eventName, hander, capture) : dom.removeEventListener(eventName, hander, capture);\n  }\n\n  var error = function error(msg) {\n    console.error('[vuescroll] ' + msg);\n  };\n\n  var warn = function warn(msg) {\n    console.warn('[vuescroll] ' + msg);\n  };\n\n  function isChildInParent(child, parent) {\n    var flag = false;\n\n    if (!child || !parent) {\n      return flag;\n    }\n\n    while (child.parentNode !== parent && child.parentNode.nodeType !== 9 && !child.parentNode._isVuescroll) {\n      child = child.parentNode;\n    }\n\n    if (child.parentNode == parent) {\n      flag = true;\n    }\n\n    return flag;\n  }\n\n  function getPrefix(global) {\n    var docStyle = document.documentElement.style;\n    var engine;\n    /* istanbul ignore if */\n\n    if (global.opera && Object.prototype.toString.call(opera) === '[object Opera]') {\n      engine = 'presto';\n    }\n    /* istanbul ignore next */\n    else if ('MozAppearance' in docStyle) {\n        engine = 'gecko';\n      } else if ('WebkitAppearance' in docStyle) {\n        engine = 'webkit';\n      }\n      /* istanbul ignore next */\n      else if (typeof navigator.cpuClass === 'string') {\n          engine = 'trident';\n        }\n\n    var vendorPrefix = {\n      trident: 'ms',\n      gecko: 'moz',\n      webkit: 'webkit',\n      presto: 'O'\n    }[engine];\n    return vendorPrefix;\n  }\n\n  function getComplitableStyle(property, value) {\n    /* istanbul ignore if */\n    if (isServer()) return false;\n    var compatibleValue = '-' + getPrefix(window) + '-' + value;\n    var testElm = document.createElement('div');\n    testElm.style[property] = compatibleValue;\n\n    if (testElm.style[property] == compatibleValue) {\n      return compatibleValue;\n    }\n    /* istanbul ignore next */\n\n\n    return false;\n  }\n  /**\n   * Insert children into user-passed slot at vnode level\n   */\n\n\n  function insertChildrenIntoSlot(h) {\n    var parentVnode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var childVNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var swapChildren = arguments[4];\n    /* istanbul ignore if */\n\n    if (parentVnode && parentVnode.length > 1) {\n      return swapChildren ? [].concat(toConsumableArray(childVNode), toConsumableArray(parentVnode)) : [].concat(toConsumableArray(parentVnode), toConsumableArray(childVNode));\n    }\n\n    parentVnode = parentVnode[0];\n\n    var _getVnodeInfo = getVnodeInfo(parentVnode),\n        ch = _getVnodeInfo.ch,\n        tag = _getVnodeInfo.tag,\n        isComponent = _getVnodeInfo.isComponent;\n\n    if (isComponent) {\n      parentVnode.data = mergeObject({\n        attrs: parentVnode.componentOptions.propsData\n      }, parentVnode.data, false, // force: false\n      true // shallow: true\n      );\n    }\n\n    ch = swapChildren ? [].concat(toConsumableArray(childVNode), toConsumableArray(ch)) : [].concat(toConsumableArray(ch), toConsumableArray(childVNode));\n    delete parentVnode.data.slot;\n    return h(tag, mergeObject(data, parentVnode.data, false, true), ch);\n  }\n  /**\n   *  Get the info of a vnode,\n   * vnode must be parentVnode\n   */\n\n\n  function getVnodeInfo(vnode) {\n    if (!vnode || vnode.length > 1) return {};\n    vnode = vnode[0] ? vnode[0] : vnode;\n    var isComponent = !!vnode.componentOptions;\n    var ch = void 0;\n    var tag = void 0;\n\n    if (isComponent) {\n      ch = vnode.componentOptions.children || [];\n      tag = vnode.componentOptions.tag;\n    } else {\n      ch = vnode.children || [];\n      tag = vnode.tag;\n    }\n\n    return {\n      isComponent: isComponent,\n      ch: ch,\n      tag: tag\n    };\n  }\n  /**\n   * Get the vuescroll instance instead of\n   * user pass component like slot.\n   */\n\n\n  function getRealParent(ctx) {\n    var parent = ctx.$parent;\n\n    if (!parent._isVuescrollRoot && parent) {\n      parent = parent.$parent;\n    }\n\n    return parent;\n  }\n\n  var isArray = function isArray(_) {\n    return Array.isArray(_);\n  };\n\n  var isPlainObj = function isPlainObj(_) {\n    return Object.prototype.toString.call(_) == '[object Object]';\n  };\n\n  var isUndef = function isUndef(_) {\n    return typeof _ === 'undefined';\n  };\n\n  function getNumericValue(distance, size) {\n    var number = void 0;\n\n    if (!(number = /(-?\\d+(?:\\.\\d+?)?)%$/.exec(distance))) {\n      number = distance - 0;\n    } else {\n      number = number[1] - 0;\n      number = size * number / 100;\n    }\n\n    return number;\n  }\n\n  function createStyle(styleId, cssText) {\n    /* istanbul ignore if */\n    if (isServer() || document.getElementById(styleId)) {\n      return;\n    }\n\n    var head = document.head || doc.getElementsByTagName('head')[0];\n    var style = document.createElement('style');\n    style.id = styleId;\n    style.type = 'text/css';\n    /* istanbul ignore if */\n\n    if (style.styleSheet) {\n      style.styleSheet.cssText = cssText;\n    } else {\n      style.appendChild(document.createTextNode(cssText));\n    }\n\n    head.appendChild(style);\n  } // Hide the ios native scrollbar.\n\n\n  function createHideBarStyle() {\n    /* istanbul ignore next */\n    {\n      var cssText = '.__hidebar::-webkit-scrollbar {\\n      width: 0;\\n      height: 0;\\n    }';\n      createStyle('vuescroll-hide-ios-bar', cssText);\n    }\n  } // create slide mode style\n\n\n  function createSlideModeStyle() {\n    var cssText = '\\n    @-webkit-keyframes loading-rotate {\\n      to {\\n        -webkit-transform: rotate(1turn);\\n        transform: rotate(1turn);\\n      }\\n    }\\n\\n    @keyframes loading-rotate {\\n      to {\\n        -webkit-transform: rotate(1turn);\\n        transform: rotate(1turn);\\n      }\\n    }\\n\\n    @-webkit-keyframes loading-wipe {\\n      0% {\\n        stroke-dasharray: 1, 200;\\n        stroke-dashoffset: 0;\\n      }\\n      50% {\\n        stroke-dasharray: 90, 150;\\n        stroke-dashoffset: -40px;\\n      }\\n      to {\\n        stroke-dasharray: 90, 150;\\n        stroke-dashoffset: -120px;\\n      }\\n    }\\n\\n    @keyframes loading-wipe {\\n      0% {\\n        stroke-dasharray: 1, 200;\\n        stroke-dashoffset: 0;\\n      }\\n      50% {\\n        stroke-dasharray: 90, 150;\\n        stroke-dashoffset: -40px;\\n      }\\n      to {\\n        stroke-dasharray: 90, 150;\\n        stroke-dashoffset: -120px;\\n      }\\n    }\\n\\n    .__vuescroll .__refresh,\\n    .__vuescroll .__load {\\n      position: absolute;\\n      width: 100%;\\n      color: black;\\n      height: 50px;\\n      line-height: 50px;\\n      text-align: center;\\n      font-size: 16px;\\n    }\\n    .__vuescroll .__refresh svg,\\n    .__vuescroll .__load svg {\\n      margin-right: 10px;\\n      width: 25px;\\n      height: 25px;\\n      vertical-align: sub;\\n    }\\n    .__vuescroll .__refresh svg.active,\\n    .__vuescroll .__load svg.active {\\n      transition: all 0.2s;\\n    }\\n    .__vuescroll .__refresh svg.active.deactive,\\n    .__vuescroll .__load svg.active.deactive {\\n      transform: rotateZ(180deg);\\n    }\\n    .__vuescroll .__refresh svg path,\\n    .__vuescroll .__refresh svg rect,\\n    .__vuescroll .__load svg path,\\n    .__vuescroll .__load svg rect {\\n      fill: #20a0ff;\\n    }\\n    .__vuescroll .__refresh svg.start,\\n    .__vuescroll .__load svg.start {\\n      stroke: #343640;\\n      stroke-width: 4;\\n      stroke-linecap: round;\\n      -webkit-animation: loading-rotate 2s linear infinite;\\n      animation: loading-rotate 2s linear infinite;\\n    }\\n    .__vuescroll .__refresh svg.start .bg-path,\\n    .__vuescroll .__load svg.start .bg-path {\\n      stroke: #f2f2f2;\\n      fill: none;\\n    }\\n    .__vuescroll .__refresh svg.start .active-path,\\n    .__vuescroll .__load svg.start .active-path {\\n      stroke: #20a0ff;\\n      fill: none;\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: 0;\\n      -webkit-animation: loading-wipe 1.5s ease-in-out infinite;\\n      animation: loading-wipe 1.5s ease-in-out infinite;\\n    }\\n  ';\n    createStyle('vuescroll-silde-mode-style', cssText);\n  }\n\n  var api = {\n    mounted: function mounted() {\n      vsInstances[this._uid] = this;\n    },\n    beforeDestroy: function beforeDestroy() {\n      delete vsInstances[this._uid];\n    },\n    methods: {\n      // public api\n      scrollTo: function scrollTo(_ref, speed, easing) {\n        var x = _ref.x,\n            y = _ref.y; // istanbul ignore if\n\n        if (speed === true || typeof speed == 'undefined') {\n          speed = this.mergedOptions.scrollPanel.speed;\n        }\n\n        this.internalScrollTo(x, y, speed, easing);\n      },\n      scrollBy: function scrollBy(_ref2, speed, easing) {\n        var _ref2$dx = _ref2.dx,\n            dx = _ref2$dx === undefined ? 0 : _ref2$dx,\n            _ref2$dy = _ref2.dy,\n            dy = _ref2$dy === undefined ? 0 : _ref2$dy;\n\n        var _getPosition = this.getPosition(),\n            _getPosition$scrollLe = _getPosition.scrollLeft,\n            scrollLeft = _getPosition$scrollLe === undefined ? 0 : _getPosition$scrollLe,\n            _getPosition$scrollTo = _getPosition.scrollTop,\n            scrollTop = _getPosition$scrollTo === undefined ? 0 : _getPosition$scrollTo;\n\n        if (dx) {\n          scrollLeft += getNumericValue(dx, this.scrollPanelElm.scrollWidth - this.$el.clientWidth);\n        }\n\n        if (dy) {\n          scrollTop += getNumericValue(dy, this.scrollPanelElm.scrollHeight - this.$el.clientHeight);\n        }\n\n        this.internalScrollTo(scrollLeft, scrollTop, speed, easing);\n      },\n      scrollIntoView: function scrollIntoView(elm) {\n        var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var parentElm = this.$el;\n\n        if (typeof elm === 'string') {\n          elm = parentElm.querySelector(elm);\n        }\n\n        if (!isChildInParent(elm, parentElm)) {\n          warn('The element or selector you passed is not the element of Vuescroll, please pass the element that is in Vuescroll to scrollIntoView API. ');\n          return;\n        } // parent elm left, top\n\n\n        var _$el$getBoundingClien = this.$el.getBoundingClientRect(),\n            left = _$el$getBoundingClien.left,\n            top = _$el$getBoundingClien.top; // child elm left, top\n\n\n        var _elm$getBoundingClien = elm.getBoundingClientRect(),\n            childLeft = _elm$getBoundingClien.left,\n            childTop = _elm$getBoundingClien.top;\n\n        var diffX = left - childLeft;\n        var diffY = top - childTop;\n        this.scrollBy({\n          dx: -diffX,\n          dy: -diffY\n        }, animate);\n      },\n      refresh: function refresh() {\n        this.refreshInternalStatus(); // refresh again to keep status is correct\n\n        this.$nextTick(this.refreshInternalStatus);\n      }\n    }\n  };\n  /** Public Api */\n\n  /**\n   * Refresh all\n   */\n\n  var vsInstances = {};\n\n  function refreshAll() {\n    for (var vs in vsInstances) {\n      vsInstances[vs].refresh();\n    }\n  }\n\n  var baseConfig = {\n    // vuescroll\n    vuescroll: {\n      // vuescroll's size(height/width) should be a percent(100%)\n      // or be a number that is equal to its parentNode's width or\n      // height ?\n      sizeStrategy: 'percent',\n\n      /** Whether to detect dom resize or not */\n      detectResize: true\n    },\n    scrollPanel: {\n      // when component mounted.. it will automatically scrolls.\n      initialScrollY: false,\n      initialScrollX: false,\n      // feat: #11\n      scrollingX: true,\n      scrollingY: true,\n      speed: 300,\n      easing: undefined,\n      // Sometimes, the nativebar maybe on the left,\n      // See https://github.com/YvesCoding/vuescroll/issues/64\n      verticalNativeBarPos: 'right'\n    },\n    //\n    rail: {\n      background: '#01a99a',\n      opacity: 0,\n      border: 'none',\n\n      /** Rail's size(Height/Width) , default -> 6px */\n      size: '6px',\n\n      /** Specify rail's border-radius, or the border-radius of rail and bar will be equal to the rail's size. default -> false **/\n      specifyBorderRadius: false,\n\n      /** Rail the distance from the two ends of the X axis and Y axis. **/\n      gutterOfEnds: null,\n\n      /** Rail the distance from the side of container. **/\n      gutterOfSide: '2px',\n\n      /** Whether to keep rail show or not, default -> false, event content height is not enough */\n      keepShow: false\n    },\n    bar: {\n      /** How long to hide bar after mouseleave, default -> 500 */\n      showDelay: 500,\n\n      /** Specify bar's border-radius, or the border-radius of rail and bar will be equal to the rail's size. default -> false **/\n      specifyBorderRadius: false,\n\n      /** Whether to show bar on scrolling, default -> true */\n      onlyShowBarOnScroll: true,\n\n      /** Whether to keep show or not, default -> false */\n      keepShow: false,\n\n      /** Bar's background , default -> #00a650 */\n      background: 'rgb(3, 185, 118)',\n\n      /** Bar's opacity, default -> 1  */\n      opacity: 1,\n\n      /** Styles when you hover scrollbar, it will merge into the current style */\n      hoverStyle: false,\n\n      /** bar's size(Height/Width) , default -> 6px */\n      size: '6px',\n      minSize: 0,\n      disable: false\n    },\n    scrollButton: {\n      enable: false,\n      background: 'rgb(3, 185, 118)',\n      opacity: 1,\n      step: 180,\n      mousedownStep: 30\n    }\n  };\n  /**\n   * validate the options\n   * @export\n   * @param {any} ops\n   */\n\n  function validateOps(ops) {\n    var renderError = false;\n    var scrollPanel = ops.scrollPanel;\n    var _ops$bar = ops.bar,\n        vBar = _ops$bar.vBar,\n        hBar = _ops$bar.hBar;\n    var _ops$rail = ops.rail,\n        vRail = _ops$rail.vRail,\n        hRail = _ops$rail.hRail; // validate scrollPanel\n\n    var initialScrollY = scrollPanel['initialScrollY'];\n    var initialScrollX = scrollPanel['initialScrollX'];\n\n    if (initialScrollY && !String(initialScrollY).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n      warn('The prop `initialScrollY` or `initialScrollX` should be a percent number like `10%` or an exact number that greater than or equal to 0 like `100`.');\n    }\n\n    if (initialScrollX && !String(initialScrollX).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n      warn('The prop `initialScrollY` or `initialScrollX` should be a percent number like `10%` or an exact number that greater than or equal to 0 like `100`.');\n    } // validate deprecated vBar/hBar vRail/hRail\n\n\n    if (vBar || hBar || vRail || hRail) {\n      warn('The options: vRail, hRail, vBar, hBar have been deprecated since v4.7.0,' + 'please use corresponing rail/bar instead!');\n    }\n\n    if (_extraValidate) {\n      _extraValidate = [].concat(_extraValidate);\n\n      _extraValidate.forEach(function (hasError) {\n        if (hasError(ops)) {\n          renderError = true;\n        }\n      });\n    }\n\n    return renderError;\n  }\n\n  var _extraValidate = null;\n\n  var extendOpts = function extendOpts(extraOpts, extraValidate) {\n    extraOpts = [].concat(extraOpts);\n    extraOpts.forEach(function (opts) {\n      mergeObject(opts, baseConfig);\n    });\n    _extraValidate = extraValidate;\n  }; // all modes\n\n\n  var modes = ['slide', 'native']; // do nothing\n\n  var NOOP = function NOOP() {}; // some small changes.\n\n\n  var smallChangeArray = ['mergedOptions.vuescroll.pullRefresh.tips', 'mergedOptions.vuescroll.pushLoad.tips', 'mergedOptions.vuescroll.scroller.disable', 'mergedOptions.rail', 'mergedOptions.bar']; // refresh/load dom ref/key...\n\n  var __REFRESH_DOM_NAME = 'refreshDom';\n  var __LOAD_DOM_NAME = 'loadDom'; // detect content size change\n\n  function installResizeDetection(element, callback) {\n    return injectObject(element, callback);\n  }\n\n  function injectObject(element, callback) {\n    if (element.hasResized) {\n      return;\n    }\n\n    var OBJECT_STYLE = 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;'; // define a wrap due to ie's zIndex bug\n\n    var objWrap = document.createElement('div');\n    objWrap.style.cssText = OBJECT_STYLE;\n    var object = document.createElement('object');\n    object.style.cssText = OBJECT_STYLE;\n    object.type = 'text/html';\n    object.tabIndex = -1;\n\n    object.onload = function () {\n      eventCenter(object.contentDocument.defaultView, 'resize', callback);\n    }; // https://github.com/wnr/element-resize-detector/blob/aafe9f7ea11d1eebdab722c7c5b86634e734b9b8/src/detection-strategy/object.js#L159\n\n\n    if (!isIE()) {\n      object.data = 'about:blank';\n    }\n\n    objWrap.isResizeElm = true;\n    objWrap.appendChild(object);\n    element.appendChild(objWrap);\n\n    if (isIE()) {\n      object.data = 'about:blank';\n    }\n\n    return function destroy() {\n      if (object.contentDocument) {\n        eventCenter(object.contentDocument.defaultView, 'resize', callback, 'off');\n      }\n\n      element.removeChild(objWrap);\n      element.hasResized = false;\n    };\n  }\n\n  var scrollMap = {\n    vertical: {\n      size: 'height',\n      opsSize: 'width',\n      posName: 'top',\n      opposName: 'bottom',\n      sidePosName: 'right',\n      page: 'pageY',\n      scroll: 'scrollTop',\n      scrollSize: 'scrollHeight',\n      offset: 'offsetHeight',\n      client: 'clientY',\n      axis: 'Y',\n      scrollButton: {\n        start: 'top',\n        end: 'bottom'\n      }\n    },\n    horizontal: {\n      size: 'width',\n      opsSize: 'height',\n      posName: 'left',\n      opposName: 'right',\n      sidePosName: 'bottom',\n      page: 'pageX',\n      scroll: 'scrollLeft',\n      scrollSize: 'scrollWidth',\n      offset: 'offsetWidth',\n      client: 'clientX',\n      axis: 'X',\n      scrollButton: {\n        start: 'left',\n        end: 'right'\n      }\n    }\n  };\n\n  function requestAnimationFrame(global) {\n    // Check for request animation Frame support\n    var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;\n    var isNative = !!requestFrame;\n\n    if (requestFrame && !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(requestFrame.toString())) {\n      isNative = false;\n    }\n\n    if (isNative) {\n      return function (callback, root) {\n        requestFrame(callback, root);\n      };\n    }\n\n    var TARGET_FPS = 60;\n    var requests = {};\n    var rafHandle = 1;\n    var intervalHandle = null;\n    var lastActive = +new Date();\n    return function (callback) {\n      var callbackHandle = rafHandle++; // Store callback\n\n      requests[callbackHandle] = callback; // Create timeout at first request\n\n      if (intervalHandle === null) {\n        intervalHandle = setInterval(function () {\n          var time = +new Date();\n          var currentRequests = requests; // Reset data structure before executing callbacks\n\n          requests = {};\n\n          for (var key in currentRequests) {\n            if (currentRequests.hasOwnProperty(key)) {\n              currentRequests[key](time);\n              lastActive = time;\n            }\n          } // Disable the timeout when nothing happens for a certain\n          // period of time\n\n\n          if (time - lastActive > 2500) {\n            clearInterval(intervalHandle);\n            intervalHandle = null;\n          }\n        }, 1000 / TARGET_FPS);\n      }\n\n      return callbackHandle;\n    };\n  }\n\n  var colorCache = {};\n  var rgbReg = /rgb\\(/;\n  var extractRgbColor = /rgb\\((.*)\\)/;\n  /* istanbul ignore next */\n\n  function createBarEvent(ctx) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'mouse';\n    var parent = getRealParent(ctx);\n    var moveEventName = type == 'mouse' ? 'mousemove' : 'touchmove';\n    var endEventName = type == 'mouse' ? 'mouseup' : 'touchend';\n\n    function mousedown(e) {\n      e.stopImmediatePropagation();\n      e.preventDefault();\n      var event = type == 'mouse' ? e : e.touches[0];\n\n      document.onselectstart = function () {\n        return false;\n      };\n\n      ctx.axisStartPos = event[ctx.bar.client] - ctx.$refs['thumb'].getBoundingClientRect()[ctx.bar.posName]; // Tell parent that the mouse has been down.\n\n      ctx.setBarDrag(true);\n      eventCenter(document, moveEventName, mousemove);\n      eventCenter(document, endEventName, mouseup);\n    }\n\n    function mousemove(e) {\n      if (!ctx.axisStartPos) {\n        return;\n      }\n\n      var thubmParent = ctx.$refs.thumb.parentNode;\n      var event = type == 'mouse' ? e : e.touches[0];\n      var delta = event[ctx.bar.client] - thubmParent.getBoundingClientRect()[ctx.bar.posName];\n      delta = delta / ctx.barRatio;\n      var percent = (delta - ctx.axisStartPos) / thubmParent[ctx.bar.offset];\n      parent.scrollTo(defineProperty({}, ctx.bar.axis.toLowerCase(), parent.scrollPanelElm[ctx.bar.scrollSize] * percent), false);\n    }\n\n    function mouseup() {\n      ctx.setBarDrag(false);\n      parent.hideBar();\n      document.onselectstart = null;\n      ctx.axisStartPos = 0;\n      eventCenter(document, moveEventName, mousemove, false, 'off');\n      eventCenter(document, endEventName, mouseup, false, 'off');\n    }\n\n    return mousedown;\n  }\n  /* istanbul ignore next */\n\n\n  function createScrollButtonEvent(ctx, type) {\n    var env = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'mouse';\n    var parent = getRealParent(ctx);\n    var endEventName = env == 'mouse' ? 'mouseup' : 'touchend';\n    var _ctx$ops$scrollButton = ctx.ops.scrollButton,\n        step = _ctx$ops$scrollButton.step,\n        mousedownStep = _ctx$ops$scrollButton.mousedownStep;\n    var stepWithDirection = type == 'start' ? -step : step;\n    var mousedownStepWithDirection = type == 'start' ? -mousedownStep : mousedownStep;\n    var ref = requestAnimationFrame(window); // bar props: type\n\n    var barType = ctx.type;\n    var isMouseDown = false;\n    var isMouseout = true;\n    var timeoutId = void 0;\n\n    function start(e) {\n      /* istanbul ignore if */\n      if (3 == e.which) {\n        return;\n      } // set class hook\n\n\n      parent.setClassHook('cliking' + barType + type + 'Button', true);\n      e.stopImmediatePropagation();\n      e.preventDefault();\n      isMouseout = false;\n      parent.scrollBy(defineProperty({}, 'd' + ctx.bar.axis.toLowerCase(), stepWithDirection));\n      eventCenter(document, endEventName, endPress, false);\n\n      if (env == 'mouse') {\n        var elm = ctx.$refs[type];\n        eventCenter(elm, 'mouseenter', enter, false);\n        eventCenter(elm, 'mouseleave', leave, false);\n      }\n\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(function () {\n        isMouseDown = true;\n        ref(pressing, window);\n      }, 500);\n    }\n\n    function pressing() {\n      if (isMouseDown && !isMouseout) {\n        parent.scrollBy(defineProperty({}, 'd' + ctx.bar.axis.toLowerCase(), mousedownStepWithDirection), false);\n        ref(pressing, window);\n      }\n    }\n\n    function endPress() {\n      clearTimeout(timeoutId);\n      isMouseDown = false;\n      eventCenter(document, endEventName, endPress, false, 'off');\n\n      if (env == 'mouse') {\n        var elm = ctx.$refs[type];\n        eventCenter(elm, 'mouseenter', enter, false, 'off');\n        eventCenter(elm, 'mouseleave', leave, false, 'off');\n      }\n\n      parent.setClassHook('cliking' + barType + type + 'Button', false);\n    }\n\n    function enter() {\n      isMouseout = false;\n      pressing();\n    }\n\n    function leave() {\n      isMouseout = true;\n    }\n\n    return start;\n  } // Transform a common color int oa `rgbA` color\n\n\n  function getRgbAColor(color, opacity) {\n    var id = color + '&' + opacity;\n\n    if (colorCache[id]) {\n      return colorCache[id];\n    }\n\n    var div = document.createElement('div');\n    div.style.background = color;\n    document.body.appendChild(div);\n    var computedColor = window.getComputedStyle(div).backgroundColor;\n    document.body.removeChild(div);\n    /* istanbul ignore if */\n\n    if (!rgbReg.test(computedColor)) {\n      return color;\n    }\n\n    return colorCache[id] = 'rgba(' + extractRgbColor.exec(computedColor)[1] + ', ' + opacity + ')';\n  }\n\n  function createTrackEvent(ctx, type) {\n    return function handleClickTrack(e) {\n      var parent = getRealParent(ctx);\n      var _ctx$bar = ctx.bar,\n          client = _ctx$bar.client,\n          offset = _ctx$bar.offset,\n          posName = _ctx$bar.posName,\n          axis = _ctx$bar.axis;\n      var thumb = ctx.$refs['thumb'];\n      e.preventDefault();\n      e.stopImmediatePropagation();\n      /* istanbul ignore if */\n\n      if (!thumb) return;\n      var barOffset = thumb[offset];\n      var event = type == 'touchstart' ? e.touches[0] : e;\n      var percent = (event[client] - e.currentTarget.getBoundingClientRect()[posName] - barOffset / 2) / (e.currentTarget[offset] - barOffset);\n      parent.scrollTo(defineProperty({}, axis.toLowerCase(), percent * 100 + '%'));\n    };\n  }\n\n  function createScrollbarButton(h, barContext, type) {\n    var _style;\n\n    if (!barContext.ops.scrollButton.enable) {\n      return null;\n    }\n\n    var size = barContext.ops.rail.size;\n    var borderColor = barContext.ops.scrollButton.background;\n    var wrapperProps = {\n      class: ['__bar-button', '__bar-button-is-' + barContext.type + '-' + type],\n      style: (_style = {}, defineProperty(_style, barContext.bar.scrollButton[type], 0), defineProperty(_style, 'width', size), defineProperty(_style, 'height', size), defineProperty(_style, 'position', 'absolute'), defineProperty(_style, 'cursor', 'pointer'), defineProperty(_style, 'display', 'table'), _style),\n      ref: type\n    };\n    var innerProps = {\n      class: '__bar-button-inner',\n      style: {\n        border: 'calc(' + size + ' / 2.5) solid transparent',\n        width: '0',\n        height: '0',\n        margin: 'auto',\n        position: 'absolute',\n        top: '0',\n        bottom: '0',\n        right: '0',\n        left: '0'\n      },\n      on: {}\n    };\n\n    if (barContext.type == 'vertical') {\n      if (type == 'start') {\n        innerProps.style['border-bottom-color'] = borderColor;\n        innerProps.style['transform'] = 'translateY(-25%)';\n      } else {\n        innerProps.style['border-top-color'] = borderColor;\n        innerProps.style['transform'] = 'translateY(25%)';\n      }\n    } else {\n      if (type == 'start') {\n        innerProps.style['border-right-color'] = borderColor;\n        innerProps.style['transform'] = 'translateX(-25%)';\n      } else {\n        innerProps.style['border-left-color'] = borderColor;\n        innerProps.style['transform'] = 'translateX(25%)';\n      }\n    }\n    /* istanbul ignore next */\n\n\n    {\n      if (isSupportTouch()) {\n        innerProps.on['touchstart'] = createScrollButtonEvent(barContext, type, 'touch');\n      } else {\n        innerProps.on['mousedown'] = createScrollButtonEvent(barContext, type);\n      }\n    }\n    return h('div', wrapperProps, [h('div', innerProps)]);\n  }\n\n  var bar = {\n    name: 'bar',\n    props: {\n      ops: Object,\n      state: Object,\n      hideBar: Boolean,\n      otherBarHide: Boolean,\n      type: String\n    },\n    computed: {\n      bar: function bar() {\n        return scrollMap[this.type];\n      },\n      barSize: function barSize() {\n        return Math.max(this.state.size, this.ops.bar.minSize);\n      },\n      barRatio: function barRatio() {\n        return (1 - this.barSize) / (1 - this.state.size);\n      }\n    },\n    render: function render(h) {\n      var _style2, _style3, _barStyle;\n\n      var vm = this;\n      /** Get rgbA format background color */\n\n      var railBackgroundColor = getRgbAColor(vm.ops.rail.background, vm.ops.rail.opacity);\n      /** Rail Data */\n\n      var railSize = vm.ops.rail.size;\n      var endPos = vm.otherBarHide ? 0 : railSize;\n      var rail = {\n        class: '__rail-is-' + vm.type,\n        style: (_style2 = {\n          position: 'absolute',\n          'z-index': '1',\n          borderRadius: vm.ops.rail.specifyBorderRadius || railSize,\n          background: railBackgroundColor,\n          border: vm.ops.rail.border\n        }, defineProperty(_style2, vm.bar.opsSize, railSize), defineProperty(_style2, vm.bar.posName, vm.ops.rail['gutterOfEnds'] || 0), defineProperty(_style2, vm.bar.opposName, vm.ops.rail['gutterOfEnds'] || endPos), defineProperty(_style2, vm.bar.sidePosName, vm.ops.rail['gutterOfSide']), _style2)\n      }; // left space for scroll button\n\n      var buttonSize = vm.ops.scrollButton.enable ? railSize : 0;\n      var barWrapper = {\n        class: '__bar-wrap-is-' + vm.type,\n        style: (_style3 = {\n          position: 'absolute',\n          borderRadius: vm.ops.rail.specifyBorderRadius || railSize\n        }, defineProperty(_style3, vm.bar.posName, buttonSize), defineProperty(_style3, vm.bar.opposName, buttonSize), _style3),\n        on: {}\n      };\n      var scrollDistance = vm.state.posValue * vm.state.size;\n      var pos = scrollDistance * vm.barRatio / vm.barSize;\n      var opacity = vm.state.opacity;\n      var parent = getRealParent(this); // set class hook\n\n      parent.setClassHook(this.type == 'vertical' ? 'vBarVisible' : 'hBarVisible', !!opacity);\n      /** Scrollbar style */\n\n      var barStyle = (_barStyle = {\n        cursor: 'pointer',\n        position: 'absolute',\n        margin: 'auto',\n        transition: 'opacity 0.5s',\n        'user-select': 'none',\n        'border-radius': 'inherit'\n      }, defineProperty(_barStyle, vm.bar.size, vm.barSize * 100 + '%'), defineProperty(_barStyle, 'background', vm.ops.bar.background), defineProperty(_barStyle, vm.bar.opsSize, vm.ops.bar.size), defineProperty(_barStyle, 'opacity', opacity), defineProperty(_barStyle, 'transform', 'translate' + scrollMap[vm.type].axis + '(' + pos + '%)'), _barStyle);\n      var bar = {\n        style: barStyle,\n        class: '__bar-is-' + vm.type,\n        ref: 'thumb',\n        on: {\n          mouseenter: function mouseenter() {\n            vm.setBarHoverStyles();\n          },\n          mouseleave: function mouseleave() {\n            vm.tryRestoreBarStyles();\n          }\n        }\n      };\n\n      if (vm.type == 'vertical') {\n        barWrapper.style.width = '100%'; // Let bar to be on the center.\n\n        bar.style.left = 0;\n        bar.style.right = 0;\n      } else {\n        barWrapper.style.height = '100%';\n        bar.style.top = 0;\n        bar.style.bottom = 0;\n      }\n      /* istanbul ignore if */\n\n\n      if (isSupportTouch()) {\n        bar.on['touchstart'] = createBarEvent(this, 'touch');\n        barWrapper.on['touchstart'] = createTrackEvent(this, 'touchstart');\n      } else {\n        bar.on['mousedown'] = createBarEvent(this);\n        barWrapper.on['mousedown'] = createTrackEvent(this, 'mousedown');\n      }\n\n      return h('div', rail, [createScrollbarButton(h, this, 'start'), this.hideBar ? null : h('div', barWrapper, [h('div', bar)]), createScrollbarButton(h, this, 'end')]);\n    },\n    data: function data() {\n      return {\n        // Use to restore bar styles after hovering the bars, on enable\n        // when option hoverStyle is not `falsy`.\n        originBarStyle: null,\n        isBarDragging: false\n      };\n    },\n    methods: {\n      setBarDrag: function setBarDrag(val)\n      /* istanbul ignore next */\n      {\n        this.$emit('setBarDrag', this.isBarDragging = val); // set class hooks\n\n        var parent = getRealParent(this); // set class hook\n\n        parent.setClassHook(this.type == 'vertical' ? 'vBarDragging' : 'hBarDragging', !!val);\n\n        if (!val) {\n          this.tryRestoreBarStyles();\n        }\n      },\n      tryRestoreBarStyles: function tryRestoreBarStyles() {\n        var _this = this;\n        /* istanbul ignore if */\n\n\n        if (this.isBarDragging || !this.originBarStyle) return;\n        Object.keys(this.originBarStyle).forEach(function (key) {\n          _this.$refs.thumb.style[key] = _this.originBarStyle[key];\n        });\n      },\n      setBarHoverStyles: function setBarHoverStyles() {\n        var _this2 = this;\n\n        var hoverBarStyle = this.ops.bar.hoverStyle;\n        /* istanbul ignore next */\n\n        if (!hoverBarStyle) return;\n\n        if (!this.originBarStyle) {\n          this.originBarStyle = {};\n          Object.keys(hoverBarStyle).forEach(function (key) {\n            _this2.originBarStyle[key] = _this2.$refs.thumb.style[key];\n          });\n        }\n\n        mergeObject(hoverBarStyle, this.$refs.thumb.style, true);\n      }\n    }\n  };\n\n  function getBarData(vm, type) {\n    var axis = scrollMap[type].axis;\n    /** type.charAt(0) = vBar/hBar */\n\n    var barType = type.charAt(0) + 'Bar';\n    var hideBar = !vm.bar[barType].state.size || !vm.mergedOptions.scrollPanel['scrolling' + axis] || vm.refreshLoad && type !== 'vertical' || vm.mergedOptions.bar.disable;\n    var keepShowRail = vm.mergedOptions.rail.keepShow;\n\n    if (hideBar && !keepShowRail) {\n      return null;\n    }\n\n    return {\n      props: {\n        type: type,\n        ops: {\n          bar: vm.mergedOptions.bar,\n          rail: vm.mergedOptions.rail,\n          scrollButton: vm.mergedOptions.scrollButton\n        },\n        state: vm.bar[barType].state,\n        hideBar: hideBar\n      },\n      on: {\n        setBarDrag: vm.setBarDrag\n      },\n      ref: type + 'Bar',\n      key: type\n    };\n  }\n  /**\n   * create bars\n   *\n   * @param {any} size\n   * @param {any} type\n   */\n\n\n  function createBar(h, vm) {\n    var verticalBarProps = getBarData(vm, 'vertical');\n    var horizontalBarProps = getBarData(vm, 'horizontal'); // set class hooks\n\n    vm.setClassHook('hasVBar', !!verticalBarProps);\n    vm.setClassHook('hasHBar', !!horizontalBarProps);\n    return [verticalBarProps ? h('bar', _extends({}, verticalBarProps, {\n      props: _extends({\n        otherBarHide: !horizontalBarProps\n      }, verticalBarProps.props)\n    })) : null, horizontalBarProps ? h('bar', _extends({}, horizontalBarProps, {\n      props: _extends({\n        otherBarHide: !verticalBarProps\n      }, horizontalBarProps.props)\n    })) : null];\n  }\n  /**\n   * This is like a HOC, It extracts the common parts of the\n   * native-mode, slide-mode and mix-mode.\n   * Each mode must implement the following methods:\n   * 1. refreshInternalStatus : use to refresh the component\n   * 2. destroy : Destroy some registryed events before component destroy.\n   * 3. updateBarStateAndEmitEvent: use to update bar states and emit events.\n   */\n\n\n  var createComponent = function createComponent(_ref) {\n    var _render = _ref.render,\n        components = _ref.components,\n        mixins = _ref.mixins;\n    return {\n      name: 'vueScroll',\n      props: {\n        ops: {\n          type: Object\n        }\n      },\n      components: components,\n      mixins: [api].concat(toConsumableArray([].concat(mixins))),\n      created: function created() {\n        var _this = this;\n        /**\n         * Begin to merge options\n         */\n\n\n        var _gfc = mergeObject(this.$vuescrollConfig || {}, {});\n\n        var ops = mergeObject(baseConfig, _gfc);\n        this.$options.propsData.ops = this.$options.propsData.ops || {};\n        Object.keys(this.$options.propsData.ops).forEach(function (key) {\n          {\n            defineReactive(_this.mergedOptions, key, _this.$options.propsData.ops);\n          }\n        }); // from ops to mergedOptions\n\n        mergeObject(ops, this.mergedOptions);\n        this._isVuescrollRoot = true;\n        this.renderError = validateOps(this.mergedOptions);\n      },\n      render: function render(h) {\n        var vm = this;\n\n        if (vm.renderError) {\n          return h('div', [[vm.$slots['default']]]);\n        } // vuescroll data\n\n\n        var data = {\n          style: {\n            height: vm.vuescroll.state.height,\n            width: vm.vuescroll.state.width,\n            padding: 0,\n            position: 'relative',\n            overflow: 'hidden'\n          },\n          class: _extends({\n            __vuescroll: true\n          }, vm.classHooks)\n        };\n\n        if (!isSupportTouch()) {\n          data.on = {\n            mouseenter: function mouseenter() {\n              vm.vuescroll.state.pointerLeave = false;\n              vm.updateBarStateAndEmitEvent();\n              vm.setClassHook('mouseEnter', true);\n            },\n            mouseleave: function mouseleave() {\n              vm.vuescroll.state.pointerLeave = true;\n              vm.hideBar();\n              vm.setClassHook('mouseEnter', false);\n            },\n            mousemove: function mousemove()\n            /* istanbul ignore next */\n            {\n              vm.vuescroll.state.pointerLeave = false;\n              vm.updateBarStateAndEmitEvent();\n            }\n          };\n        }\n        /* istanbul ignore next */\n        else {\n            data.on = {\n              touchstart: function touchstart() {\n                vm.vuescroll.state.pointerLeave = false;\n                vm.updateBarStateAndEmitEvent();\n              },\n              touchend: function touchend() {\n                vm.vuescroll.state.pointerLeave = true;\n                vm.hideBar();\n              },\n              touchmove: function touchmove()\n              /* istanbul ignore next */\n              {\n                vm.vuescroll.state.pointerLeave = false;\n                vm.updateBarStateAndEmitEvent();\n              }\n            };\n          }\n\n        var ch = [_render(h, vm)].concat(toConsumableArray(createBar(h, vm)));\n        var _customContainer = this.$slots['scroll-container'];\n\n        if (_customContainer) {\n          return insertChildrenIntoSlot(h, _customContainer, ch, data);\n        }\n\n        return h('div', data, [ch]);\n      },\n      mounted: function mounted() {\n        var _this2 = this;\n\n        if (!this.renderError) {\n          this.initVariables();\n          this.initWatchOpsChange(); // Call external merged Api\n\n          this.refreshInternalStatus();\n          this.updatedCbs.push(function () {\n            _this2.scrollToAnchor(); // need to reflow to deal with the\n            // latest thing.\n\n\n            _this2.updateBarStateAndEmitEvent();\n          });\n        }\n      },\n      updated: function updated() {\n        var _this3 = this;\n\n        this.updatedCbs.forEach(function (cb) {\n          cb.call(_this3);\n        }); // Clear\n\n        this.updatedCbs = [];\n      },\n      beforeDestroy: function beforeDestroy() {\n        // remove registryed resize event\n        if (this.destroyParentDomResize) {\n          this.destroyParentDomResize();\n          this.destroyParentDomResize = null;\n        }\n\n        if (this.destroy) {\n          this.destroy();\n        }\n      },\n\n      /** ------------------------------- Computed ----------------------------- */\n      computed: {\n        scrollPanelElm: function scrollPanelElm() {\n          return this.$refs['scrollPanel']._isVue ? this.$refs['scrollPanel'].$el : this.$refs['scrollPanel'];\n        }\n      },\n      data: function data() {\n        return {\n          vuescroll: {\n            state: {\n              isDragging: false,\n              pointerLeave: true,\n\n              /** Default sizeStrategies */\n              height: '100%',\n              width: '100%',\n              // current size strategy\n              currentSizeStrategy: 'percent'\n            }\n          },\n          bar: {\n            vBar: {\n              state: {\n                posValue: 0,\n                size: 0,\n                opacity: 0\n              }\n            },\n            hBar: {\n              state: {\n                posValue: 0,\n                size: 0,\n                opacity: 0\n              }\n            }\n          },\n          mergedOptions: {\n            vuescroll: {},\n            scrollPanel: {},\n            scrollContent: {},\n            rail: {},\n            bar: {}\n          },\n          updatedCbs: [],\n          renderError: false,\n          classHooks: {\n            hasVBar: false,\n            hasHBar: false,\n            vBarVisible: false,\n            hBarVisible: false,\n            vBarDragging: false,\n            hBarDragging: false,\n            clikingVerticalStartButton: false,\n            clikingVerticalEndButton: false,\n            clikingHorizontalStartButton: false,\n            clikingHorizontalEndButton: false,\n            mouseEnter: false\n          }\n        };\n      },\n\n      /** ------------------------------- Methods -------------------------------- */\n      methods: {\n        /** ------------------------ Handlers --------------------------- */\n        scrollingComplete: function scrollingComplete() {\n          this.updateBarStateAndEmitEvent('handle-scroll-complete');\n        },\n        setBarDrag: function setBarDrag(val) {\n          /* istanbul ignore next */\n          this.vuescroll.state.isDragging = val;\n        },\n        setClassHook: function setClassHook(name, value) {\n          this.classHooks[name] = value;\n        },\n\n        /** ------------------------ Some Helpers --------------------------- */\n\n        /*\n         * To have a good ux, instead of hiding bar immediately, we hide bar\n         * after some seconds by using this simple debounce-hidebar method.\n         */\n        showAndDefferedHideBar: function showAndDefferedHideBar(forceHideBar) {\n          var _this4 = this;\n\n          this.showBar();\n\n          if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = 0;\n          }\n\n          this.timeoutId = setTimeout(function () {\n            _this4.timeoutId = 0;\n\n            _this4.hideBar(forceHideBar);\n          }, this.mergedOptions.bar.showDelay);\n        },\n        showBar: function showBar() {\n          var opacity = this.mergedOptions.bar.opacity;\n          this.bar.vBar.state.opacity = opacity;\n          this.bar.hBar.state.opacity = opacity;\n        },\n        hideBar: function hideBar(forceHideBar) {\n          // when in non-native mode dragging content\n          // in slide mode, just return\n\n          /* istanbul ignore next */\n          if (this.vuescroll.state.isDragging) {\n            return;\n          }\n\n          if (forceHideBar && !this.mergedOptions.bar.keepShow) {\n            this.bar.hBar.state.opacity = 0;\n            this.bar.vBar.state.opacity = 0;\n          } // add isDragging condition\n          // to prevent from hiding bar while dragging the bar\n\n\n          if (!this.mergedOptions.bar.keepShow && !this.vuescroll.state.isDragging && this.vuescroll.state.pointerLeave) {\n            this.bar.vBar.state.opacity = 0;\n            this.bar.hBar.state.opacity = 0;\n          }\n        },\n        useNumbericSize: function useNumbericSize() {\n          var _this5 = this;\n\n          this.usePercentSize();\n          setTimeout(function () {\n            _this5.vuescroll.state.currentSizeStrategy = 'number';\n            var el = _this5.$el.parentNode || _this5.$el;\n            _this5.vuescroll.state.height = el.offsetHeight + 'px';\n            _this5.vuescroll.state.width = el.offsetWidth + 'px';\n\n            _this5.updateBarStateAndEmitEvent('handle-resize');\n          }, 0);\n        },\n        usePercentSize: function usePercentSize() {\n          this.vuescroll.state.currentSizeStrategy = 'percent';\n          this.vuescroll.state.height = '100%';\n          this.vuescroll.state.width = '100%';\n        },\n        // Set its size to be equal to its parentNode\n        setVsSize: function setVsSize() {\n          if (this.destroyParentDomResize) {\n            this.destroyParentDomResize();\n            this.destroyParentDomResize = null;\n          }\n\n          if (this.mergedOptions.vuescroll.sizeStrategy == 'number') {\n            this.useNumbericSize();\n            this.registryParentResize();\n          } else if (this.mergedOptions.vuescroll.sizeStrategy == 'percent') {\n            this.usePercentSize();\n          }\n        },\n\n        /** ------------------------ Init --------------------------- */\n        initWatchOpsChange: function initWatchOpsChange() {\n          var _this6 = this;\n\n          var watchOpts = {\n            deep: true,\n            sync: true\n          };\n          this.$watch('mergedOptions', function () {\n            setTimeout(function () {\n              if (_this6.isSmallChangeThisTick) {\n                _this6.isSmallChangeThisTick = false;\n\n                _this6.updateBarStateAndEmitEvent('options-change');\n\n                return;\n              }\n\n              _this6.refreshInternalStatus();\n            }, 0);\n          }, watchOpts);\n          /**\n           * We also watch `small` changes, and when small changes happen, we send\n           * a signal to vuescroll, to tell it:\n           * 1. we don't need to registry resize\n           * 2. we don't need to registry scroller.\n           */\n\n          smallChangeArray.forEach(function (opts) {\n            _this6.$watch(opts, function () {\n              _this6.isSmallChangeThisTick = true;\n            }, watchOpts);\n          });\n        },\n        // scrollTo hash-anchor while mounted component have mounted.\n        scrollToAnchor: function scrollToAnchor()\n        /* istanbul ignore next */\n        {\n          var validateHashSelector = function validateHashSelector(hash) {\n            return /^#[a-zA-Z_]\\d*$/.test(hash);\n          };\n\n          var hash = window.location.hash;\n\n          if (!hash || (hash = hash.slice(hash.lastIndexOf('#'))) && !validateHashSelector(hash)) {\n            return;\n          }\n\n          var elm = document.querySelector(hash);\n\n          if (!isChildInParent(elm, this.$el) || this.mergedOptions.scrollPanel.initialScrollY || this.mergedOptions.scrollPanel.initialScrollX) {\n            return;\n          }\n\n          this.scrollIntoView(elm);\n        },\n\n        /** ------------------------ Registry Resize --------------------------- */\n        registryParentResize: function registryParentResize() {\n          var resizeEnable = this.mergedOptions.vuescroll.detectResize;\n          this.destroyParentDomResize = resizeEnable ? installResizeDetection(this.$el.parentNode, this.useNumbericSize) : function () {};\n        }\n      }\n    };\n  }; // begin importing\n\n\n  var scrollPanel = {\n    name: 'scrollPanel',\n    props: {\n      ops: {\n        type: Object,\n        required: true\n      }\n    },\n    methods: {\n      // trigger scrollPanel options initialScrollX,\n      // initialScrollY\n      updateInitialScroll: function updateInitialScroll() {\n        var x = 0;\n        var y = 0;\n        var parent = getRealParent(this);\n\n        if (this.ops.initialScrollX) {\n          x = this.ops.initialScrollX;\n        }\n\n        if (this.ops.initialScrollY) {\n          y = this.ops.initialScrollY;\n        }\n\n        if (x || y) {\n          parent.scrollTo({\n            x: x,\n            y: y\n          });\n        }\n      }\n    },\n    mounted: function mounted() {\n      var _this = this;\n\n      setTimeout(function () {\n        if (!_this._isDestroyed) {\n          _this.updateInitialScroll();\n        }\n      }, 0);\n    },\n    render: function render(h) {\n      // eslint-disable-line\n      var data = {\n        class: ['__panel'],\n        style: {\n          position: 'relative',\n          boxSizing: 'border-box'\n        }\n      };\n      var parent = getRealParent(this);\n      var _customPanel = parent.$slots['scroll-panel'];\n\n      if (_customPanel) {\n        return insertChildrenIntoSlot(h, _customPanel, this.$slots.default, data);\n      }\n\n      return h('div', data, [[this.$slots.default]]);\n    }\n  };\n  /**\n   * Init following things\n   * 1. Component\n   * 2. Render\n   * 3. Config\n   */\n\n  function _install(core, render) {\n    var _components;\n\n    var extraConfigs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var extraValidators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var components = (_components = {}, defineProperty(_components, scrollPanel.name, scrollPanel), defineProperty(_components, bar.name, bar), _components);\n    var opts = {};\n    opts.components = components;\n    opts.render = render;\n    opts.mixins = core;\n    var comp = createComponent(opts); // Init Config\n\n    extendOpts(extraConfigs, extraValidators);\n    return comp;\n  }\n  /**\n   * Get the children of parent those are in viewport\n   */\n\n\n  function getCurrentViewportDom(parent, container) {\n    var children = parent.children;\n    var domFragment = [];\n\n    var isCurrentview = function isCurrentview(dom) {\n      var _dom$getBoundingClien = dom.getBoundingClientRect(),\n          left = _dom$getBoundingClien.left,\n          top = _dom$getBoundingClien.top,\n          width = _dom$getBoundingClien.width,\n          height = _dom$getBoundingClien.height;\n\n      var _container$getBoundin = container.getBoundingClientRect(),\n          parentLeft = _container$getBoundin.left,\n          parentTop = _container$getBoundin.top,\n          parentHeight = _container$getBoundin.height,\n          parentWidth = _container$getBoundin.width;\n\n      if (left - parentLeft + width > 0 && left - parentLeft < parentWidth && top - parentTop + height > 0 && top - parentTop < parentHeight) {\n        return true;\n      }\n\n      return false;\n    };\n\n    for (var i = 0; i < children.length; i++) {\n      var dom = children.item(i);\n\n      if (isCurrentview(dom) && !dom.isResizeElm) {\n        domFragment.push(dom);\n      }\n    }\n\n    return domFragment;\n  }\n  /**\n   *  Compatible to scroller's animation function\n   */\n\n\n  function createEasingFunction(easing, easingPattern) {\n    return function (time) {\n      return easingPattern(easing, time);\n    };\n  }\n  /**\n   * Calculate the easing pattern\n   * @link https://github.com/cferdinandi/smooth-scroll/blob/master/src/js/smooth-scroll.js\n   * modified by wangyi7099\n   * @param {String} type Easing pattern\n   * @param {Number} time Time animation should take to complete\n   * @returns {Number}\n   */\n\n\n  function easingPattern(easing, time) {\n    var pattern = null;\n    /* istanbul ignore next */\n\n    {\n      // Default Easing Patterns\n      if (easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity\n\n      if (easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity\n\n      if (easing === 'easeInOutQuad') pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration\n\n      if (easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity\n\n      if (easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity\n\n      if (easing === 'easeInOutCubic') pattern = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration\n\n      if (easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity\n\n      if (easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity\n\n      if (easing === 'easeInOutQuart') pattern = time < 0.5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration\n\n      if (easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity\n\n      if (easing === 'easeOutQuint') pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity\n\n      if (easing === 'easeInOutQuint') pattern = time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration\n    }\n    return pattern || time; // no easing, no acceleration\n  }\n\n  function noop() {\n    return true;\n  }\n  /* istanbul ignore next */\n\n\n  var now = Date.now || function () {\n    return new Date().getTime();\n  };\n\n  var ScrollControl = function () {\n    function ScrollControl() {\n      classCallCheck(this, ScrollControl);\n      this.init();\n      this.isRunning = false;\n    }\n\n    createClass(ScrollControl, [{\n      key: 'startScroll',\n      value: function startScroll(st, ed, spd) {\n        var stepCb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n        var completeCb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : noop;\n        var vertifyCb = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : noop;\n        var easingMethod = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : noop;\n        var df = ed - st;\n        var dir = df > 0 ? -1 : 1;\n        var nt = now();\n\n        if (!this.isRunning) {\n          this.init();\n        }\n\n        if (dir != this.dir || nt - this.ts > 200) {\n          this.ts = nt;\n          this.dir = dir;\n          this.st = st;\n          this.ed = ed;\n          this.df = df;\n        }\n        /* istanbul ignore next */\n        else {\n            this.df += df;\n          }\n\n        this.spd = spd;\n        this.completeCb = completeCb;\n        this.vertifyCb = vertifyCb;\n        this.stepCb = stepCb;\n        this.easingMethod = easingMethod;\n        this.ref = requestAnimationFrame(window);\n        if (!this.isRunning) this.execScroll();\n      }\n    }, {\n      key: 'execScroll',\n      value: function execScroll() {\n        var _this = this;\n\n        var percent = 0;\n        this.isRunning = true;\n\n        var loop = function loop() {\n          /* istanbul ignore if */\n          if (!_this.isRunning || !_this.vertifyCb(percent)) {\n            _this.isRunning = false;\n            return;\n          }\n\n          percent = (now() - _this.ts) / _this.spd;\n\n          if (percent < 1) {\n            var value = _this.st + _this.df * _this.easingMethod(percent);\n\n            _this.stepCb(value);\n\n            _this.ref(loop);\n          } else {\n            // trigger complete\n            _this.stepCb(_this.st + _this.df);\n\n            _this.completeCb();\n\n            _this.isRunning = false;\n          }\n        };\n\n        this.ref(loop);\n      }\n    }, {\n      key: 'init',\n      value: function init() {\n        this.st = 0;\n        this.ed = 0;\n        this.df = 0;\n        this.spd = 0;\n        this.ts = 0;\n        this.dir = 0;\n      }\n    }]);\n    return ScrollControl;\n  }();\n\n  function scrollTo(elm, x, y) {\n    var speed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;\n    var easing = arguments[4];\n    var scrollingComplete = arguments[5];\n    var scrollLeft = void 0,\n        scrollTop = void 0,\n        scrollHeight = void 0,\n        scrollWidth = void 0,\n        clientWidth = void 0,\n        clientHeight = void 0;\n    var _elm = elm,\n        nodeType = _elm.nodeType;\n    var scrollX = new ScrollControl();\n    var scrollY = new ScrollControl();\n\n    if (!nodeType) {\n      warn('You must pass a dom for the first param, ' + 'for window scrolling, ' + 'you can pass document as the first param.');\n      return;\n    }\n\n    if (nodeType == 9) {\n      // document\n      elm = elm.scrollingElement;\n    }\n\n    var _elm2 = elm;\n    scrollLeft = _elm2.scrollLeft;\n    scrollTop = _elm2.scrollTop;\n    scrollHeight = _elm2.scrollHeight;\n    scrollWidth = _elm2.scrollWidth;\n    clientWidth = _elm2.clientWidth;\n    clientHeight = _elm2.clientHeight;\n\n    if (typeof x === 'undefined') {\n      x = scrollLeft;\n    } else {\n      x = getNumericValue(x, scrollWidth - clientWidth);\n    }\n\n    if (typeof y === 'undefined') {\n      y = scrollTop;\n    } else {\n      y = getNumericValue(y, scrollHeight - clientHeight);\n    }\n\n    var easingMethod = createEasingFunction(easing, easingPattern);\n    scrollX.startScroll(scrollLeft, x, speed, function (dx) {\n      elm.scrollLeft = dx;\n    }, scrollingComplete, undefined, easingMethod);\n    scrollY.startScroll(scrollTop, y, speed, function (dy) {\n      elm.scrollTop = dy;\n    }, scrollingComplete, undefined, easingMethod);\n  }\n\n  var nativeApi = {\n    mounted: function mounted() {\n      // registry scroll\n      this.scrollX = new ScrollControl();\n      this.scrollY = new ScrollControl();\n    },\n    methods: {\n      nativeScrollTo: function nativeScrollTo(x, y, speed, easing) {\n        if (speed === false) {} else if (typeof speed === 'undefined') {\n          speed = this.mergedOptions.scrollPanel.speed;\n        }\n\n        var elm = this.scrollPanelElm;\n        var scrollTop = elm.scrollTop,\n            scrollLeft = elm.scrollLeft,\n            scrollWidth = elm.scrollWidth,\n            clientWidth = elm.clientWidth,\n            scrollHeight = elm.scrollHeight,\n            clientHeight = elm.clientHeight;\n\n        if (typeof x === 'undefined') {\n          x = scrollLeft;\n        } else {\n          x = getNumericValue(x, scrollWidth - clientWidth);\n        }\n\n        if (typeof y === 'undefined') {\n          y = scrollTop;\n        } else {\n          y = getNumericValue(y, scrollHeight - clientHeight);\n        }\n\n        if (speed) {\n          easing = easing || this.mergedOptions.scrollPanel.easing;\n          var easingMethod = createEasingFunction(easing, easingPattern);\n\n          if (x != scrollLeft) {\n            this.scrollX.startScroll(scrollLeft, x, speed, function (x) {\n              elm.scrollLeft = x;\n            }, this.scrollingComplete.bind(this), undefined, easingMethod);\n          }\n\n          if (y != scrollTop) {\n            this.scrollY.startScroll(scrollTop, y, speed, function (y) {\n              elm.scrollTop = y;\n            }, this.scrollingComplete.bind(this), undefined, easingMethod);\n          }\n        } else {\n          elm.scrollTop = y;\n          elm.scrollLeft = x;\n        }\n      },\n      getCurrentviewDomNative: function getCurrentviewDomNative() {\n        var parent = this.scrollContentElm;\n        var domFragment = getCurrentViewportDom(parent, this.$el);\n        return domFragment;\n      }\n    }\n  };\n\n  function getPanelData(context) {\n    // scrollPanel data start\n    var data = {\n      ref: 'scrollPanel',\n      style: {\n        height: '100%',\n        overflowY: 'scroll',\n        overflowX: 'scroll'\n      },\n      class: [],\n      nativeOn: {\n        '&scroll': context.handleScroll\n      },\n      props: {\n        ops: context.mergedOptions.scrollPanel\n      }\n    };\n    context.scrollYEnable = true;\n    context.scrollXEnable = true;\n    data.nativeOn.DOMMouseScroll = data.nativeOn.mousewheel = context.onMouseWheel;\n    var _context$mergedOption = context.mergedOptions.scrollPanel,\n        scrollingY = _context$mergedOption.scrollingY,\n        scrollingX = _context$mergedOption.scrollingX;\n\n    if (!context.bar.hBar.state.size || !scrollingX) {\n      context.scrollXEnable = false;\n      data.style.overflowX = 'hidden';\n    }\n\n    if (!context.bar.vBar.state.size || !scrollingY) {\n      context.scrollYEnable = false;\n      data.style.overflowY = 'hidden';\n    }\n\n    var gutter = getGutter();\n    /* istanbul ignore if */\n\n    if (!gutter) {\n      createHideBarStyle();\n      data.class.push('__hidebar');\n\n      if (isIos()) {\n        data.style['-webkit-overflow-scrolling'] = 'touch';\n      }\n    } else {\n      // hide system bar by use a negative value px\n      // gutter should be 0 when manually disable scrollingX #14\n      if (context.bar.vBar.state.size && context.mergedOptions.scrollPanel.scrollingY) {\n        if (context.mergedOptions.scrollPanel.verticalNativeBarPos == 'right') {\n          data.style.marginRight = '-' + gutter + 'px';\n        }\n        /* istanbul ignore next */\n        else {\n            data.style.marginLeft = '-' + gutter + 'px';\n          }\n      }\n\n      if (context.bar.hBar.state.size && context.mergedOptions.scrollPanel.scrollingX) {\n        data.style.height = 'calc(100% + ' + gutter + 'px)';\n      }\n    } // clear legency styles of slide mode...\n\n\n    data.style.transformOrigin = '';\n    data.style.transform = '';\n    return data;\n  }\n  /**\n   * create a scrollPanel\n   *\n   * @param {any} size\n   * @param {any} context\n   * @returns\n   */\n\n\n  function createPanel(h, context) {\n    var data = {};\n    data = getPanelData(context);\n    return h('scrollPanel', data, [getPanelChildren(h, context)]);\n  }\n\n  function getPanelChildren(h, context) {\n    var viewStyle = {\n      position: 'relative',\n      'box-sizing': 'border-box',\n      'min-width': '100%',\n      'min-height': '100%'\n    };\n    var data = {\n      style: viewStyle,\n      ref: 'scrollContent',\n      class: '__view'\n    };\n    var _customContent = context.$slots['scroll-content'];\n\n    if (context.mergedOptions.scrollPanel.scrollingX) {\n      viewStyle.width = getComplitableStyle('width', 'fit-content');\n    } else {\n      data.style['width'] = '100%';\n    }\n\n    if (context.mergedOptions.scrollPanel.padding) {\n      data.style.paddingRight = context.mergedOptions.rail.size;\n    }\n\n    if (_customContent) {\n      return insertChildrenIntoSlot(h, _customContent, context.$slots.default, data);\n    }\n\n    return h('div', data, [context.$slots.default]);\n  }\n\n  function getPanelData$1(context) {\n    // scrollPanel data start\n    var data = {\n      ref: 'scrollPanel',\n      style: {\n        'user-select': 'none',\n        '-webkit-user-select': 'none',\n        'min-width': '100%',\n        'min-height': '100%'\n      },\n      class: [],\n      props: {\n        ops: context.mergedOptions.scrollPanel\n      }\n    };\n    data.class.push('__slide');\n    /* istanbul ignore if */\n\n    if (isIos()) {\n      data.style = defineProperty({}, '-webkit-overflow-scrolling', 'touch');\n    }\n\n    if (context.mergedOptions.vuescroll.renderMethod == 'transform') {\n      data.style['transform-origin'] = 'left top 0px';\n    }\n\n    var _context$mergedOption = context.mergedOptions.scrollPanel,\n        scrollingX = _context$mergedOption.scrollingX,\n        scrollingY = _context$mergedOption.scrollingY,\n        padding = _context$mergedOption.padding;\n\n    if (scrollingX && !context.refreshLoad) {\n      var width = getComplitableStyle('width', 'fit-content');\n\n      if (width) {\n        data.style['width'] = width;\n      }\n      /* istanbul ignore next */\n      else {\n          data['display'] = 'inline-block';\n        }\n    }\n    /* istanbul ignore if */\n\n\n    if (!scrollingX) {\n      data.class.push('x-hidden');\n    }\n    /* istanbul ignore if */\n\n\n    if (!scrollingY) {\n      data.class.push('y-hidden');\n    }\n\n    if (padding) {\n      data.style.paddingRight = context.mergedOptions.rail.size;\n    }\n\n    return data;\n  }\n\n  function getPanelChildren$1(h, context) {\n    var renderChildren = getVnodeInfo(context.$slots['scroll-panel']).ch || context.$slots.default;\n    var finalChildren = [];\n    /* istanbul ignore if */\n\n    if (!renderChildren) {\n      context.$slots.default = renderChildren = [];\n    } // handle refresh\n\n\n    if (context.mergedOptions.vuescroll.pullRefresh.enable) {\n      finalChildren.push(h('div', {\n        'class': '__refresh',\n        style: {\n          visibility: context.refrehDomVisiable ? '' : 'hidden'\n        },\n        ref: __REFRESH_DOM_NAME,\n        key: __REFRESH_DOM_NAME\n      }, [createTipDom(h, context, 'refresh', context.pullRefreshTip)]));\n    }\n\n    finalChildren.push(renderChildren); // handle load\n\n    if (context.mergedOptions.vuescroll.pushLoad.enable) {\n      finalChildren.push(h('div', {\n        ref: __LOAD_DOM_NAME,\n        key: __LOAD_DOM_NAME,\n        'class': '__load',\n        style: {\n          visibility: context.loadDomVisiable ? '' : 'hidden'\n        }\n      }, [createTipDom(h, context, 'load', context.pushLoadTip)]));\n    }\n\n    return finalChildren;\n  } // Create load or refresh tip dom of each stages\n\n\n  function createTipDom(h, context, type, tip) {\n    var stage = context.vuescroll.state[type + 'Stage'];\n    var dom = null; // Return user specified animation dom\n\n    /* istanbul ignore if */\n\n    if (dom = context.$slots[type + '-' + stage]) {\n      return dom;\n    }\n\n    switch (stage) {\n      // The dom will show at deactive stage\n      case 'deactive':\n      case 'active':\n        {\n          var className = 'active';\n\n          if (stage == 'deactive') {\n            className += ' deactive';\n          }\n\n          dom = h('svg', {\n            'class': className,\n            attrs: {\n              version: '1.1',\n              xmlns: 'http://www.w3.org/2000/svg',\n              xmlnsXlink: 'http://www.w3.org/1999/xlink',\n              x: '0px',\n              y: '0px',\n              viewBox: '0 0 1000 1000',\n              'enable-background': 'new 0 0 1000 1000',\n              xmlSpace: 'preserve'\n            }\n          }, [h('metadata', [' Svg Vector Icons : http://www.sfont.cn ']), h('g', [h('g', {\n            attrs: {\n              transform: 'matrix(1 0 0 -1 0 1008)'\n            }\n          }, [h('path', {\n            attrs: {\n              d: 'M10,543l490,455l490-455L885,438L570,735.5V18H430v717.5L115,438L10,543z'\n            }\n          })])])]);\n        }\n        break;\n\n      case 'start':\n        dom = h('svg', {\n          attrs: {\n            viewBox: '0 0 50 50'\n          },\n          'class': 'start'\n        }, [h('circle', {\n          attrs: {\n            stroke: 'true',\n            cx: '25',\n            cy: '25',\n            r: '20'\n          },\n          'class': 'bg-path'\n        }), h('circle', {\n          attrs: {\n            cx: '25',\n            cy: '25',\n            r: '20'\n          },\n          'class': 'active-path'\n        })]);\n        break;\n\n      case 'beforeDeactive':\n        dom = h('svg', {\n          attrs: {\n            viewBox: '0 0 1024 1024',\n            version: '1.1',\n            xmlns: 'http://www.w3.org/2000/svg',\n            'p-id': '3562'\n          }\n        }, [h('path', {\n          attrs: {\n            d: 'M512 0C229.706831 0 0 229.667446 0 512s229.667446 512 512 512c282.293169 0 512-229.667446 512-512S794.332554 0 512 0z m282.994215 353.406031L433.2544 715.145846a31.484062 31.484062 0 0 1-22.275938 9.231754h-0.4096a31.586462 31.586462 0 0 1-22.449231-9.814646L228.430769 546.327631a31.507692 31.507692 0 0 1 45.701908-43.386093l137.4208 144.785724L750.442338 308.854154a31.507692 31.507692 0 1 1 44.551877 44.551877z',\n            fill: '',\n            'p-id': '3563'\n          }\n        })]);\n        break;\n    }\n\n    return [dom, tip];\n  }\n  /**\n   * create a scrollPanel\n   *\n   * @param {any} size\n   * @param {any} context\n   * @returns\n   */\n\n\n  function createPanel$1(h, context) {\n    var data = getPanelData$1(context);\n    return h('scrollPanel', data, [getPanelChildren$1(h, context)]);\n  } // begin importing\n\n  /**\n   * create a scrollPanel\n   *\n   * @param {any} size\n   * @param {any} vm\n   * @returns\n   */\n\n\n  function createPanel$2(h, vm) {\n    if (vm.mode == 'native') {\n      return createPanel(h, vm);\n    } else if (vm.mode == 'slide') {\n      return createPanel$1(h, vm);\n    }\n  }\n\n  var slideApi = {\n    methods: {\n      slideScrollTo: function slideScrollTo(x, y, speed, easing) {\n        var _getPosition = this.getPosition(),\n            scrollLeft = _getPosition.scrollLeft,\n            scrollTop = _getPosition.scrollTop;\n\n        x = getNumericValue(x || scrollLeft, this.scroller.__maxScrollLeft);\n        y = getNumericValue(y || scrollTop, this.scroller.__maxScrollTop);\n        this.scroller.scrollTo(x, y, speed > 0, undefined, false, speed, easing);\n      },\n      zoomBy: function zoomBy(factor, animate, originLeft, originTop, callback) {\n        if (!this.scroller) {\n          warn('zoomBy and zoomTo are only for slide mode!');\n          return;\n        }\n\n        this.scroller.zoomBy(factor, animate, originLeft, originTop, callback);\n      },\n      zoomTo: function zoomTo(level) {\n        var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var originLeft = arguments[2];\n        var originTop = arguments[3];\n        var callback = arguments[4];\n\n        if (!this.scroller) {\n          warn('zoomBy and zoomTo are only for slide mode!');\n          return;\n        }\n\n        this.scroller.zoomTo(level, animate, originLeft, originTop, callback);\n      },\n      getCurrentPage: function getCurrentPage() {\n        if (!this.scroller || !this.mergedOptions.vuescroll.paging) {\n          warn('getCurrentPage and goToPage are only for slide mode and paging is enble!');\n          return;\n        }\n\n        return this.scroller.getCurrentPage();\n      },\n      goToPage: function goToPage(dest) {\n        var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (!this.scroller || !this.mergedOptions.vuescroll.paging) {\n          warn('getCurrentPage and goToPage are only for slide mode and paging is enble!');\n          return;\n        }\n\n        this.scroller.goToPage(dest, animate);\n      },\n      triggerRefreshOrLoad: function triggerRefreshOrLoad(type) {\n        if (!this.scroller) {\n          warn('You can only use triggerRefreshOrLoad in slide mode!');\n          return;\n        }\n\n        var isRefresh = this.mergedOptions.vuescroll.pullRefresh.enable;\n        var isLoad = this.mergedOptions.vuescroll.pushLoad.enable;\n\n        if (type == 'refresh' && !isRefresh) {\n          warn('refresh must be enabled!');\n          return;\n        } else if (type == 'load' && !isLoad) {\n          warn('load must be enabled and content\\'s height > container\\'s height!');\n          return;\n        } else if (type !== 'refresh' && type !== 'load') {\n          warn('param must be one of load and refresh!');\n          return;\n        }\n        /* istanbul ignore if */\n\n\n        if (this.vuescroll.state[type + 'Stage'] == 'start') {\n          return;\n        }\n\n        this.scroller.triggerRefreshOrLoad(type);\n        return true;\n      },\n      getCurrentviewDomSlide: function getCurrentviewDomSlide() {\n        var parent = this.scrollPanelElm;\n        var domFragment = getCurrentViewportDom(parent, this.$el);\n        return domFragment;\n      }\n    }\n  };\n  var api$1 = {\n    // mix slide and nitive modes apis.\n    mixins: [slideApi, nativeApi],\n    methods: {\n      // private api\n      internalScrollTo: function internalScrollTo(destX, destY, speed, easing) {\n        if (this.mode == 'native') {\n          this.nativeScrollTo(destX, destY, speed, easing);\n        } // for non-native we use scroller's scorllTo\n        else if (this.mode == 'slide') {\n            this.slideScrollTo(destX, destY, speed, easing);\n          }\n      },\n      getCurrentviewDom: function getCurrentviewDom() {\n        return this.mode == 'slide' ? this.getCurrentviewDomSlide() : this.getCurrentviewDomNative();\n      }\n    }\n  };\n  /*\n   * Scroller\n   * http://github.com/zynga/scroller\n   *\n   * Copyright 2011, Zynga Inc.\n   * Licensed under the MIT License.\n   * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n   *\n   * Based on the work of: Unify Project (unify-project.org)\n   * http://unify-project.org\n   * Copyright 2011, Deutsche Telekom AG\n   * License: MIT + Apache (V2)\n   */\n\n  /**\n   * Generic animation class with support for dropped frames both optional easing and duration.\n   *\n   * Optional duration is useful when the lifetime is defined by another condition than time\n   * e.g. speed of an animating object, etc.\n   *\n   * Dropped frame logic allows to keep using the same updater logic independent from the actual\n   * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n   * based on the pure time difference.\n   */\n\n  var time = Date.now || function () {\n    return +new Date();\n  };\n\n  var desiredFrames = 60;\n  var millisecondsPerSecond = 1000;\n  var running = {};\n  var counter = 1;\n  var core = {\n    effect: {}\n  };\n  var global$1 = null;\n\n  if (typeof window !== 'undefined') {\n    global$1 = window;\n  } else {\n    global$1 = {};\n  }\n\n  core.effect.Animate = {\n    /**\n     * A requestAnimationFrame wrapper / polyfill.\n     *\n     * @param callback {Function} The callback to be invoked before the next repaint.\n     * @param root {HTMLElement} The root element for the repaint\n     */\n    requestAnimationFrame: requestAnimationFrame(global$1),\n\n    /**\n     * Stops the given animation.\n     *\n     * @param id {Integer} Unique animation ID\n     * @return {Boolean} Whether the animation was stopped (aka, was running before)\n     */\n    stop: function stop(id) {\n      var cleared = running[id] != null;\n\n      if (cleared) {\n        running[id] = null;\n      }\n\n      return cleared;\n    },\n\n    /**\n     * Whether the given animation is still running.\n     *\n     * @param id {Integer} Unique animation ID\n     * @return {Boolean} Whether the animation is still running\n     */\n    isRunning: function isRunning(id) {\n      return running[id] != null;\n    },\n\n    /**\n     * Start the animation.\n     *\n     * @param stepCallback {Function} Pointer to function which is executed on every step.\n     *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n     * @param verifyCallback {Function} Executed before every animation step.\n     *   Signature of the method should be `function() { return continueWithAnimation; }`\n     * @param completedCallback {Function}\n     *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n     * @param duration {Integer} Milliseconds to run the animation\n     * @param easingMethod {Function} Pointer to easing function\n     *   Signature of the method should be `function(percent) { return modifiedValue; }`\n     * @param root {Element ? document.body} Render root, when available. Used for internal\n     *   usage of requestAnimationFrame.\n     * @return {Integer} Identifier of animation. Can be used to stop it any time.\n     */\n    start: function start(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {\n      var start = time();\n      var lastFrame = start;\n      var percent = 0;\n      var dropCounter = 0;\n      var id = counter++;\n\n      if (!root) {\n        root = document.body;\n      } // Compacting running db automatically every few new animations\n\n\n      if (id % 20 === 0) {\n        var newRunning = {};\n\n        for (var usedId in running) {\n          newRunning[usedId] = true;\n        }\n\n        running = newRunning;\n      } // This is the internal step method which is called every few milliseconds\n\n\n      var step = function step(virtual) {\n        // Normalize virtual value\n        var render = virtual !== true; // Get current time\n\n        var now = time(); // Verification is executed before next animation step\n\n        if (!running[id] || verifyCallback && !verifyCallback(id)) {\n          running[id] = null;\n          completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, false);\n          return;\n        } // For the current rendering to apply let's update omitted steps in memory.\n        // This is important to bring internal state variables up-to-date with progress in time.\n\n\n        if (render) {\n          var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;\n\n          for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n            step(true);\n            dropCounter++;\n          }\n        }\n\n        if (!running[id]) {\n          return;\n        } // Compute percent value\n\n\n        if (duration) {\n          percent = (now - start) / duration;\n\n          if (percent > 1) {\n            percent = 1;\n          }\n        } // Execute step callback, then...\n\n\n        var value = easingMethod ? easingMethod(percent) : percent;\n\n        if ((stepCallback(value, now, render) === false || percent === 1) && render) {\n          running[id] = null;\n          completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, percent === 1 || duration == null);\n        } else if (render) {\n          lastFrame = now;\n          core.effect.Animate.requestAnimationFrame(step, root);\n        }\n      }; // Mark as running\n\n\n      running[id] = true; // Init first step\n\n      core.effect.Animate.requestAnimationFrame(step, root); // Return unique animation ID\n\n      return id;\n    }\n  };\n  /*\n   * Scroller\n   * http://github.com/zynga/scroller\n   *\n   * modified by wangyi7099\n   *\n   * Copyright 2011, Zynga Inc.\n   * Licensed under the MIT License.\n   * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n   *\n   * Based on the work of: Unify Project (unify-project.org)\n   * http://unify-project.org\n   * Copyright 2011, Deutsche Telekom AG\n   * License: MIT + Apache (V2)\n   */\n\n  var animatingMethod = null;\n  var noAnimatingMethod = null;\n\n  function Scroller(callback, options) {\n    this.__callback = callback;\n    this.options = {\n      /** Enable scrolling on x-axis */\n      scrollingX: true,\n\n      /** Enable scrolling on y-axis */\n      scrollingY: true,\n\n      /** Enable animations for deceleration, snap back, zooming and scrolling */\n      animating: true,\n\n      /** duration for animations triggered by scrollTo/zoomTo */\n      animationDuration: 250,\n\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n      bouncing: {\n        top: 100,\n        bottom: 100,\n        left: 100,\n        right: 100\n      },\n\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\n      locking: true,\n\n      /** Enable pagination mode (switching between full page content panes) */\n      paging: false,\n\n      /** Enable snapping of content to a configured pixel grid */\n      snapping: false,\n\n      /** Enable zooming of content via API, fingers and mouse wheel */\n      zooming: false,\n\n      /** Minimum zoom level */\n      minZoom: 0.5,\n\n      /** Maximum zoom level */\n      maxZoom: 3,\n\n      /** Multiply or decrease scrolling speed **/\n      speedMultiplier: 1,\n\n      /** Callback that is fired on the later of touch end or deceleration end,\n      provided that another scrolling action has not begun. Used to know\n      when to fade out a scrollbar. */\n      scrollingComplete: NOOP,\n      animatingEasing: 'easeOutCubic',\n      noAnimatingEasing: 'easeInOutCubic',\n\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n      penetrationDeceleration: 0.03,\n\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n      penetrationAcceleration: 0.08\n    };\n\n    for (var key in options) {\n      this.options[key] = options[key];\n    }\n\n    animatingMethod = createEasingFunction(this.options.animatingEasing, easingPattern);\n    noAnimatingMethod = createEasingFunction(this.options.noAnimatingEasing, easingPattern);\n  }\n\n  var members = {\n    /*\n    ---------------------------------------------------------------------------\n    INTERNAL FIELDS :: STATUS\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Boolean} Whether only a single finger is used in touch handling */\n    __isSingleTouch: false,\n\n    /** {Boolean} Whether a touch event sequence is in progress */\n    __isTracking: false,\n\n    /** {Boolean} Whether a deceleration animation went to completion. */\n    __didDecelerationComplete: false,\n\n    /**\n     * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n     * a gesturestart event happens. This has higher priority than dragging.\n     */\n    __isGesturing: false,\n\n    /**\n     * {Boolean} Whether the user has moved by such a distance that we have enabled\n     * dragging mode. Hint: It's only enabled after some pixels of movement to\n     * not interrupt with clicks etc.\n     */\n    __isDragging: false,\n\n    /**\n     * {Boolean} Not touching and dragging anymore, and smoothly animating the\n     * touch sequence using deceleration.\n     */\n    __isDecelerating: false,\n\n    /**\n     * {Boolean} Smoothly animating the currently configured change\n     */\n    __isAnimating: false,\n\n    /*\n    ---------------------------------------------------------------------------\n    INTERNAL FIELDS :: DIMENSIONS\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Integer} Available outer left position (from document perspective) */\n    __clientLeft: 0,\n\n    /** {Integer} Available outer top position (from document perspective) */\n    __clientTop: 0,\n\n    /** {Integer} Available outer width */\n    __clientWidth: 0,\n\n    /** {Integer} Available outer height */\n    __clientHeight: 0,\n\n    /** {Integer} Outer width of content */\n    __contentWidth: 0,\n\n    /** {Integer} Outer height of content */\n    __contentHeight: 0,\n\n    /** {Integer} Snapping width for content */\n    __snapWidth: 100,\n\n    /** {Integer} Snapping height for content */\n    __snapHeight: 100,\n\n    /** {Integer} Height to assign to refresh area */\n    __refreshHeight: null,\n\n    /** {Integer} Height to assign to refresh area */\n    __loadHeight: null,\n\n    /** {Boolean} Whether the refresh process is enabled when the event is released now */\n    __refreshActive: false,\n\n    /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n    __refreshActivate: null,\n    __refreshBeforeDeactivate: null,\n\n    /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n    __refreshDeactivate: null,\n\n    /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n    __refreshStart: null,\n    __loadActive: null,\n    __loadActivate: null,\n    __loadBeforeDeactivate: null,\n    __loadDeactivate: null,\n    __loadStart: null,\n\n    /** {Number} Zoom level */\n    __zoomLevel: 1,\n\n    /** {Number} Scroll position on x-axis */\n    __scrollLeft: 0,\n\n    /** {Number} Scroll position on y-axis */\n    __scrollTop: 0,\n\n    /** {Integer} Maximum allowed scroll position on x-axis */\n    __maxScrollLeft: 0,\n\n    /** {Integer} Maximum allowed scroll position on y-axis */\n    __maxScrollTop: 0,\n\n    /* {Number} Scheduled left position (final position when animating) */\n    __scheduledLeft: 0,\n\n    /* {Number} Scheduled top position (final position when animating) */\n    __scheduledTop: 0,\n\n    /* {Number} Scheduled zoom level (final scale when animating) */\n    __scheduledZoom: 0,\n\n    /**\n     * current page\n     */\n    __currentPageX: null,\n    __currentPageY: null,\n\n    /**\n     * total page\n     */\n    __totalXPage: null,\n    __totalYPage: null,\n\n    /*\n    ---------------------------------------------------------------------------\n    INTERNAL FIELDS :: LAST POSITIONS\n    ---------------------------------------------------------------------------\n    */\n\n    /** whether the scroller is disabled or not */\n    __disable: false,\n\n    /** {Number} Left position of finger at start */\n    __lastTouchLeft: null,\n\n    /** {Number} Top position of finger at start */\n    __lastTouchTop: null,\n\n    /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n    __lastTouchMove: null,\n\n    /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n    __positions: null,\n\n    /*\n    ---------------------------------------------------------------------------\n    INTERNAL FIELDS :: DECELERATION SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n    /** {Integer} Minimum left scroll position during deceleration */\n    __minDecelerationScrollLeft: null,\n\n    /** {Integer} Minimum top scroll position during deceleration */\n    __minDecelerationScrollTop: null,\n\n    /** {Integer} Maximum left scroll position during deceleration */\n    __maxDecelerationScrollLeft: null,\n\n    /** {Integer} Maximum top scroll position during deceleration */\n    __maxDecelerationScrollTop: null,\n\n    /** {Number} Current factor to modify horizontal scroll position with on every step */\n    __decelerationVelocityX: null,\n\n    /** {Number} Current factor to modify vertical scroll position with on every step */\n    __decelerationVelocityY: null,\n\n    /*\n    ---------------------------------------------------------------------------\n    PUBLIC API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Configures the dimensions of the client (outer) and content (inner) elements.\n     * Requires the available space for the outer element and the outer size of the inner element.\n     * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n     *\n     * @param clientWidth {Integer ? null} Inner width of outer element\n     * @param clientHeight {Integer ? null} Inner height of outer element\n     * @param contentWidth {Integer ? null} Outer width of inner element\n     * @param contentHeight {Integer ? null} Outer height of inner element\n     */\n    setDimensions: function setDimensions(clientWidth, clientHeight, contentWidth, contentHeight, animate) {\n      var noScroll = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      var self = this; // Only update values which are defined\n\n      if (clientWidth === +clientWidth) {\n        self.__clientWidth = clientWidth;\n      }\n\n      if (clientHeight === +clientHeight) {\n        self.__clientHeight = clientHeight;\n      }\n\n      if (contentWidth === +contentWidth) {\n        self.__contentWidth = contentWidth;\n      }\n\n      if (contentHeight === +contentHeight) {\n        self.__contentHeight = contentHeight;\n      } // Refresh maximums\n\n\n      self.__computeScrollMax();\n\n      if (!noScroll) {\n        // Refresh scroll position\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, animate);\n      }\n    },\n\n    /**\n     * Sets the client coordinates in relation to the document.\n     *\n     * @param left {Integer ? 0} Left position of outer element\n     * @param top {Integer ? 0} Top position of outer element\n     */\n    setPosition: function setPosition(left, top) {\n      var self = this;\n      self.__clientLeft = left || 0;\n      self.__clientTop = top || 0;\n    },\n\n    /**\n     * Configures the snapping (when snapping is active)\n     *\n     * @param width {Integer} Snapping width\n     * @param height {Integer} Snapping height\n     */\n    setSnapSize: function setSnapSize(width, height) {\n      var self = this;\n      self.__snapWidth = width;\n      self.__snapHeight = height;\n    },\n\n    /**\n     * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n     * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n     * the official Twitter client.\n     *\n     * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n     * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n     * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n     * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n     */\n    activatePullToRefresh: function activatePullToRefresh(height, _ref) {\n      var activateCallback = _ref.activateCallback,\n          deactivateCallback = _ref.deactivateCallback,\n          startCallback = _ref.startCallback,\n          beforeDeactivateCallback = _ref.beforeDeactivateCallback,\n          beforeDeactiveEnd = _ref.beforeDeactiveEnd;\n      var self = this;\n      self.__refreshHeight = height;\n      self.__refreshActivate = activateCallback;\n      self.__refreshBeforeDeactivate = beforeDeactivateCallback;\n      self.__refreshBeforeDeactiveEnd = beforeDeactiveEnd;\n      self.__refreshDeactivate = deactivateCallback;\n      self.__refreshStart = startCallback;\n    },\n    activatePushToLoad: function activatePushToLoad(height, _ref2) {\n      var activateCallback = _ref2.activateCallback,\n          deactivateCallback = _ref2.deactivateCallback,\n          startCallback = _ref2.startCallback,\n          beforeDeactivateCallback = _ref2.beforeDeactivateCallback,\n          beforeDeactiveEnd = _ref2.beforeDeactiveEnd;\n      var self = this;\n      self.__loadHeight = height;\n      self.__loadActivate = activateCallback;\n      self.__loadBeforeDeactivate = beforeDeactivateCallback;\n      self.__loadBeforeDeactiveEnd = beforeDeactiveEnd;\n      self.__loadDeactivate = deactivateCallback;\n      self.__loadStart = startCallback;\n    },\n\n    /**\n     * Starts pull-to-refresh manually.\n     */\n    triggerRefreshOrLoad: function triggerRefreshOrLoad() {\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'refresh';\n      var wasDecelerating = this.__isDecelerating;\n\n      if (wasDecelerating) {\n        core.effect.Animate.stop(wasDecelerating);\n        this.__isDecelerating = false;\n      } // Use publish instead of scrollTo to allow scrolling to out of boundary position\n      // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n\n\n      if (type == 'refresh') {\n        if (this.__refreshActive || this.__refreshBeforeDeactiveStarted) return;\n\n        this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);\n\n        if (this.__refreshStart) {\n          this.__refreshStart();\n\n          this.__refreshActive = true;\n        }\n      } else if (type == 'load') {\n        if (this.__loadActive || this.__loadBeforeDeactiveStarted) return;\n\n        this.__publish(this.__scrollLeft, this.__maxScrollTop + this.__loadHeight, this.__zoomLevel, true);\n\n        if (this.__loadStart) {\n          this.__loadStart();\n\n          this.__loadActive = true;\n        }\n      }\n    },\n\n    /**\n     * Signalizes that pull-to-refresh is finished.\n     */\n    finishRefreshOrLoad: function finishRefreshOrLoad() {\n      var self = this;\n\n      if (self.__refreshActive) {\n        self.__refreshActive = false;\n\n        var endRefreshActive = function endRefreshActive() {\n          if (self.__refreshBeforeDeactiveEnd) {\n            self.__refreshBeforeDeactiveEnd();\n          }\n\n          self.__refreshBeforeDeactiveStarted = true;\n          self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n        };\n\n        if (self.__refreshBeforeDeactivate) {\n          self.__refreshBeforeDeactivate(endRefreshActive);\n        } else {\n          endRefreshActive();\n        }\n      }\n\n      if (self.__loadActive) {\n        self.__loadActive = false;\n\n        var endLoadActive = function endLoadActive() {\n          if (self.__loadBeforeDeactiveEnd) {\n            self.__loadBeforeDeactiveEnd();\n          }\n\n          self.__loadBeforeDeactiveStarted = true;\n          self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n        };\n\n        if (self.__loadBeforeDeactivate) {\n          self.__loadBeforeDeactivate(endLoadActive);\n        } else {\n          endLoadActive();\n        }\n      }\n    },\n\n    /**\n     * Returns the scroll position and zooming values\n     *\n     * @return {Map} `left` and `top` scroll position and `zoom` level\n     */\n    getValues: function getValues() {\n      var self = this;\n      return {\n        left: self.__scrollLeft,\n        top: self.__scrollTop,\n        zoom: self.__zoomLevel\n      };\n    },\n\n    /**\n     * Returns the maximum scroll values\n     *\n     * @return {Map} `left` and `top` maximum scroll values\n     */\n    getScrollMax: function getScrollMax() {\n      var self = this;\n      return {\n        left: self.__maxScrollLeft,\n        top: self.__maxScrollTop\n      };\n    },\n\n    /**\n     * Zooms to the given level. Supports optional animation. Zooms\n     * the center when no coordinates are given.\n     *\n     * @param level {Number} Level to zoom to\n     * @param animate {Boolean ? false} Whether to use animation\n     * @param originLeft {Number ? null} Zoom in at given left coordinate\n     * @param originTop {Number ? null} Zoom in at given top coordinate\n     * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n     */\n    zoomTo: function zoomTo(level, animate, originLeft, originTop, callback) {\n      var self = this;\n\n      if (!self.options.zooming) {\n        throw new Error('Zooming is not enabled!');\n      } // Add callback if exists\n\n\n      if (callback) {\n        self.__zoomComplete = callback;\n      } // Stop deceleration\n\n\n      if (self.__isDecelerating) {\n        core.effect.Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n      }\n\n      var oldLevel = self.__zoomLevel; // Normalize input origin to center of viewport if not defined\n\n      if (originLeft == null) {\n        originLeft = self.__clientWidth / 2;\n      }\n\n      if (originTop == null) {\n        originTop = self.__clientHeight / 2;\n      } // Limit level according to configuration\n\n\n      level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom); // Recompute maximum values while temporary tweaking maximum scroll ranges\n\n      self.__computeScrollMax(level); // Recompute left and top coordinates based on new zoom level\n\n\n      var left = (originLeft + self.__scrollLeft) * level / oldLevel - originLeft;\n      var top = (originTop + self.__scrollTop) * level / oldLevel - originTop; // Limit x-axis\n\n      if (left > self.__maxScrollLeft) {\n        left = self.__maxScrollLeft;\n      } else if (left < 0) {\n        left = 0;\n      } // Limit y-axis\n\n\n      if (top > self.__maxScrollTop) {\n        top = self.__maxScrollTop;\n      } else if (top < 0) {\n        top = 0;\n      } // Push values out\n\n\n      self.__publish(left, top, level, animate);\n    },\n\n    /**\n     * Zooms the content by the given factor.\n     *\n     * @param factor {Number} Zoom by given factor\n     * @param animate {Boolean ? false} Whether to use animation\n     * @param originLeft {Number ? 0} Zoom in at given left coordinate\n     * @param originTop {Number ? 0} Zoom in at given top coordinate\n     * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n     */\n    zoomBy: function zoomBy(factor, animate, originLeft, originTop, callback) {\n      var self = this;\n      self.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop, callback);\n    },\n\n    /**\n     * Scrolls to the given position. Respect limitations and snapping automatically.\n     *\n     * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n     * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n     * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n     * @param zoom {Number?null} Zoom level to go to\n     */\n    scrollTo: function scrollTo(left, top, animate, zoom, force, speed, easing) {\n      var self = this; // Stop deceleration\n\n      if (self.__isDecelerating) {\n        core.effect.Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n      } // Correct coordinates based on new zoom level\n\n\n      if (zoom != null && zoom !== self.__zoomLevel) {\n        if (!self.options.zooming) {\n          throw new Error('Zooming is not enabled!');\n        }\n\n        left *= zoom;\n        top *= zoom; // Recompute maximum values while temporary tweaking maximum scroll ranges\n\n        self.__computeScrollMax(zoom);\n      } else {\n        // Keep zoom when not defined\n        zoom = self.__zoomLevel;\n      }\n\n      if (!self.options.scrollingX && !force) {\n        left = self.__scrollLeft;\n      } else {\n        if (self.options.paging) {\n          left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n        } else if (self.options.snapping) {\n          left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n        }\n      }\n\n      if (!self.options.scrollingY && !force) {\n        top = self.__scrollTop;\n      } else {\n        if (self.options.paging) {\n          top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n        } else if (self.options.snapping) {\n          top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n        }\n      }\n\n      if (!force) {\n        // Limit for allowed ranges\n        left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n        top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n      } // Don't animate when no change detected, still call publish to make sure\n      // that rendered position is really in-sync with internal data\n\n\n      if (left === self.__scrollLeft && top === self.__scrollTop) {\n        animate = false;\n      } // Publish new values\n\n\n      if (!self.__isTracking) {\n        self.__publish(left, top, zoom, animate, speed, easing);\n      }\n    },\n\n    /**\n     * Scroll by the given offset\n     *\n     * @param left {Number ? 0} Scroll x-axis by given offset\n     * @param top {Number ? 0} Scroll x-axis by given offset\n     * @param animate {Boolean ? false} Whether to animate the given change\n     */\n    scrollBy: function scrollBy(left, top, animate) {\n      var self = this;\n      var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;\n      var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n      self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n    },\n    getCurrentPage: function getCurrentPage() {\n      this.__computePage();\n\n      return {\n        x: this.__currentPageX,\n        y: this.__currentPageY\n      };\n    },\n    goToPage: function goToPage(_ref3, animate) {\n      var x = _ref3.x,\n          y = _ref3.y;\n\n      if (isNaN(x)) {\n        x = 1;\n      }\n\n      if (isNaN(y)) {\n        y = 1;\n      }\n\n      this.scrollTo((x - 1) * this.__clientWidth, (y - 1) * this.__clientHeight, animate);\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n    EVENT CALLBACKS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Mouse wheel handler for zooming support\n     */\n    doMouseZoom: function doMouseZoom(wheelDelta, timeStamp, pageX, pageY) {\n      var self = this;\n      var change = wheelDelta > 0 ? 0.97 : 1.03;\n      return self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop);\n    },\n\n    /**\n     * Touch start handler for scrolling support\n     */\n    doTouchStart: function doTouchStart(touches, timeStamp) {\n      // Array-like check is enough here\n      if (touches.length == null) {\n        throw new Error('Invalid touch list: ' + touches);\n      }\n\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n\n      if (typeof timeStamp !== 'number') {\n        throw new Error('Invalid timestamp value: ' + timeStamp);\n      }\n\n      var self = this; // Reset interruptedAnimation flag\n\n      self.__interruptedAnimation = true; // Stop deceleration\n\n      if (self.__isDecelerating) {\n        core.effect.Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n        self.__interruptedAnimation = true;\n      } // Stop animation\n\n\n      if (self.__isAnimating) {\n        core.effect.Animate.stop(self.__isAnimating);\n        self.__isAnimating = false;\n        self.__interruptedAnimation = true;\n      } // Use center point when dealing with two fingers\n\n\n      var currentTouchLeft, currentTouchTop;\n      var isSingleTouch = touches.length === 1;\n\n      if (isSingleTouch) {\n        currentTouchLeft = touches[0].pageX;\n        currentTouchTop = touches[0].pageY;\n      } else {\n        currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      } // Store initial positions\n\n\n      self.__initialTouchLeft = currentTouchLeft;\n      self.__initialTouchTop = currentTouchTop; // Store current zoom level\n\n      self.__zoomLevelStart = self.__zoomLevel; // Store initial touch positions\n\n      self.__lastTouchLeft = currentTouchLeft;\n      self.__lastTouchTop = currentTouchTop; // Store initial move time stamp\n\n      self.__lastTouchMove = timeStamp; // Reset initial scale\n\n      self.__lastScale = 1; // Reset locking flags\n\n      self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n      self.__enableScrollY = !isSingleTouch && self.options.scrollingY; // Reset tracking flag\n\n      self.__isTracking = true; // Reset deceleration complete flag\n\n      self.__didDecelerationComplete = false; // Dragging starts directly with two fingers, otherwise lazy with an offset\n\n      self.__isDragging = !isSingleTouch; // Some features are  in multi touch scenarios\n\n      self.__isSingleTouch = isSingleTouch; // Clearing data structure\n\n      self.__positions = [];\n    },\n\n    /**\n     * Touch move handler for scrolling support\n     */\n    doTouchMove: function doTouchMove(touches, timeStamp, scale) {\n      // Array-like check is enough here\n      if (touches.length == null) {\n        throw new Error('Invalid touch list: ' + touches);\n      }\n\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n\n      if (typeof timeStamp !== 'number') {\n        throw new Error('Invalid timestamp value: ' + timeStamp);\n      }\n\n      var self = this; // Ignore event when tracking is not enabled (event might be outside of element)\n\n      if (!self.__isTracking) {\n        return;\n      }\n\n      var currentTouchLeft, currentTouchTop; // Compute move based around of center of fingers\n\n      if (touches.length === 2) {\n        currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      } else {\n        currentTouchLeft = touches[0].pageX;\n        currentTouchTop = touches[0].pageY;\n      }\n\n      var positions = self.__positions; // Are we already is dragging mode?\n\n      if (self.__isDragging) {\n        // Compute move distance\n        var moveX = currentTouchLeft - self.__lastTouchLeft;\n        var moveY = currentTouchTop - self.__lastTouchTop; // Read previous scroll position and zooming\n\n        var scrollLeft = self.__scrollLeft;\n        var scrollTop = self.__scrollTop;\n        var level = self.__zoomLevel; // Work with scaling\n\n        if (scale != null && self.options.zooming) {\n          var oldLevel = level; // Recompute level based on previous scale and new scale\n\n          level = level / self.__lastScale * scale; // Limit level according to configuration\n\n          level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom); // Only do further compution when change happened\n\n          if (oldLevel !== level) {\n            // Compute relative event position to container\n            var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n            var currentTouchTopRel = currentTouchTop - self.__clientTop; // Recompute left and top coordinates based on new zoom level\n\n            scrollLeft = (currentTouchLeftRel + scrollLeft) * level / oldLevel - currentTouchLeftRel;\n            scrollTop = (currentTouchTopRel + scrollTop) * level / oldLevel - currentTouchTopRel; // Recompute max scroll values\n\n            self.__computeScrollMax(level);\n          }\n        }\n\n        var bouncing = self.options.bouncing;\n\n        if (self.__enableScrollX) {\n          scrollLeft -= moveX * this.options.speedMultiplier;\n          var maxScrollLeft = self.__maxScrollLeft;\n\n          if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n            scrollLeft += moveX / 2 * this.options.speedMultiplier; // fix scrollLeft\n\n            scrollLeft = Math.min(Math.max(-bouncing.left, scrollLeft), maxScrollLeft + bouncing.right);\n          }\n        } // Compute new vertical scroll position\n\n\n        if (self.__enableScrollY) {\n          scrollTop -= moveY * this.options.speedMultiplier;\n          var maxScrollTop = self.__maxScrollTop;\n\n          if (scrollTop > maxScrollTop || scrollTop < 0) {\n            scrollTop += moveY / 2 * this.options.speedMultiplier; // fix scrollTop\n\n            scrollTop = Math.min(Math.max(-bouncing.top, scrollTop), maxScrollTop + bouncing.bottom); // Trigger pull to refresh or push to load\n\n            if (!self.__enableScrollX && (self.__refreshHeight != null || self.__loadHeight != null)) {\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n                self.__refreshActive = true;\n\n                if (self.__refreshActivate) {\n                  self.__refreshActivate();\n                }\n              } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {\n                self.__refreshActive = false;\n\n                if (self.__refreshDeactivate) {\n                  self.__refreshDeactivate();\n                }\n              } // handle for push-load\n              else if (!self.__loadActive && scrollTop >= self.__maxScrollTop + self.__loadHeight && self.__loadHeight > 0) {\n                  self.__loadActive = true;\n\n                  if (self.__loadActivate) {\n                    self.__loadActivate();\n                  }\n                } else if (self.__loadActive && scrollTop < self.__maxScrollTop + self.__loadHeight) {\n                  self.__loadActive = false;\n\n                  if (self.__loadDeactivate) {\n                    self.__loadDeactivate();\n                  }\n                }\n            }\n          }\n        } // Keep list from growing infinitely (holding min 10, max 20 measure points)\n\n\n        if (positions.length > 60) {\n          positions.splice(0, 30);\n        } // Track scroll movement for decleration\n\n\n        positions.push(scrollLeft, scrollTop, timeStamp); // Sync scroll position\n\n        self.__publish(scrollLeft, scrollTop, level); // Otherwise figure out whether we are switching into dragging mode now.\n\n      } else {\n        var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n        var minimumTrackingForDrag = 5;\n        var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n        var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n        self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n        self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n        positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n        self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);\n\n        if (self.__isDragging) {\n          self.__interruptedAnimation = false;\n        }\n      } // Update last touch positions and time stamp for next event\n\n\n      self.__lastTouchLeft = currentTouchLeft;\n      self.__lastTouchTop = currentTouchTop;\n      self.__lastTouchMove = timeStamp;\n      self.__lastScale = scale;\n    },\n\n    /**\n     * Touch end handler for scrolling support\n     */\n    doTouchEnd: function doTouchEnd(timeStamp) {\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n\n      if (typeof timeStamp !== 'number') {\n        throw new Error('Invalid timestamp value: ' + timeStamp);\n      }\n\n      var self = this; // Ignore event when tracking is not enabled (no touchstart event on element)\n      // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n\n      if (!self.__isTracking) {\n        return;\n      } // Not touching anymore (when two finger hit the screen there are two touch end events)\n\n\n      self.__isTracking = false; // Be sure to reset the dragging flag now. Here we also detect whether\n      // the finger has moved fast enough to switch into a deceleration animation.\n\n      if (self.__isDragging) {\n        // Reset dragging flag\n        self.__isDragging = false; // Start deceleration\n        // Verify that the last move detected was in some relevant time frame\n\n        if (self.__isSingleTouch && self.options.animating && timeStamp - self.__lastTouchMove <= 100) {\n          // Then figure out what the scroll position was about 100ms ago\n          var positions = self.__positions;\n          var endPos = positions.length - 1;\n          var startPos = endPos; // Move pointer to position measured 100ms ago\n\n          for (var i = endPos; i > 0 && positions[i] > self.__lastTouchMove - 100; i -= 3) {\n            startPos = i;\n          } // If start and stop position is identical in a 100ms timeframe,\n          // we cannot compute any useful deceleration.\n\n\n          if (startPos !== endPos) {\n            // Compute relative movement between these two points\n            var timeOffset = positions[endPos] - positions[startPos];\n            var movedLeft = self.__scrollLeft - positions[startPos - 2];\n            var movedTop = self.__scrollTop - positions[startPos - 1]; // Based on 50ms compute the movement to apply for each render step\n\n            self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\n            self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60); // How much velocity is required to start the deceleration\n\n            var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1; // Verify that we have enough velocity to start deceleration\n\n            if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {\n              // Deactivate pull-to-refresh when decelerating\n              if (!self.__refreshActive && !self.__loadActive) {\n                self.__startDeceleration(timeStamp);\n              }\n            } else {\n              self.__scrollComplete();\n            }\n          } else {\n            self.__scrollComplete();\n          }\n        } else if (timeStamp - self.__lastTouchMove > 100) {\n          self.__scrollComplete();\n        }\n      } // If this was a slower move it is per default non decelerated, but this\n      // still means that we want snap back to the bounds which is done here.\n      // This is placed outside the condition above to improve edge case stability\n      // e.g. touchend fired without enabled dragging. This should normally do not\n      // have modified the scroll positions or even showed the scrollbars though.\n\n\n      if (!self.__isDecelerating) {\n        if (self.__refreshActive && self.__refreshStart) {\n          // Use publish instead of scrollTo to allow scrolling to out of boundary position\n          // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n          self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);\n\n          if (self.__refreshStart) {\n            self.__refreshStart();\n          }\n        } else if (self.__loadActive && self.__loadStart) {\n          // Use publish instead of scrollTo to allow scrolling to out of boundary position\n          // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n          self.__publish(self.__scrollLeft, self.__maxScrollTop + self.__loadHeight, self.__zoomLevel, true);\n\n          if (self.__loadStart) {\n            self.__loadStart();\n          }\n        } else {\n          if (self.__interruptedAnimation || self.__isDragging) {\n            self.__scrollComplete();\n          }\n\n          self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel); // Directly signalize deactivation (nothing todo on refresh?)\n\n          if (self.__refreshActive) {\n            self.__refreshActive = false;\n\n            if (self.__refreshDeactivate) {\n              self.__refreshDeactivate();\n            }\n          } else if (self.__loadActive) {\n            self.__loadActive = false;\n\n            if (self.__loadDeactivate) {\n              self.__loadDeactivate();\n            }\n          }\n        }\n      } // Fully cleanup list\n\n\n      self.__positions.length = 0;\n    },\n\n    /** Handle for scroll/publish */\n    onScroll: NOOP,\n    stop: function stop() {\n      var self = this;\n      self.__disable = true;\n    },\n    start: function start() {\n      var self = this;\n      self.__disable = true;\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n    PRIVATE API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Applies the scroll position to the content element\n     *\n     * @param left {Number} Left scroll position\n     * @param top {Number} Top scroll position\n     * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n     */\n    __publish: function __publish(left, top, zoom, animate, speed, easing) {\n      var self = this;\n\n      if (self.__disable) {\n        return;\n      }\n\n      if (isNaN(left)) {\n        left = this.__scrollLeft;\n      }\n\n      if (isNaN(top)) {\n        top = this.__scrollTop;\n      } // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n\n\n      var wasAnimating = self.__isAnimating;\n\n      if (wasAnimating) {\n        core.effect.Animate.stop(wasAnimating);\n        self.__isAnimating = false;\n      }\n\n      if (animate && (self.options.animating || speed)) {\n        // Keep scheduled positions for scrollBy/zoomBy functionality\n        self.__scheduledLeft = left;\n        self.__scheduledTop = top;\n        self.__scheduledZoom = zoom;\n        var oldLeft = self.__scrollLeft;\n        var oldTop = self.__scrollTop;\n        var oldZoom = self.__zoomLevel;\n        var diffLeft = left - oldLeft;\n        var diffTop = top - oldTop;\n        var diffZoom = zoom - oldZoom;\n\n        var step = function step(percent, now, render) {\n          if (render) {\n            self.__scrollLeft = oldLeft + diffLeft * percent;\n            self.__scrollTop = oldTop + diffTop * percent;\n            self.__zoomLevel = oldZoom + diffZoom * percent; // Push values out\n\n            if (self.__callback) {\n              self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel);\n\n              self.onScroll();\n            }\n          }\n        };\n\n        var verify = function verify(id) {\n          return self.__isAnimating === id;\n        };\n\n        var completed = function completed(renderedFramesPerSecond, animationId, wasFinished) {\n          if (animationId === self.__isAnimating) {\n            self.__isAnimating = false;\n          }\n\n          if (self.__didDecelerationComplete || wasFinished) {\n            self.__scrollComplete();\n          }\n\n          if (self.options.zooming) {\n            self.__computeScrollMax();\n\n            if (self.__zoomComplete) {\n              self.__zoomComplete();\n\n              self.__zoomComplete = null;\n            }\n          }\n\n          if (self.__refreshBeforeDeactiveStarted) {\n            self.__refreshBeforeDeactiveStarted = false;\n            if (self.__refreshDeactivate) self.__refreshDeactivate();\n          }\n\n          if (self.__loadBeforeDeactiveStarted) {\n            self.__loadBeforeDeactiveStarted = false;\n            if (self.__loadDeactivate) self.__loadDeactivate();\n          }\n        };\n\n        var easingFunction = animatingMethod;\n\n        if (easing) {\n          easingFunction = createEasingFunction(easing, easingPattern);\n        } // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n\n\n        self.__isAnimating = core.effect.Animate.start(step, verify, completed, speed || self.options.animationDuration, wasAnimating ? easingFunction : noAnimatingMethod);\n      } else {\n        self.__scheduledLeft = self.__scrollLeft = left;\n        self.__scheduledTop = self.__scrollTop = top;\n        self.__scheduledZoom = self.__zoomLevel = zoom; // Push values out\n\n        if (self.__callback) {\n          self.__callback(left, top, zoom);\n\n          self.onScroll();\n        } // Fix max scroll ranges\n\n\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n\n            self.__zoomComplete = null;\n          }\n        }\n\n        if (self.__refreshBeforeDeactiveStarted) {\n          self.__refreshBeforeDeactiveStarted = false;\n          if (self.__refreshDeactivate) self.__refreshDeactivate();\n        }\n\n        if (self.__loadBeforeDeactiveStarted) {\n          self.__loadBeforeDeactiveStarted = false;\n          if (self.__loadDeactivate) self.__loadDeactivate();\n        }\n      }\n    },\n\n    /**\n     * Recomputes scroll minimum values based on client dimensions and content dimensions.\n     */\n    __computeScrollMax: function __computeScrollMax(zoomLevel) {\n      var self = this;\n\n      if (zoomLevel == null) {\n        zoomLevel = self.__zoomLevel;\n      }\n\n      self.__maxScrollLeft = Math.max(self.__contentWidth * zoomLevel - self.__clientWidth, 0);\n      self.__maxScrollTop = Math.max(self.__contentHeight * zoomLevel - self.__clientHeight, 0);\n    },\n\n    /** compute current page total page */\n    __computePage: function __computePage() {\n      var self = this;\n      var clientWidth = self.__clientWidth;\n      var clientHeight = self.__clientHeight;\n      var left = self.__scrollLeft;\n      var top = self.__scrollTop;\n      self.__totalXPage = Math.ceil(self.__contentWidth / clientWidth);\n      self.__currentPageX = Math.ceil(left / clientWidth + 1);\n      self.__totalYPage = Math.ceil(self.__contentHeight / clientHeight);\n      self.__currentPageY = Math.ceil(top / clientHeight + 1);\n    },\n\n    /** complete scroll*/\n    __scrollComplete: function __scrollComplete() {\n      var self = this;\n      self.options.scrollingComplete();\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n    ANIMATION (DECELERATION) SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Called when a touch sequence end and the speed of the finger was high enough\n     * to switch into deceleration mode.\n     */\n    __startDeceleration: function __startDeceleration() {\n      var self = this;\n\n      if (self.options.paging) {\n        var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);\n        var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);\n        var clientWidth = self.__clientWidth;\n        var clientHeight = self.__clientHeight; // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n        // Each page should have exactly the size of the client area.\n\n        self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;\n        self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;\n        self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;\n        self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;\n      } else {\n        self.__minDecelerationScrollLeft = 0;\n        self.__minDecelerationScrollTop = 0;\n        self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n        self.__maxDecelerationScrollTop = self.__maxScrollTop;\n      } // Wrap class method\n\n\n      var step = function step(percent, now, render) {\n        self.__stepThroughDeceleration(render);\n      }; // How much velocity is required to keep the deceleration running\n\n\n      var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001; // Detect whether it's still worth to continue animating steps\n      // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n\n      var verify = function verify() {\n        var shouldContinue = Math.abs(self.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n\n        if (!shouldContinue) {\n          self.__didDecelerationComplete = true;\n        }\n\n        return shouldContinue;\n      };\n\n      var completed = function completed() {\n        if (!self.__isDecelerating) {\n          return;\n        }\n\n        self.__isDecelerating = false;\n\n        if (self.__didDecelerationComplete) {\n          self.__scrollComplete();\n        } // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n\n\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n      }; // Start animation and switch on flag\n\n\n      self.__isDecelerating = core.effect.Animate.start(step, verify, completed);\n    },\n\n    /**\n     * Called on every step of the animation\n     *\n     * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\n     */\n    __stepThroughDeceleration: function __stepThroughDeceleration(render) {\n      var self = this;\n      var bouncing = self.options.bouncing;\n      var minLeft = self.__minDecelerationScrollLeft;\n      var maxLeft = self.__maxDecelerationScrollLeft;\n      var minTop = self.__minDecelerationScrollTop;\n      var maxTop = self.__maxDecelerationScrollTop; // Add deceleration to scroll position\n\n      var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n      var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n      var bounceX = scrollLeft < minLeft || scrollLeft > maxLeft;\n      var bounceY = scrollTop < minTop || scrollTop > maxTop; // fix scrollLeft and scrollTop\n\n      var fixedScrollLeft = Math.min(Math.max(minLeft - bouncing.left, scrollLeft), maxLeft + bouncing.right);\n      var fixedScrollTop = Math.min(Math.max(minTop - bouncing.top, scrollTop), maxTop + bouncing.bottom); //\n      // UPDATE SCROLL POSITION\n      //\n\n      if (render) {\n        self.__publish(fixedScrollLeft, fixedScrollTop, self.__zoomLevel);\n      } else {\n        self.__scrollLeft = scrollLeft;\n        self.__scrollTop = scrollTop;\n      } //\n      // SLOW DOWN\n      //\n      // Slow down velocity on every iteration\n\n\n      if (!self.options.paging) {\n        // This is the factor applied to every iteration of the animation\n        // to slow down the process. This should emulate natural behavior where\n        // objects slow down when the initiator of the movement is removed\n        var frictionFactor = 0.95;\n        self.__decelerationVelocityX *= frictionFactor;\n        self.__decelerationVelocityY *= frictionFactor;\n      } //\n      // BOUNCING SUPPORT\n      //\n\n\n      var scrollOutsideX = 0;\n      var scrollOutsideY = 0; // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n\n      var penetrationDeceleration = self.options.penetrationDeceleration;\n      var penetrationAcceleration = self.options.penetrationAcceleration;\n\n      if (bounceX) {\n        // Check limits\n        if (scrollLeft < self.__minDecelerationScrollLeft) {\n          scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n        } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n          scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n        }\n      }\n\n      if (bounceY) {\n        if (scrollTop < self.__minDecelerationScrollTop) {\n          scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n        } else if (scrollTop > self.__maxDecelerationScrollTop) {\n          scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n        }\n      }\n\n      if (scrollOutsideX !== 0) {\n        if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n          self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;\n\n          if (scrollOutsideX < 0 && -scrollOutsideX >= bouncing.right && self.__decelerationVelocityX > 0) {\n            self.__decelerationVelocityX = -bouncing.right / 2;\n          }\n\n          if (scrollOutsideX > 0 && scrollOutsideX >= bouncing.left && self.__decelerationVelocityX < 0) {\n            self.__decelerationVelocityX = bouncing.left / 2;\n          }\n        } else {\n          self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;\n        }\n      }\n\n      if (scrollOutsideY !== 0) {\n        if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n          self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;\n\n          if (scrollOutsideY < 0 && -scrollOutsideY >= bouncing.bottom && self.__decelerationVelocityY > 0) {\n            self.__decelerationVelocityY = -bouncing.bottom;\n          }\n\n          if (scrollOutsideY > 0 && scrollOutsideY >= bouncing.top && self.__decelerationVelocityY < 0) {\n            self.__decelerationVelocityY = bouncing.top / 2;\n          }\n        } else {\n          self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration / 2;\n        }\n      }\n    }\n  }; // Copy over members to prototype\n\n  for (var key in members) {\n    Scroller.prototype[key] = members[key];\n  }\n  /* DOM-based rendering (Uses 3D when available, falls back on margin when transform not available) */\n\n\n  function render(content, global, suffix, type) {\n    if (type == 'position') {\n      return function (left, top) {\n        content.style.left = -left + 'px';\n        content.style.top = -top + 'px';\n      };\n    }\n\n    var vendorPrefix = getPrefix(global);\n    var helperElem = document.createElement('div');\n    var undef;\n    var perspectiveProperty = vendorPrefix + 'Perspective';\n    var transformProperty = 'transform'; //vendorPrefix + 'Transform';\n\n    if (helperElem.style[perspectiveProperty] !== undef) {\n      return function (left, top, zoom) {\n        content.style[transformProperty] = 'translate3d(' + -left + suffix + ',' + -top + suffix + ',0) scale(' + zoom + ')';\n      };\n    } else if (helperElem.style[transformProperty] !== undef) {\n      return function (left, top, zoom) {\n        content.style[transformProperty] = 'translate(' + -left + suffix + ',' + -top + suffix + ') scale(' + zoom + ')';\n      };\n    }\n  }\n\n  function listenContainer(container, scroller, eventCallback, zooming, preventDefault, preventDefaultOnMove) {\n    var destroy = null; // for touch\n\n    function touchstart(e) {\n      // Don't react if initial down happens on a form element\n      if (e.touches[0] && e.touches[0].target && e.touches[0].target.tagName.match(/input|textarea|select/i) || scroller.__disable) {\n        return;\n      }\n\n      eventCallback('mousedown');\n      scroller.doTouchStart(e.touches, e.timeStamp);\n\n      if (preventDefault) {\n        e.preventDefault();\n      }\n\n      e.stopPropagation(); // here , we want to manully prevent default, so we\n      // set passive to false\n      // see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\n\n      document.addEventListener('touchmove', touchmove, {\n        passive: false\n      });\n    }\n\n    function touchmove(e) {\n      if (scroller.__disable) return;\n      eventCallback('mousemove');\n      scroller.doTouchMove(e.touches, e.timeStamp, e.scale);\n\n      if (preventDefaultOnMove) {\n        e.preventDefault();\n      }\n    }\n\n    function touchend(e) {\n      eventCallback('mouseup');\n      scroller.doTouchEnd(e.timeStamp);\n      document.removeEventListener('touchmove', touchmove);\n    }\n\n    function touchcancel(e) {\n      scroller.doTouchEnd(e.timeStamp);\n    } // for mouse\n\n\n    function mousedownEvent(e) {\n      if (e.target.tagName.match(/input|textarea|select/i) || scroller.__disable) {\n        return;\n      }\n\n      e.stopPropagation();\n      eventCallback('mousedown');\n      scroller.doTouchStart([{\n        pageX: e.pageX,\n        pageY: e.pageY\n      }], e.timeStamp);\n\n      if (preventDefault) {\n        e.preventDefault();\n      }\n\n      mousedown = true;\n    }\n\n    function mousemove(e) {\n      if (!mousedown || scroller.__disable) {\n        return;\n      }\n\n      eventCallback('mousemove');\n      scroller.doTouchMove([{\n        pageX: e.pageX,\n        pageY: e.pageY\n      }], e.timeStamp);\n\n      if (preventDefaultOnMove) {\n        e.preventDefault();\n      }\n\n      mousedown = true;\n    }\n\n    function mouseup(e) {\n      if (!mousedown) {\n        return;\n      }\n\n      eventCallback('mouseup');\n      scroller.doTouchEnd(e.timeStamp);\n      mousedown = false;\n    }\n\n    function zoomHandle(e) {\n      scroller.doMouseZoom(e.detail ? e.detail * -120 : e.wheelDelta, e.timeStamp, e.pageX, e.pageY);\n    }\n\n    if ('ontouchstart' in window) {\n      container.addEventListener('touchstart', touchstart, false);\n      document.addEventListener('touchend', touchend, false);\n      document.addEventListener('touchcancel', touchcancel, false);\n\n      destroy = function destroy() {\n        container.removeEventListener('touchstart', touchstart, false);\n        document.removeEventListener('touchend', touchend, false);\n        document.removeEventListener('touchcancel', touchcancel, false);\n      };\n    } else {\n      var mousedown = false;\n      container.addEventListener('mousedown', mousedownEvent, false);\n      document.addEventListener('mousemove', mousemove, false);\n      document.addEventListener('mouseup', mouseup, false);\n\n      if (zooming) {\n        container.addEventListener(navigator.userAgent.indexOf('Firefox') > -1 ? 'DOMMouseScroll' : 'mousewheel', zoomHandle, false);\n      } // container.addEventListener(navigator.userAgent.indexOf(\"Firefox\") > -1 ? \"DOMMouseScroll\" :  \"mousewheel\", function(e) {\n      //     scroller.doMouseZoom(e.detail ? (e.detail * -120) : e.wheelDelta, e.timeStamp, e.pageX, e.pageY);\n      // }, false);\n\n\n      destroy = function destroy() {\n        container.removeEventListener('mousedown', mousedownEvent, false);\n        document.removeEventListener('mousemove', mousemove, false);\n        document.removeEventListener('mouseup', mouseup, false);\n        container.removeEventListener(navigator.userAgent.indexOf('Firefox') > -1 ? 'DOMMouseScroll' : 'mousewheel', zoomHandle, false);\n      };\n    } // handle __publish event\n\n\n    scroller.onScroll = function () {\n      eventCallback('onscroll');\n    };\n\n    return destroy;\n  }\n  /**\n   * These mixes is exclusive for slide mode\n   */\n\n\n  createSlideModeStyle();\n  /**\n   * @description refresh and load callback\n   */\n\n  function createStateCallbacks(type, stageType, vm, tipDom) {\n    var listeners = vm.$listeners;\n\n    var activateCallback = function activateCallback() {\n      vm.vuescroll.state[stageType] = 'active';\n      vm.$emit(type + '-activate', vm, tipDom);\n    };\n\n    var deactivateCallback = function deactivateCallback() {\n      vm.vuescroll.state[stageType] = 'deactive';\n      vm.$emit(type + '-deactivate', vm, tipDom);\n    };\n\n    var beforeDeactiveEnd = function beforeDeactiveEnd() {\n      vm.vuescroll.state[stageType] = 'beforeDeactiveEnd';\n      vm.$emit(type + '-before-deactivate-end', vm, tipDom);\n    };\n\n    var startCallback = function startCallback() {\n      vm.vuescroll.state[stageType] = 'start';\n      setTimeout(function () {\n        vm.scroller.finishRefreshOrLoad();\n      }, 2000); // Default start stage duration\n    }; // let beforeDeactivateCallback = done => {\n    //   vm.vuescroll.state[stageType] = 'beforeDeactive';\n    //   setTimeout(function() {\n    //     done();\n    //   }, 500); // Default before-deactivated stage duration\n    // };\n\n\n    var beforeDeactivateCallback = void 0;\n    /* istanbul ignore if */\n\n    if (listeners[type + '-before-deactivate']) {\n      beforeDeactivateCallback = function beforeDeactivateCallback(done) {\n        vm.vuescroll.state[stageType] = 'beforeDeactive';\n        vm.$emit(type + '-before-deactivate', vm, tipDom, done.bind(vm.scroller));\n      };\n    }\n    /* istanbul ignore if */\n\n\n    if (listeners[type + '-start']) {\n      startCallback = function startCallback() {\n        vm.vuescroll.state[stageType] = 'start';\n        vm.$emit(type + '-start', vm, tipDom, vm.scroller.finishRefreshOrLoad.bind(vm.scroller));\n      };\n    }\n\n    return {\n      activateCallback: activateCallback,\n      deactivateCallback: deactivateCallback,\n      startCallback: startCallback,\n      beforeDeactivateCallback: beforeDeactivateCallback,\n      beforeDeactiveEnd: beforeDeactiveEnd\n    };\n  }\n\n  var slideMix = {\n    mounted: function mounted() {\n      this.vsMounted = true;\n    },\n    computed: {\n      pullRefreshTip: function pullRefreshTip() {\n        return this.mergedOptions.vuescroll.pullRefresh.tips[this.vuescroll.state.refreshStage];\n      },\n      pushLoadTip: function pushLoadTip() {\n        return this.mergedOptions.vuescroll.pushLoad.tips[this.vuescroll.state.loadStage];\n      },\n      refreshLoad: function refreshLoad() {\n        return this.mergedOptions.vuescroll.pullRefresh.enable || this.mergedOptions.vuescroll.pushLoad.enable;\n      },\n      refrehDomVisiable: function refrehDomVisiable() {\n        return this.vsMounted && this.outTheTopBoundary;\n      },\n      loadDomVisiable: function loadDomVisiable() {\n        return this.vsMounted && this.outTheBottomBoundary;\n      }\n    },\n    data: function data() {\n      return {\n        vuescroll: {\n          state: {\n            /** Default tips of refresh and load */\n            refreshStage: 'deactive',\n            loadStage: 'deactive'\n          }\n        },\n        vsMounted: false,\n        outTheTopBoundary: false,\n        outTheBottomBoundary: false\n      };\n    },\n    methods: {\n      // Update:\n      // 1. update height/width\n      // 2. update refresh or load\n      updateScroller: function updateScroller() {\n        this.updateDimesion();\n        this.registryRefreshLoad();\n      },\n      updateDimesion: function updateDimesion() {\n        var clientWidth = this.$el.clientWidth;\n        var clientHeight = this.$el.clientHeight;\n        var contentWidth = this.scrollPanelElm.scrollWidth;\n        var contentHeight = this.scrollPanelElm.scrollHeight;\n        var refreshHeight = 0;\n        var loadHeight = 0; // If the refresh option is true,let's  give a \"margin-top\" style to\n        // the refresh-tip dom. let it to be invisible when doesn't trigger\n        // refresh.\n\n        if (this.mergedOptions.vuescroll.pullRefresh.enable) {\n          if (this.vsMounted) {\n            var refreshDom = this.$refs[__REFRESH_DOM_NAME].elm || this.$refs[__REFRESH_DOM_NAME];\n            refreshHeight = refreshDom.offsetHeight;\n            refreshDom.style.marginTop = -refreshHeight + 'px';\n          }\n        }\n\n        if (this.mergedOptions.vuescroll.pushLoad.enable) {\n          if (this.vsMounted) {\n            var loadDom = this.$refs[__LOAD_DOM_NAME].elm || this.$refs[__LOAD_DOM_NAME];\n            loadHeight = loadDom.offsetHeight;\n            contentHeight -= loadHeight;\n            loadDom.style.bottom = '-' + loadHeight + 'px';\n          }\n        }\n\n        if (this.scroller) {\n          this.scroller.setDimensions(clientWidth, clientHeight, contentWidth, contentHeight, false);\n        }\n      },\n      registryRefreshLoad: function registryRefreshLoad() {\n        // registry refresh\n        if (this.mergedOptions.vuescroll.pullRefresh.enable) {\n          this.registryEvent('refresh');\n        } // registry load\n\n\n        if (this.mergedOptions.vuescroll.pushLoad.enable) {\n          this.registryEvent('load');\n        }\n      },\n      registryScroller: function registryScroller() {\n        var _this = this;\n\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$left = _ref.left,\n            left = _ref$left === undefined ? 0 : _ref$left,\n            _ref$top = _ref.top,\n            top = _ref$top === undefined ? 0 : _ref$top,\n            _ref$zoom = _ref.zoom,\n            zoom = _ref$zoom === undefined ? 1 : _ref$zoom;\n\n        var _mergedOptions$vuescr = this.mergedOptions.vuescroll.scroller,\n            preventDefault = _mergedOptions$vuescr.preventDefault,\n            preventDefaultOnMove = _mergedOptions$vuescr.preventDefaultOnMove;\n        var _mergedOptions$vuescr2 = this.mergedOptions.vuescroll,\n            paging = _mergedOptions$vuescr2.paging,\n            snapping = _mergedOptions$vuescr2.snapping.enable,\n            renderMethod = _mergedOptions$vuescr2.renderMethod,\n            zooming = _mergedOptions$vuescr2.zooming; // disale zooming when refresh or load enabled\n\n        zooming = !this.refreshLoad && !paging && !snapping && zooming;\n        var _mergedOptions$scroll = this.mergedOptions.scrollPanel,\n            scrollingY = _mergedOptions$scroll.scrollingY,\n            scrollingX = _mergedOptions$scroll.scrollingX;\n        var scrollingComplete = this.scrollingComplete.bind(this); // Initialize Scroller\n\n        this.scroller = new Scroller(render(this.scrollPanelElm, window, 'px', renderMethod), _extends({}, this.mergedOptions.vuescroll.scroller, {\n          zooming: zooming,\n          scrollingY: scrollingY,\n          scrollingX: scrollingX && !this.refreshLoad,\n          animationDuration: this.mergedOptions.scrollPanel.speed,\n          paging: paging,\n          snapping: snapping,\n          scrollingComplete: scrollingComplete\n        }));\n        this.scroller.__disable = this.mergedOptions.vuescroll.scroller.disable;\n        this.scroller.__scrollLeft = left;\n        this.scroller.__scrollTop = top;\n        this.scroller.__zoomLevel = zoom; // Set snap\n\n        if (snapping) {\n          this.scroller.setSnapSize(this.mergedOptions.vuescroll.snapping.width, this.mergedOptions.vuescroll.snapping.height);\n        }\n\n        var rect = this.$el.getBoundingClientRect();\n        this.scroller.setPosition(rect.left + this.$el.clientLeft, rect.top + this.$el.clientTop); // Get destroy callback\n\n        var cb = listenContainer(this.$el, this.scroller, function (eventType) {\n          // Thie is to dispatch the event from the scroller.\n          // to let vuescroll refresh the dom\n          switch (eventType) {\n            case 'mousedown':\n              _this.vuescroll.state.isDragging = true;\n              break;\n\n            case 'onscroll':\n              {\n                /**\n                   * Trigger auto load\n                   */\n                var stage = _this.vuescroll.state['loadStage'];\n                var _mergedOptions$vuescr3 = _this.mergedOptions.vuescroll.pushLoad,\n                    enable = _mergedOptions$vuescr3.enable,\n                    auto = _mergedOptions$vuescr3.auto,\n                    autoLoadDistance = _mergedOptions$vuescr3.autoLoadDistance;\n                var _scroller = _this.scroller,\n                    __scrollTop = _scroller.__scrollTop,\n                    __maxScrollTop = _scroller.__maxScrollTop;\n\n                if (stage != 'start' && enable && auto && !_this.lockAutoLoad && // auto load debounce\n                autoLoadDistance >= __maxScrollTop - __scrollTop && __scrollTop > 0) {\n                  _this.lockAutoLoad = true;\n\n                  _this.triggerRefreshOrLoad('load');\n                }\n\n                if (autoLoadDistance < __maxScrollTop - __scrollTop) {\n                  _this.lockAutoLoad = false;\n                }\n\n                _this.handleScroll(false);\n              }\n              break;\n\n            case 'mouseup':\n              _this.vuescroll.state.isDragging = false;\n              break;\n          }\n        }, zooming, preventDefault, preventDefaultOnMove);\n        this.updateScroller();\n        return cb;\n      },\n      updateSlideModeBarState: function updateSlideModeBarState() {\n        // update slide mode scrollbars' state\n        var heightPercentage = void 0,\n            widthPercentage = void 0;\n        var vuescroll = this.$el;\n        var scroller = this.scroller;\n        var outerLeft = 0;\n        var outerTop = 0;\n        var _$el = this.$el,\n            clientWidth = _$el.clientWidth,\n            clientHeight = _$el.clientHeight;\n        var contentWidth = clientWidth + this.scroller.__maxScrollLeft;\n        var contentHeight = clientHeight + this.scroller.__maxScrollTop; // We should add the the height or width that is\n        // out of horizontal bountry  to the total length\n\n        /* istanbul ignore if */\n\n        if (scroller.__scrollLeft < 0) {\n          outerLeft = -scroller.__scrollLeft;\n        }\n        /* istanbul ignore next */\n        else if (scroller.__scrollLeft > scroller.__maxScrollLeft) {\n            outerLeft = scroller.__scrollLeft - scroller.__maxScrollLeft;\n          } // out of vertical bountry\n\n\n        if (scroller.__scrollTop < 0) {\n          outerTop = -scroller.__scrollTop;\n          this.outTheBottomBoundary = false;\n          this.outTheTopBoundary = true;\n        } else if (scroller.__scrollTop > scroller.__maxScrollTop) {\n          outerTop = scroller.__scrollTop - scroller.__maxScrollTop;\n          this.outTheTopBoundary = false;\n          this.outTheBottomBoundary = true;\n        } else {\n          this.outTheTopBoundary = this.outTheBottomBoundary = false;\n        }\n\n        heightPercentage = clientHeight / (contentHeight + outerTop);\n        widthPercentage = clientWidth / (contentWidth + outerLeft);\n        var scrollTop = Math.min(Math.max(0, scroller.__scrollTop), scroller.__maxScrollTop);\n        var scrollLeft = Math.min(Math.max(0, scroller.__scrollLeft), scroller.__maxScrollLeft);\n        this.bar.vBar.state.posValue = (scrollTop + outerTop) * 100 / vuescroll.clientHeight;\n        this.bar.hBar.state.posValue = (scrollLeft + outerLeft) * 100 / vuescroll.clientWidth;\n        /* istanbul ignore if */\n\n        if (scroller.__scrollLeft < 0) {\n          this.bar.hBar.state.posValue = 0;\n        }\n\n        if (scroller.__scrollTop < 0) {\n          this.bar.vBar.state.posValue = 0;\n        }\n\n        this.bar.vBar.state.size = heightPercentage < 1 ? heightPercentage : 0;\n        this.bar.hBar.state.size = widthPercentage < 1 ? widthPercentage : 0;\n      },\n      registryEvent: function registryEvent(type) {\n        var domName = type == 'refresh' ? __REFRESH_DOM_NAME : __LOAD_DOM_NAME;\n        var activateFunc = type == 'refresh' ? this.scroller.activatePullToRefresh : this.scroller.activatePushToLoad;\n        var stageType = type == 'refresh' ? 'refreshStage' : 'loadStage';\n        var tipDom = this.$refs[domName].elm || this.$refs[domName];\n        var cbs = createStateCallbacks(type, stageType, this, tipDom);\n        var height = tipDom.offsetHeight;\n        activateFunc.bind(this.scroller)(height, cbs);\n      },\n      getSlidePosition: function getSlidePosition() {\n        return {\n          scrollLeft: this.scroller.__scrollLeft,\n          scrollTop: this.scroller.__scrollTop\n        };\n      }\n    }\n  };\n  /**\n   * These mixes is exclusive for native mode\n   */\n\n  var nativeMix = {\n    methods: {\n      updateNativeModeBarState: function updateNativeModeBarState() {\n        var container = this.scrollPanelElm;\n        var isPercent = this.vuescroll.state.currentSizeStrategy == 'percent';\n        var clientWidth = isPercent ? container.clientWidth : this.vuescroll.state.width.slice(0, -2); // xxxpx ==> xxx\n\n        var clientHeight = isPercent ? container.clientHeight : this.vuescroll.state.height.slice(0, -2);\n        var heightPercentage = clientHeight / container.scrollHeight;\n        var widthPercentage = clientWidth / container.scrollWidth;\n        this.bar.vBar.state.posValue = container.scrollTop * 100 / clientHeight;\n        this.bar.hBar.state.posValue = container.scrollLeft * 100 / clientWidth;\n        this.bar.vBar.state.size = heightPercentage < 1 ? heightPercentage : 0;\n        this.bar.hBar.state.size = widthPercentage < 1 ? widthPercentage : 0;\n      },\n      getNativePosition: function getNativePosition() {\n        return {\n          scrollTop: this.scrollPanelElm.scrollTop,\n          scrollLeft: this.scrollPanelElm.scrollLeft\n        };\n      },\n      onMouseWheel: function onMouseWheel(event)\n      /* istanbul ignore next */\n      {\n        var delta = 0;\n        var dir = void 0;\n\n        if (event.wheelDelta) {\n          if (event.deltaY) {\n            dir = 'dy';\n            delta = event.deltaY;\n          } else if (event.deltaYX) {\n            delta = event.deltaX;\n            dir = 'dx';\n          } else {\n            if (event.shiftKey) {\n              dir = 'dx';\n            } else {\n              dir = 'dy';\n            }\n\n            delta = -1 * event.wheelDelta / 2;\n          }\n        } else if (event.detail) {\n          // horizontal scroll\n          if (event.axis == 1) {\n            dir = 'dx';\n          } else if (event.axis == 2) {\n            // vertical scroll\n            dir = 'dy';\n          }\n\n          delta = event.detail * 16;\n        }\n\n        var duration = this.mergedOptions.vuescroll.wheelScrollDuration;\n\n        if (duration && (this.scrollXEnable && dir == 'dx' || this.scrollYEnable && dir == 'dy')) {\n          event.stopPropagation();\n          event.preventDefault();\n          this.scrollBy(defineProperty({}, dir, delta), duration);\n        }\n      }\n    },\n    computed: {\n      scrollContentElm: function scrollContentElm() {\n        return this.$refs['scrollContent']._isVue ? this.$refs['scrollContent'].$el : this.$refs['scrollContent'];\n      }\n    }\n  };\n  var update = [slideMix, nativeMix];\n  var mixins = [api$1].concat(toConsumableArray(update));\n  var core$1 = {\n    mixins: mixins,\n    mounted: function mounted() {\n      if (!this._isDestroyed && !this.renderError) {\n        if (this.mode == 'slide') {\n          this.updatedCbs.push(this.updateScroller);\n        }\n\n        this.$watch('mergedOptions.vuescroll.scroller.disable', {\n          sync: true,\n          handler: function handler(newVal) {\n            if (this.scroller) {\n              this.scroller.__disable = newVal;\n            }\n          }\n        });\n      }\n    },\n    computed: {\n      mode: function mode() {\n        return this.mergedOptions.vuescroll.mode;\n      }\n    },\n    methods: {\n      destroy: function destroy() {\n        if (this.destroyScroller) {\n          this.scroller.stop();\n          this.destroyScroller();\n          this.destroyScroller = null;\n        }\n        /* istanbul ignore next */\n\n\n        if (this.destroyResize) {\n          this.destroyResize();\n        }\n      },\n      handleScroll: function handleScroll(nativeEvent) {\n        this.updateBarStateAndEmitEvent('handle-scroll', nativeEvent);\n      },\n      updateBarStateAndEmitEvent: function updateBarStateAndEmitEvent(eventType) {\n        var nativeEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        if (this.mode == 'native') {\n          this.updateNativeModeBarState();\n        } else if (this.mode == 'slide') {\n          /* istanbul ignore if */\n          if (!this.scroller) {\n            return;\n          }\n\n          this.updateSlideModeBarState();\n        }\n\n        if (eventType) {\n          this.emitEvent(eventType, nativeEvent);\n        }\n\n        if (this.mergedOptions.bar.onlyShowBarOnScroll) {\n          if (eventType == 'handle-scroll' || eventType == 'handle-resize' || eventType == 'refresh-status' || eventType == 'window-resize' || eventType == 'options-change') {\n            this.showAndDefferedHideBar(true\n            /* forceHideBar: true */\n            );\n          }\n        } else {\n          this.showAndDefferedHideBar();\n        }\n      },\n      emitEvent: function emitEvent(eventType) {\n        var nativeEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var _scrollPanelElm = this.scrollPanelElm,\n            scrollHeight = _scrollPanelElm.scrollHeight,\n            scrollWidth = _scrollPanelElm.scrollWidth,\n            clientHeight = _scrollPanelElm.clientHeight,\n            clientWidth = _scrollPanelElm.clientWidth,\n            scrollTop = _scrollPanelElm.scrollTop,\n            scrollLeft = _scrollPanelElm.scrollLeft;\n        var vertical = {\n          type: 'vertical'\n        };\n        var horizontal = {\n          type: 'horizontal'\n        };\n\n        if (this.mode == 'slide') {\n          scrollHeight = this.scroller.__contentHeight;\n          scrollWidth = this.scroller.__contentWidth;\n          scrollTop = this.scroller.__scrollTop;\n          scrollLeft = this.scroller.__scrollLeft;\n          clientHeight = this.$el.clientHeight;\n          clientWidth = this.$el.clientWidth;\n        }\n\n        vertical['process'] = Math.min(scrollTop / (scrollHeight - clientHeight), 1);\n        horizontal['process'] = Math.min(scrollLeft / (scrollWidth - clientWidth), 1);\n        vertical['barSize'] = this.bar.vBar.state.size;\n        horizontal['barSize'] = this.bar.hBar.state.size;\n        vertical['scrollTop'] = scrollTop;\n        horizontal['scrollLeft'] = scrollLeft;\n        this.$emit(eventType, vertical, horizontal, nativeEvent);\n      },\n      initVariables: function initVariables() {\n        this.lastMode = this.mode;\n        this.$el._isVuescroll = true;\n      },\n      refreshMode: function refreshMode() {\n        var initPos = void 0;\n\n        if (this.scroller) {\n          initPos = this.scroller.getValues();\n        }\n\n        if (this.destroyScroller) {\n          this.scroller.stop();\n          this.destroyScroller();\n          this.destroyScroller = null;\n        }\n\n        if (this.mode == 'slide') {\n          this.destroyScroller = this.registryScroller(initPos);\n        } else if (this.mode == 'native') {\n          // remove the legacy transform style attribute\n          this.scrollPanelElm.style.transform = '';\n          this.scrollPanelElm.style.transformOrigin = '';\n        }\n      },\n      refreshInternalStatus: function refreshInternalStatus() {\n        // 1.set vuescroll height or width according to\n        // sizeStrategy\n        this.setVsSize(); // 2. registry resize event\n\n        this.registryResize(); // 3. registry scroller if mode is 'slide'\n        // or remove 'transform origin' is the mode is not `slide`\n\n        this.refreshMode(); // 4. update scrollbar's height/width\n\n        this.updateBarStateAndEmitEvent('refresh-status');\n      },\n      registryResize: function registryResize() {\n        var _this = this;\n\n        var resizeEnable = this.mergedOptions.vuescroll.detectResize;\n        var modeChanged = false;\n\n        if (this.lastMode != this.mode) {\n          modeChanged = true;\n          this.lastMode = this.mode;\n        }\n        /* istanbul ignore next */\n\n\n        if (this.destroyResize && resizeEnable && !modeChanged) {\n          return;\n        }\n\n        if (this.destroyResize) {\n          this.destroyResize();\n        }\n\n        if (!resizeEnable) {\n          return;\n        }\n\n        var contentElm = null;\n\n        if (this.mode == 'slide') {\n          contentElm = this.scrollPanelElm;\n        } else if (this.mode == 'native') {\n          // scrollContent maybe a vue-component or a pure-dom\n          contentElm = this.scrollContentElm;\n        }\n\n        var vm = this;\n\n        var handleWindowResize = function handleWindowResize()\n        /* istanbul ignore next */\n        {\n          vm.updateBarStateAndEmitEvent('window-resize');\n\n          if (vm.mode == 'slide') {\n            vm.updatedCbs.push(vm.updateScroller);\n            vm.$forceUpdate();\n          }\n        };\n\n        var handleDomResize = function handleDomResize() {\n          var currentSize = {};\n\n          if (_this.mode == 'slide') {\n            currentSize['width'] = _this.scroller.__contentWidth;\n            currentSize['height'] = _this.scroller.__contentHeight;\n\n            _this.updateBarStateAndEmitEvent('handle-resize', currentSize); // update scroller should after rendering\n\n\n            _this.updatedCbs.push(_this.updateScroller);\n\n            _this.$forceUpdate();\n          } else if (_this.mode == 'native') {\n            currentSize['width'] = _this.scrollPanelElm.scrollWidth;\n            currentSize['height'] = _this.scrollPanelElm.scrollHeight;\n\n            _this.updateBarStateAndEmitEvent('handle-resize', currentSize);\n          } // Since content sie changes, we should tell parent to set\n          // correct size to fit content's size\n          //  this.setVsSize();\n\n        };\n\n        window.addEventListener('resize', handleWindowResize, false);\n        var destroyDomResize = installResizeDetection(contentElm, handleDomResize);\n\n        var destroyWindowResize = function destroyWindowResize() {\n          window.removeEventListener('resize', handleWindowResize, false);\n        };\n\n        this.destroyResize = function () {\n          destroyWindowResize();\n          destroyDomResize();\n          _this.destroyResize = null;\n        };\n      },\n      getPosition: function getPosition() {\n        if (this.mode == 'slide') {\n          return this.getSlidePosition();\n        } else if (this.mode == 'native') {\n          return this.getNativePosition();\n        }\n      }\n    }\n  };\n  /**\n   * The slide mode config\n   */\n\n  var config = {\n    // vuescroll\n    vuescroll: {\n      // position or transform\n      renderMethod: 'transform',\n      // pullRefresh or pushLoad is only for the slide mode...\n      pullRefresh: {\n        enable: false,\n        tips: {\n          deactive: 'Pull to Refresh',\n          active: 'Release to Refresh',\n          start: 'Refreshing...',\n          beforeDeactive: 'Refresh Successfully!'\n        }\n      },\n      pushLoad: {\n        enable: false,\n        tips: {\n          deactive: 'Push to Load',\n          active: 'Release to Load',\n          start: 'Loading...',\n          beforeDeactive: 'Load Successfully!'\n        },\n        auto: false,\n        autoLoadDistance: 0\n      },\n      paging: false,\n      zooming: true,\n      snapping: {\n        enable: false,\n        width: 100,\n        height: 100\n      },\n\n      /* some scroller options */\n      scroller: {\n        /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n        bouncing: {\n          top: 100,\n          bottom: 100,\n          left: 100,\n          right: 100\n        },\n\n        /** Enable locking to the main axis if user moves only slightly on one of them at start */\n        locking: true,\n\n        /** Minimum zoom level */\n        minZoom: 0.5,\n\n        /** Maximum zoom level */\n        maxZoom: 3,\n\n        /** Multiply or decrease scrolling speed **/\n        speedMultiplier: 1,\n\n        /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n        penetrationDeceleration: 0.03,\n\n        /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n        penetrationAcceleration: 0.08,\n\n        /** Whether call e.preventDefault event when sliding the content or not */\n        preventDefault: false,\n\n        /** Whether call preventDefault when (mouse/touch)move*/\n        preventDefaultOnMove: true,\n        disable: false\n      }\n    }\n  };\n  /**\n   * validate the options\n   * @export\n   * @param {any} ops\n   */\n\n  function configValidator(ops) {\n    var renderError = false;\n    var vuescroll = ops.vuescroll; // validate pushLoad, pullReresh, snapping\n\n    if (vuescroll.paging == vuescroll.snapping.enable && vuescroll.paging && (vuescroll.pullRefresh || vuescroll.pushLoad)) {\n      error('paging, snapping, (pullRefresh with pushLoad) can only one of them to be true.');\n    }\n\n    return renderError;\n  }\n\n  var config$1 = {\n    vuescroll: {\n      wheelScrollDuration: 0\n    }\n  };\n  var config$2 = {\n    // vuescroll\n    vuescroll: {\n      mode: 'native'\n    }\n  };\n  /**\n   * validate the options\n   * @export\n   * @param {any} ops\n   */\n\n  function configValidator$1(ops) {\n    var renderError = false;\n    var vuescroll = ops.vuescroll; // validate modes\n\n    if (!~modes.indexOf(vuescroll.mode)) {\n      error('Unknown mode: ' + vuescroll.mode + ',the vuescroll\\'s option \"mode\" should be one of the ' + modes);\n      renderError = true;\n    }\n\n    return renderError;\n  }\n\n  var configs = [config$2, config, config$1];\n  var configValidators = [configValidator$1, configValidator];\n\n  var component = _install(core$1, createPanel$2, configs, configValidators);\n\n  function install(Vue$$1) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Vue$$1.component(opts.name || component.name, component);\n    Vue$$1.prototype.$vuescrollConfig = opts.ops || {};\n  }\n\n  var Vuescroll = _extends({\n    install: install,\n    version: '4.12.0',\n    refreshAll: refreshAll,\n    scrollTo: scrollTo\n  }, component);\n  /* istanbul ignore if */\n\n\n  if (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(Vuescroll);\n  }\n\n  return Vuescroll;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlc2Nyb2xsL2Rpc3QvdnVlc2Nyb2xsLmpzPzc3YTAiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiVnVlIiwiaGFzT3duUHJvcGVydHkiLCJpc0lFIiwiaXNTZXJ2ZXIiLCJhZ2VudCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwiaW5kZXhPZiIsImlzSW9zIiwidSIsIm1hdGNoIiwiaXNTdXBwb3J0VG91Y2giLCJ3aW5kb3ciLCJwcm90b3R5cGUiLCIkaXNTZXJ2ZXIiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJvYmoiLCJjb25zdHJ1Y3RvciIsImNsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsImNyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInZhbHVlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJjYWxsIiwidG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJhcnIyIiwiZnJvbSIsImRlZXBDb3B5IiwidG8iLCJzaGFsbG93IiwiaXNVbmRlZiIsImZvckVhY2giLCJpdGVtIiwiaW5kZXgiLCJpc1BsYWluT2JqIiwibWVyZ2VPYmplY3QiLCJmb3JjZSIsImRlZmluZVJlYWN0aXZlIiwic291Y2VLZXkiLCJnZXQiLCJnZXQkJDEiLCJzY3JvbGxCYXJXaWR0aCIsImdldEd1dHRlciIsInVuZGVmaW5lZCIsIm91dGVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJ2aXNpYmlsaXR5Iiwid2lkdGgiLCJwb3NpdGlvbiIsInRvcCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIndpZHRoTm9TY3JvbGwiLCJvZmZzZXRXaWR0aCIsIm92ZXJmbG93IiwiaW5uZXIiLCJ3aWR0aFdpdGhTY3JvbGwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJldmVudENlbnRlciIsImRvbSIsImV2ZW50TmFtZSIsImhhbmRlciIsImNhcHR1cmUiLCJ0eXBlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlcnJvciIsIm1zZyIsImNvbnNvbGUiLCJ3YXJuIiwiaXNDaGlsZEluUGFyZW50IiwiY2hpbGQiLCJwYXJlbnQiLCJmbGFnIiwibm9kZVR5cGUiLCJfaXNWdWVzY3JvbGwiLCJnZXRQcmVmaXgiLCJkb2NTdHlsZSIsImRvY3VtZW50RWxlbWVudCIsImVuZ2luZSIsIm9wZXJhIiwidG9TdHJpbmciLCJjcHVDbGFzcyIsInZlbmRvclByZWZpeCIsInRyaWRlbnQiLCJnZWNrbyIsIndlYmtpdCIsInByZXN0byIsImdldENvbXBsaXRhYmxlU3R5bGUiLCJwcm9wZXJ0eSIsImNvbXBhdGlibGVWYWx1ZSIsInRlc3RFbG0iLCJpbnNlcnRDaGlsZHJlbkludG9TbG90IiwiaCIsInBhcmVudFZub2RlIiwiY2hpbGRWTm9kZSIsImRhdGEiLCJzd2FwQ2hpbGRyZW4iLCJjb25jYXQiLCJfZ2V0Vm5vZGVJbmZvIiwiZ2V0Vm5vZGVJbmZvIiwiY2giLCJ0YWciLCJpc0NvbXBvbmVudCIsImF0dHJzIiwiY29tcG9uZW50T3B0aW9ucyIsInByb3BzRGF0YSIsInNsb3QiLCJ2bm9kZSIsImNoaWxkcmVuIiwiZ2V0UmVhbFBhcmVudCIsImN0eCIsIiRwYXJlbnQiLCJfaXNWdWVzY3JvbGxSb290IiwiXyIsImdldE51bWVyaWNWYWx1ZSIsImRpc3RhbmNlIiwic2l6ZSIsIm51bWJlciIsImV4ZWMiLCJjcmVhdGVTdHlsZSIsInN0eWxlSWQiLCJjc3NUZXh0IiwiZ2V0RWxlbWVudEJ5SWQiLCJoZWFkIiwiZG9jIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpZCIsInN0eWxlU2hlZXQiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUhpZGVCYXJTdHlsZSIsImNyZWF0ZVNsaWRlTW9kZVN0eWxlIiwiYXBpIiwibW91bnRlZCIsInZzSW5zdGFuY2VzIiwiX3VpZCIsImJlZm9yZURlc3Ryb3kiLCJtZXRob2RzIiwic2Nyb2xsVG8iLCJfcmVmIiwic3BlZWQiLCJlYXNpbmciLCJ4IiwieSIsIm1lcmdlZE9wdGlvbnMiLCJzY3JvbGxQYW5lbCIsImludGVybmFsU2Nyb2xsVG8iLCJzY3JvbGxCeSIsIl9yZWYyIiwiX3JlZjIkZHgiLCJkeCIsIl9yZWYyJGR5IiwiZHkiLCJfZ2V0UG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsIl9nZXRQb3NpdGlvbiRzY3JvbGxMZSIsInNjcm9sbExlZnQiLCJfZ2V0UG9zaXRpb24kc2Nyb2xsVG8iLCJzY3JvbGxUb3AiLCJzY3JvbGxQYW5lbEVsbSIsInNjcm9sbFdpZHRoIiwiJGVsIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxJbnRvVmlldyIsImVsbSIsImFuaW1hdGUiLCJwYXJlbnRFbG0iLCJxdWVyeVNlbGVjdG9yIiwiXyRlbCRnZXRCb3VuZGluZ0NsaWVuIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibGVmdCIsIl9lbG0kZ2V0Qm91bmRpbmdDbGllbiIsImNoaWxkTGVmdCIsImNoaWxkVG9wIiwiZGlmZlgiLCJkaWZmWSIsInJlZnJlc2giLCJyZWZyZXNoSW50ZXJuYWxTdGF0dXMiLCIkbmV4dFRpY2siLCJyZWZyZXNoQWxsIiwidnMiLCJiYXNlQ29uZmlnIiwidnVlc2Nyb2xsIiwic2l6ZVN0cmF0ZWd5IiwiZGV0ZWN0UmVzaXplIiwiaW5pdGlhbFNjcm9sbFkiLCJpbml0aWFsU2Nyb2xsWCIsInNjcm9sbGluZ1giLCJzY3JvbGxpbmdZIiwidmVydGljYWxOYXRpdmVCYXJQb3MiLCJyYWlsIiwiYmFja2dyb3VuZCIsIm9wYWNpdHkiLCJib3JkZXIiLCJzcGVjaWZ5Qm9yZGVyUmFkaXVzIiwiZ3V0dGVyT2ZFbmRzIiwiZ3V0dGVyT2ZTaWRlIiwia2VlcFNob3ciLCJiYXIiLCJzaG93RGVsYXkiLCJvbmx5U2hvd0Jhck9uU2Nyb2xsIiwiaG92ZXJTdHlsZSIsIm1pblNpemUiLCJkaXNhYmxlIiwic2Nyb2xsQnV0dG9uIiwiZW5hYmxlIiwic3RlcCIsIm1vdXNlZG93blN0ZXAiLCJ2YWxpZGF0ZU9wcyIsIm9wcyIsInJlbmRlckVycm9yIiwiX29wcyRiYXIiLCJ2QmFyIiwiaEJhciIsIl9vcHMkcmFpbCIsInZSYWlsIiwiaFJhaWwiLCJTdHJpbmciLCJfZXh0cmFWYWxpZGF0ZSIsImhhc0Vycm9yIiwiZXh0ZW5kT3B0cyIsImV4dHJhT3B0cyIsImV4dHJhVmFsaWRhdGUiLCJvcHRzIiwibW9kZXMiLCJOT09QIiwic21hbGxDaGFuZ2VBcnJheSIsIl9fUkVGUkVTSF9ET01fTkFNRSIsIl9fTE9BRF9ET01fTkFNRSIsImluc3RhbGxSZXNpemVEZXRlY3Rpb24iLCJlbGVtZW50IiwiY2FsbGJhY2siLCJpbmplY3RPYmplY3QiLCJoYXNSZXNpemVkIiwiT0JKRUNUX1NUWUxFIiwib2JqV3JhcCIsIm9iamVjdCIsInRhYkluZGV4Iiwib25sb2FkIiwiY29udGVudERvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc1Jlc2l6ZUVsbSIsImRlc3Ryb3kiLCJzY3JvbGxNYXAiLCJ2ZXJ0aWNhbCIsIm9wc1NpemUiLCJwb3NOYW1lIiwib3Bwb3NOYW1lIiwic2lkZVBvc05hbWUiLCJwYWdlIiwic2Nyb2xsIiwic2Nyb2xsU2l6ZSIsIm9mZnNldCIsImNsaWVudCIsImF4aXMiLCJzdGFydCIsImVuZCIsImhvcml6b250YWwiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0RnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaXNOYXRpdmUiLCJ0ZXN0Iiwicm9vdCIsIlRBUkdFVF9GUFMiLCJyZXF1ZXN0cyIsInJhZkhhbmRsZSIsImludGVydmFsSGFuZGxlIiwibGFzdEFjdGl2ZSIsIkRhdGUiLCJjYWxsYmFja0hhbmRsZSIsInNldEludGVydmFsIiwidGltZSIsImN1cnJlbnRSZXF1ZXN0cyIsImNsZWFySW50ZXJ2YWwiLCJjb2xvckNhY2hlIiwicmdiUmVnIiwiZXh0cmFjdFJnYkNvbG9yIiwiY3JlYXRlQmFyRXZlbnQiLCJtb3ZlRXZlbnROYW1lIiwiZW5kRXZlbnROYW1lIiwibW91c2Vkb3duIiwiZSIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZXZlbnQiLCJ0b3VjaGVzIiwib25zZWxlY3RzdGFydCIsImF4aXNTdGFydFBvcyIsIiRyZWZzIiwic2V0QmFyRHJhZyIsIm1vdXNlbW92ZSIsIm1vdXNldXAiLCJ0aHVibVBhcmVudCIsInRodW1iIiwiZGVsdGEiLCJiYXJSYXRpbyIsInBlcmNlbnQiLCJoaWRlQmFyIiwiY3JlYXRlU2Nyb2xsQnV0dG9uRXZlbnQiLCJlbnYiLCJfY3R4JG9wcyRzY3JvbGxCdXR0b24iLCJzdGVwV2l0aERpcmVjdGlvbiIsIm1vdXNlZG93blN0ZXBXaXRoRGlyZWN0aW9uIiwicmVmIiwiYmFyVHlwZSIsImlzTW91c2VEb3duIiwiaXNNb3VzZW91dCIsInRpbWVvdXRJZCIsIndoaWNoIiwic2V0Q2xhc3NIb29rIiwiZW5kUHJlc3MiLCJlbnRlciIsImxlYXZlIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInByZXNzaW5nIiwiZ2V0UmdiQUNvbG9yIiwiY29sb3IiLCJkaXYiLCJjb21wdXRlZENvbG9yIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJhY2tncm91bmRDb2xvciIsImNyZWF0ZVRyYWNrRXZlbnQiLCJoYW5kbGVDbGlja1RyYWNrIiwiX2N0eCRiYXIiLCJiYXJPZmZzZXQiLCJjdXJyZW50VGFyZ2V0IiwiY3JlYXRlU2Nyb2xsYmFyQnV0dG9uIiwiYmFyQ29udGV4dCIsIl9zdHlsZSIsImJvcmRlckNvbG9yIiwid3JhcHBlclByb3BzIiwiY2xhc3MiLCJpbm5lclByb3BzIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm90dG9tIiwicmlnaHQiLCJvbiIsIm5hbWUiLCJzdGF0ZSIsIkJvb2xlYW4iLCJvdGhlckJhckhpZGUiLCJjb21wdXRlZCIsImJhclNpemUiLCJNYXRoIiwibWF4IiwicmVuZGVyIiwiX3N0eWxlMiIsIl9zdHlsZTMiLCJfYmFyU3R5bGUiLCJ2bSIsInJhaWxCYWNrZ3JvdW5kQ29sb3IiLCJyYWlsU2l6ZSIsImVuZFBvcyIsImJvcmRlclJhZGl1cyIsImJ1dHRvblNpemUiLCJiYXJXcmFwcGVyIiwic2Nyb2xsRGlzdGFuY2UiLCJwb3NWYWx1ZSIsInBvcyIsImJhclN0eWxlIiwiY3Vyc29yIiwidHJhbnNpdGlvbiIsIm1vdXNlZW50ZXIiLCJzZXRCYXJIb3ZlclN0eWxlcyIsIm1vdXNlbGVhdmUiLCJ0cnlSZXN0b3JlQmFyU3R5bGVzIiwib3JpZ2luQmFyU3R5bGUiLCJpc0JhckRyYWdnaW5nIiwidmFsIiwiJGVtaXQiLCJfdGhpcyIsImtleXMiLCJfdGhpczIiLCJob3ZlckJhclN0eWxlIiwiZ2V0QmFyRGF0YSIsImNoYXJBdCIsInJlZnJlc2hMb2FkIiwia2VlcFNob3dSYWlsIiwiY3JlYXRlQmFyIiwidmVydGljYWxCYXJQcm9wcyIsImhvcml6b250YWxCYXJQcm9wcyIsImNyZWF0ZUNvbXBvbmVudCIsIl9yZW5kZXIiLCJjb21wb25lbnRzIiwibWl4aW5zIiwiY3JlYXRlZCIsIl9nZmMiLCIkdnVlc2Nyb2xsQ29uZmlnIiwiJG9wdGlvbnMiLCIkc2xvdHMiLCJwYWRkaW5nIiwiX192dWVzY3JvbGwiLCJjbGFzc0hvb2tzIiwicG9pbnRlckxlYXZlIiwidXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQiLCJ0b3VjaHN0YXJ0IiwidG91Y2hlbmQiLCJ0b3VjaG1vdmUiLCJfY3VzdG9tQ29udGFpbmVyIiwiaW5pdFZhcmlhYmxlcyIsImluaXRXYXRjaE9wc0NoYW5nZSIsInVwZGF0ZWRDYnMiLCJwdXNoIiwic2Nyb2xsVG9BbmNob3IiLCJ1cGRhdGVkIiwiX3RoaXMzIiwiY2IiLCJkZXN0cm95UGFyZW50RG9tUmVzaXplIiwiX2lzVnVlIiwiaXNEcmFnZ2luZyIsImN1cnJlbnRTaXplU3RyYXRlZ3kiLCJzY3JvbGxDb250ZW50IiwiaGFzVkJhciIsImhhc0hCYXIiLCJ2QmFyVmlzaWJsZSIsImhCYXJWaXNpYmxlIiwidkJhckRyYWdnaW5nIiwiaEJhckRyYWdnaW5nIiwiY2xpa2luZ1ZlcnRpY2FsU3RhcnRCdXR0b24iLCJjbGlraW5nVmVydGljYWxFbmRCdXR0b24iLCJjbGlraW5nSG9yaXpvbnRhbFN0YXJ0QnV0dG9uIiwiY2xpa2luZ0hvcml6b250YWxFbmRCdXR0b24iLCJtb3VzZUVudGVyIiwic2Nyb2xsaW5nQ29tcGxldGUiLCJzaG93QW5kRGVmZmVyZWRIaWRlQmFyIiwiZm9yY2VIaWRlQmFyIiwiX3RoaXM0Iiwic2hvd0JhciIsInVzZU51bWJlcmljU2l6ZSIsIl90aGlzNSIsInVzZVBlcmNlbnRTaXplIiwiZWwiLCJvZmZzZXRIZWlnaHQiLCJzZXRWc1NpemUiLCJyZWdpc3RyeVBhcmVudFJlc2l6ZSIsIl90aGlzNiIsIndhdGNoT3B0cyIsImRlZXAiLCJzeW5jIiwiJHdhdGNoIiwiaXNTbWFsbENoYW5nZVRoaXNUaWNrIiwidmFsaWRhdGVIYXNoU2VsZWN0b3IiLCJoYXNoIiwibG9jYXRpb24iLCJzbGljZSIsImxhc3RJbmRleE9mIiwicmVzaXplRW5hYmxlIiwicmVxdWlyZWQiLCJ1cGRhdGVJbml0aWFsU2Nyb2xsIiwiX2lzRGVzdHJveWVkIiwiYm94U2l6aW5nIiwiX2N1c3RvbVBhbmVsIiwiZGVmYXVsdCIsIl9pbnN0YWxsIiwiY29yZSIsIl9jb21wb25lbnRzIiwiZXh0cmFDb25maWdzIiwiZXh0cmFWYWxpZGF0b3JzIiwiY29tcCIsImdldEN1cnJlbnRWaWV3cG9ydERvbSIsImNvbnRhaW5lciIsImRvbUZyYWdtZW50IiwiaXNDdXJyZW50dmlldyIsIl9kb20kZ2V0Qm91bmRpbmdDbGllbiIsIl9jb250YWluZXIkZ2V0Qm91bmRpbiIsInBhcmVudExlZnQiLCJwYXJlbnRUb3AiLCJwYXJlbnRIZWlnaHQiLCJwYXJlbnRXaWR0aCIsImNyZWF0ZUVhc2luZ0Z1bmN0aW9uIiwiZWFzaW5nUGF0dGVybiIsInBhdHRlcm4iLCJub29wIiwibm93IiwiZ2V0VGltZSIsIlNjcm9sbENvbnRyb2wiLCJpbml0IiwiaXNSdW5uaW5nIiwic3RhcnRTY3JvbGwiLCJzdCIsImVkIiwic3BkIiwic3RlcENiIiwiY29tcGxldGVDYiIsInZlcnRpZnlDYiIsImVhc2luZ01ldGhvZCIsImRmIiwiZGlyIiwibnQiLCJ0cyIsImV4ZWNTY3JvbGwiLCJsb29wIiwiX2VsbSIsInNjcm9sbFgiLCJzY3JvbGxZIiwic2Nyb2xsaW5nRWxlbWVudCIsIl9lbG0yIiwibmF0aXZlQXBpIiwibmF0aXZlU2Nyb2xsVG8iLCJiaW5kIiwiZ2V0Q3VycmVudHZpZXdEb21OYXRpdmUiLCJzY3JvbGxDb250ZW50RWxtIiwiZ2V0UGFuZWxEYXRhIiwiY29udGV4dCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIm5hdGl2ZU9uIiwiaGFuZGxlU2Nyb2xsIiwic2Nyb2xsWUVuYWJsZSIsInNjcm9sbFhFbmFibGUiLCJET01Nb3VzZVNjcm9sbCIsIm1vdXNld2hlZWwiLCJvbk1vdXNlV2hlZWwiLCJfY29udGV4dCRtZXJnZWRPcHRpb24iLCJndXR0ZXIiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkxlZnQiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJ0cmFuc2Zvcm0iLCJjcmVhdGVQYW5lbCIsImdldFBhbmVsQ2hpbGRyZW4iLCJ2aWV3U3R5bGUiLCJfY3VzdG9tQ29udGVudCIsInBhZGRpbmdSaWdodCIsImdldFBhbmVsRGF0YSQxIiwicmVuZGVyTWV0aG9kIiwiZ2V0UGFuZWxDaGlsZHJlbiQxIiwicmVuZGVyQ2hpbGRyZW4iLCJmaW5hbENoaWxkcmVuIiwicHVsbFJlZnJlc2giLCJyZWZyZWhEb21WaXNpYWJsZSIsImNyZWF0ZVRpcERvbSIsInB1bGxSZWZyZXNoVGlwIiwicHVzaExvYWQiLCJsb2FkRG9tVmlzaWFibGUiLCJwdXNoTG9hZFRpcCIsInRpcCIsInN0YWdlIiwiY2xhc3NOYW1lIiwidmVyc2lvbiIsInhtbG5zIiwieG1sbnNYbGluayIsInZpZXdCb3giLCJ4bWxTcGFjZSIsImQiLCJzdHJva2UiLCJjeCIsImN5IiwiciIsImZpbGwiLCJjcmVhdGVQYW5lbCQxIiwiY3JlYXRlUGFuZWwkMiIsIm1vZGUiLCJzbGlkZUFwaSIsInNsaWRlU2Nyb2xsVG8iLCJzY3JvbGxlciIsIl9fbWF4U2Nyb2xsTGVmdCIsIl9fbWF4U2Nyb2xsVG9wIiwiem9vbUJ5IiwiZmFjdG9yIiwib3JpZ2luTGVmdCIsIm9yaWdpblRvcCIsInpvb21UbyIsImxldmVsIiwiZ2V0Q3VycmVudFBhZ2UiLCJwYWdpbmciLCJnb1RvUGFnZSIsImRlc3QiLCJ0cmlnZ2VyUmVmcmVzaE9yTG9hZCIsImlzUmVmcmVzaCIsImlzTG9hZCIsImdldEN1cnJlbnR2aWV3RG9tU2xpZGUiLCJhcGkkMSIsImRlc3RYIiwiZGVzdFkiLCJnZXRDdXJyZW50dmlld0RvbSIsImRlc2lyZWRGcmFtZXMiLCJtaWxsaXNlY29uZHNQZXJTZWNvbmQiLCJydW5uaW5nIiwiY291bnRlciIsImVmZmVjdCIsImdsb2JhbCQxIiwiQW5pbWF0ZSIsInN0b3AiLCJjbGVhcmVkIiwic3RlcENhbGxiYWNrIiwidmVyaWZ5Q2FsbGJhY2siLCJjb21wbGV0ZWRDYWxsYmFjayIsImR1cmF0aW9uIiwibGFzdEZyYW1lIiwiZHJvcENvdW50ZXIiLCJuZXdSdW5uaW5nIiwidXNlZElkIiwidmlydHVhbCIsImRyb3BwZWRGcmFtZXMiLCJyb3VuZCIsImoiLCJtaW4iLCJhbmltYXRpbmdNZXRob2QiLCJub0FuaW1hdGluZ01ldGhvZCIsIlNjcm9sbGVyIiwib3B0aW9ucyIsIl9fY2FsbGJhY2siLCJhbmltYXRpbmciLCJhbmltYXRpb25EdXJhdGlvbiIsImJvdW5jaW5nIiwibG9ja2luZyIsInNuYXBwaW5nIiwiem9vbWluZyIsIm1pblpvb20iLCJtYXhab29tIiwic3BlZWRNdWx0aXBsaWVyIiwiYW5pbWF0aW5nRWFzaW5nIiwibm9BbmltYXRpbmdFYXNpbmciLCJwZW5ldHJhdGlvbkRlY2VsZXJhdGlvbiIsInBlbmV0cmF0aW9uQWNjZWxlcmF0aW9uIiwibWVtYmVycyIsIl9faXNTaW5nbGVUb3VjaCIsIl9faXNUcmFja2luZyIsIl9fZGlkRGVjZWxlcmF0aW9uQ29tcGxldGUiLCJfX2lzR2VzdHVyaW5nIiwiX19pc0RyYWdnaW5nIiwiX19pc0RlY2VsZXJhdGluZyIsIl9faXNBbmltYXRpbmciLCJfX2NsaWVudExlZnQiLCJfX2NsaWVudFRvcCIsIl9fY2xpZW50V2lkdGgiLCJfX2NsaWVudEhlaWdodCIsIl9fY29udGVudFdpZHRoIiwiX19jb250ZW50SGVpZ2h0IiwiX19zbmFwV2lkdGgiLCJfX3NuYXBIZWlnaHQiLCJfX3JlZnJlc2hIZWlnaHQiLCJfX2xvYWRIZWlnaHQiLCJfX3JlZnJlc2hBY3RpdmUiLCJfX3JlZnJlc2hBY3RpdmF0ZSIsIl9fcmVmcmVzaEJlZm9yZURlYWN0aXZhdGUiLCJfX3JlZnJlc2hEZWFjdGl2YXRlIiwiX19yZWZyZXNoU3RhcnQiLCJfX2xvYWRBY3RpdmUiLCJfX2xvYWRBY3RpdmF0ZSIsIl9fbG9hZEJlZm9yZURlYWN0aXZhdGUiLCJfX2xvYWREZWFjdGl2YXRlIiwiX19sb2FkU3RhcnQiLCJfX3pvb21MZXZlbCIsIl9fc2Nyb2xsTGVmdCIsIl9fc2Nyb2xsVG9wIiwiX19zY2hlZHVsZWRMZWZ0IiwiX19zY2hlZHVsZWRUb3AiLCJfX3NjaGVkdWxlZFpvb20iLCJfX2N1cnJlbnRQYWdlWCIsIl9fY3VycmVudFBhZ2VZIiwiX190b3RhbFhQYWdlIiwiX190b3RhbFlQYWdlIiwiX19kaXNhYmxlIiwiX19sYXN0VG91Y2hMZWZ0IiwiX19sYXN0VG91Y2hUb3AiLCJfX2xhc3RUb3VjaE1vdmUiLCJfX3Bvc2l0aW9ucyIsIl9fbWluRGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCIsIl9fbWluRGVjZWxlcmF0aW9uU2Nyb2xsVG9wIiwiX19tYXhEZWNlbGVyYXRpb25TY3JvbGxMZWZ0IiwiX19tYXhEZWNlbGVyYXRpb25TY3JvbGxUb3AiLCJfX2RlY2VsZXJhdGlvblZlbG9jaXR5WCIsIl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZIiwic2V0RGltZW5zaW9ucyIsImNvbnRlbnRXaWR0aCIsImNvbnRlbnRIZWlnaHQiLCJub1Njcm9sbCIsInNlbGYiLCJfX2NvbXB1dGVTY3JvbGxNYXgiLCJzZXRQb3NpdGlvbiIsInNldFNuYXBTaXplIiwiYWN0aXZhdGVQdWxsVG9SZWZyZXNoIiwiYWN0aXZhdGVDYWxsYmFjayIsImRlYWN0aXZhdGVDYWxsYmFjayIsInN0YXJ0Q2FsbGJhY2siLCJiZWZvcmVEZWFjdGl2YXRlQ2FsbGJhY2siLCJiZWZvcmVEZWFjdGl2ZUVuZCIsIl9fcmVmcmVzaEJlZm9yZURlYWN0aXZlRW5kIiwiYWN0aXZhdGVQdXNoVG9Mb2FkIiwiX19sb2FkQmVmb3JlRGVhY3RpdmVFbmQiLCJ3YXNEZWNlbGVyYXRpbmciLCJfX3JlZnJlc2hCZWZvcmVEZWFjdGl2ZVN0YXJ0ZWQiLCJfX3B1Ymxpc2giLCJfX2xvYWRCZWZvcmVEZWFjdGl2ZVN0YXJ0ZWQiLCJmaW5pc2hSZWZyZXNoT3JMb2FkIiwiZW5kUmVmcmVzaEFjdGl2ZSIsImVuZExvYWRBY3RpdmUiLCJnZXRWYWx1ZXMiLCJ6b29tIiwiZ2V0U2Nyb2xsTWF4IiwiRXJyb3IiLCJfX3pvb21Db21wbGV0ZSIsIm9sZExldmVsIiwic3RhcnRMZWZ0Iiwic3RhcnRUb3AiLCJfX2NvbXB1dGVQYWdlIiwiX3JlZjMiLCJpc05hTiIsImRvTW91c2Vab29tIiwid2hlZWxEZWx0YSIsInRpbWVTdGFtcCIsInBhZ2VYIiwicGFnZVkiLCJjaGFuZ2UiLCJkb1RvdWNoU3RhcnQiLCJ2YWx1ZU9mIiwiX19pbnRlcnJ1cHRlZEFuaW1hdGlvbiIsImN1cnJlbnRUb3VjaExlZnQiLCJjdXJyZW50VG91Y2hUb3AiLCJpc1NpbmdsZVRvdWNoIiwiYWJzIiwiX19pbml0aWFsVG91Y2hMZWZ0IiwiX19pbml0aWFsVG91Y2hUb3AiLCJfX3pvb21MZXZlbFN0YXJ0IiwiX19sYXN0U2NhbGUiLCJfX2VuYWJsZVNjcm9sbFgiLCJfX2VuYWJsZVNjcm9sbFkiLCJkb1RvdWNoTW92ZSIsInNjYWxlIiwicG9zaXRpb25zIiwibW92ZVgiLCJtb3ZlWSIsImN1cnJlbnRUb3VjaExlZnRSZWwiLCJjdXJyZW50VG91Y2hUb3BSZWwiLCJtYXhTY3JvbGxMZWZ0IiwibWF4U2Nyb2xsVG9wIiwic3BsaWNlIiwibWluaW11bVRyYWNraW5nRm9yU2Nyb2xsIiwibWluaW11bVRyYWNraW5nRm9yRHJhZyIsImRpc3RhbmNlWCIsImRpc3RhbmNlWSIsImRvVG91Y2hFbmQiLCJzdGFydFBvcyIsInRpbWVPZmZzZXQiLCJtb3ZlZExlZnQiLCJtb3ZlZFRvcCIsIm1pblZlbG9jaXR5VG9TdGFydERlY2VsZXJhdGlvbiIsIl9fc3RhcnREZWNlbGVyYXRpb24iLCJfX3Njcm9sbENvbXBsZXRlIiwib25TY3JvbGwiLCJ3YXNBbmltYXRpbmciLCJvbGRMZWZ0Iiwib2xkVG9wIiwib2xkWm9vbSIsImRpZmZMZWZ0IiwiZGlmZlRvcCIsImRpZmZab29tIiwidmVyaWZ5IiwiY29tcGxldGVkIiwicmVuZGVyZWRGcmFtZXNQZXJTZWNvbmQiLCJhbmltYXRpb25JZCIsIndhc0ZpbmlzaGVkIiwiZWFzaW5nRnVuY3Rpb24iLCJ6b29tTGV2ZWwiLCJjZWlsIiwiZmxvb3IiLCJfX3N0ZXBUaHJvdWdoRGVjZWxlcmF0aW9uIiwibWluVmVsb2NpdHlUb0tlZXBEZWNlbGVyYXRpbmciLCJzaG91bGRDb250aW51ZSIsIm1pbkxlZnQiLCJtYXhMZWZ0IiwibWluVG9wIiwibWF4VG9wIiwiYm91bmNlWCIsImJvdW5jZVkiLCJmaXhlZFNjcm9sbExlZnQiLCJmaXhlZFNjcm9sbFRvcCIsImZyaWN0aW9uRmFjdG9yIiwic2Nyb2xsT3V0c2lkZVgiLCJzY3JvbGxPdXRzaWRlWSIsImNvbnRlbnQiLCJzdWZmaXgiLCJoZWxwZXJFbGVtIiwidW5kZWYiLCJwZXJzcGVjdGl2ZVByb3BlcnR5IiwidHJhbnNmb3JtUHJvcGVydHkiLCJsaXN0ZW5Db250YWluZXIiLCJldmVudENhbGxiYWNrIiwicHJldmVudERlZmF1bHRPbk1vdmUiLCJ0YWdOYW1lIiwic3RvcFByb3BhZ2F0aW9uIiwicGFzc2l2ZSIsInRvdWNoY2FuY2VsIiwibW91c2Vkb3duRXZlbnQiLCJ6b29tSGFuZGxlIiwiZGV0YWlsIiwiY3JlYXRlU3RhdGVDYWxsYmFja3MiLCJzdGFnZVR5cGUiLCJ0aXBEb20iLCJsaXN0ZW5lcnMiLCIkbGlzdGVuZXJzIiwiZG9uZSIsInNsaWRlTWl4IiwidnNNb3VudGVkIiwidGlwcyIsInJlZnJlc2hTdGFnZSIsImxvYWRTdGFnZSIsIm91dFRoZVRvcEJvdW5kYXJ5Iiwib3V0VGhlQm90dG9tQm91bmRhcnkiLCJ1cGRhdGVTY3JvbGxlciIsInVwZGF0ZURpbWVzaW9uIiwicmVnaXN0cnlSZWZyZXNoTG9hZCIsInJlZnJlc2hIZWlnaHQiLCJsb2FkSGVpZ2h0IiwicmVmcmVzaERvbSIsIm1hcmdpblRvcCIsImxvYWREb20iLCJyZWdpc3RyeUV2ZW50IiwicmVnaXN0cnlTY3JvbGxlciIsIl9yZWYkbGVmdCIsIl9yZWYkdG9wIiwiX3JlZiR6b29tIiwiX21lcmdlZE9wdGlvbnMkdnVlc2NyIiwiX21lcmdlZE9wdGlvbnMkdnVlc2NyMiIsIl9tZXJnZWRPcHRpb25zJHNjcm9sbCIsInJlY3QiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwiZXZlbnRUeXBlIiwiX21lcmdlZE9wdGlvbnMkdnVlc2NyMyIsImF1dG8iLCJhdXRvTG9hZERpc3RhbmNlIiwiX3Njcm9sbGVyIiwibG9ja0F1dG9Mb2FkIiwidXBkYXRlU2xpZGVNb2RlQmFyU3RhdGUiLCJoZWlnaHRQZXJjZW50YWdlIiwid2lkdGhQZXJjZW50YWdlIiwib3V0ZXJMZWZ0Iiwib3V0ZXJUb3AiLCJfJGVsIiwiZG9tTmFtZSIsImFjdGl2YXRlRnVuYyIsImNicyIsImdldFNsaWRlUG9zaXRpb24iLCJuYXRpdmVNaXgiLCJ1cGRhdGVOYXRpdmVNb2RlQmFyU3RhdGUiLCJpc1BlcmNlbnQiLCJnZXROYXRpdmVQb3NpdGlvbiIsImRlbHRhWSIsImRlbHRhWVgiLCJkZWx0YVgiLCJzaGlmdEtleSIsIndoZWVsU2Nyb2xsRHVyYXRpb24iLCJ1cGRhdGUiLCJjb3JlJDEiLCJoYW5kbGVyIiwibmV3VmFsIiwiZGVzdHJveVNjcm9sbGVyIiwiZGVzdHJveVJlc2l6ZSIsIm5hdGl2ZUV2ZW50IiwiZW1pdEV2ZW50IiwiX3Njcm9sbFBhbmVsRWxtIiwibGFzdE1vZGUiLCJyZWZyZXNoTW9kZSIsImluaXRQb3MiLCJyZWdpc3RyeVJlc2l6ZSIsIm1vZGVDaGFuZ2VkIiwiY29udGVudEVsbSIsImhhbmRsZVdpbmRvd1Jlc2l6ZSIsIiRmb3JjZVVwZGF0ZSIsImhhbmRsZURvbVJlc2l6ZSIsImN1cnJlbnRTaXplIiwiZGVzdHJveURvbVJlc2l6ZSIsImRlc3Ryb3lXaW5kb3dSZXNpemUiLCJjb25maWciLCJkZWFjdGl2ZSIsImFjdGl2ZSIsImJlZm9yZURlYWN0aXZlIiwiY29uZmlnVmFsaWRhdG9yIiwiY29uZmlnJDEiLCJjb25maWckMiIsImNvbmZpZ1ZhbGlkYXRvciQxIiwiY29uZmlncyIsImNvbmZpZ1ZhbGlkYXRvcnMiLCJjb21wb25lbnQiLCJpbnN0YWxsIiwiVnVlJCQxIiwiVnVlc2Nyb2xsIiwidXNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQVFDLFdBQVVBLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQzNCLFVBQStEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJGLE9BQU8sQ0FBQ0csbUJBQU8sQ0FBQywrQ0FBRCxDQUFSLENBQXZGLEdBQ0EsU0FEQTtBQUdBLENBSkEsRUFJQyxJQUpELEVBSVEsVUFBVUMsR0FBVixFQUFl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LENBQVQsS0FBaUJ5QixTQUF6QyxHQUFxRHpCLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEVBQS9FO0FBRUFzMkIsVUFBTSxDQUFDRixTQUFQLENBQWlCbHBCLElBQUksQ0FBQ3VILElBQUwsSUFBYTJoQixTQUFTLENBQUMzaEIsSUFBeEMsRUFBOEMyaEIsU0FBOUM7QUFDQUUsVUFBTSxDQUFDbjRCLFNBQVAsQ0FBaUJ3WixnQkFBakIsR0FBb0N6SyxJQUFJLENBQUNkLEdBQUwsSUFBWSxFQUFoRDtBQUNEOztBQUVELE1BQUltcUIsU0FBUyxHQUFHejJCLFFBQVEsQ0FBQztBQUN2QnUyQixXQUFPLEVBQUVBLE9BRGM7QUFFdkJsVixXQUFPLEVBQUUsUUFGYztBQUd2QjdXLGNBQVUsRUFBRUEsVUFIVztBQUl2QjNDLFlBQVEsRUFBRUE7QUFKYSxHQUFELEVBS3JCeXVCLFNBTHFCLENBQXhCO0FBT0E7OztBQUNBLE1BQUksT0FBT2w0QixNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFNLENBQUNiLEdBQTVDLEVBQWlEO0FBQy9DYSxVQUFNLENBQUNiLEdBQVAsQ0FBV201QixHQUFYLENBQWVELFNBQWY7QUFDRDs7QUFFRCxTQUFPQSxTQUFQO0FBRUMsQ0EvMkpBLENBQUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlc2Nyb2xsL2Rpc3QvdnVlc2Nyb2xsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICAqIFZ1ZXNjcm9sbCB2NC4xMi4wXG4gICAgKiAoYykgMjAxOC0yMDE5IFlpKFl2ZXMpIFdhbmdcbiAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICAgICogR2l0aHViOiBodHRwczovL2dpdGh1Yi5jb20vWXZlc0NvZGluZy92dWVzY3JvbGxcbiAgICAqIFdlYnNpdGU6IGh0dHA6Ly92dWVzY3JvbGxqcy55dmVzY29kaW5nLm9yZy9cbiAgICAqL1xuICAgXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgndnVlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsndnVlJ10sIGZhY3RvcnkpIDpcblx0KGdsb2JhbC52dWVzY3JvbGwgPSBmYWN0b3J5KGdsb2JhbC5WdWUpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChWdWUpIHsgJ3VzZSBzdHJpY3QnO1xuXG5WdWUgPSBWdWUgJiYgVnVlLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBWdWVbJ2RlZmF1bHQnXSA6IFZ1ZTtcblxuZnVuY3Rpb24gaXNJRSgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1NlcnZlcigpKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gYWdlbnQuaW5kZXhPZignbXNpZScpICE9PSAtMSB8fCBhZ2VudC5pbmRleE9mKCd0cmlkZW50JykgIT09IC0xIHx8IGFnZW50LmluZGV4T2YoJyBlZGdlLycpICE9PSAtMTtcbn1cblxudmFyIGlzSW9zID0gZnVuY3Rpb24gaXNJb3MoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNTZXJ2ZXIoKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciB1ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuICEhdS5tYXRjaCgvXFwoaVteO10rOyggVTspPyBDUFUuK01hYyBPUyBYLyk7XG59O1xuXG5mdW5jdGlvbiBpc1N1cHBvcnRUb3VjaCgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1NlcnZlcigpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgaXNTZXJ2ZXIgPSBmdW5jdGlvbiBpc1NlcnZlcigpIHtcbiAgcmV0dXJuIFZ1ZS5wcm90b3R5cGUuJGlzU2VydmVyO1xufTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkZWVwQ29weShmcm9tLCB0bywgc2hhbGxvdykge1xuICBpZiAoc2hhbGxvdyAmJiBpc1VuZGVmKHRvKSkge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoZnJvbSkpIHtcbiAgICB0byA9IFtdO1xuICAgIGZyb20uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHRvW2luZGV4XSA9IGRlZXBDb3B5KGl0ZW0sIHRvW2luZGV4XSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZnJvbSkge1xuICAgIGlmICghaXNQbGFpbk9iaihmcm9tKSkge1xuICAgICAgcmV0dXJuIGZyb207XG4gICAgfVxuICAgIHRvID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIHRvW2tleV0gPSBfdHlwZW9mKGZyb21ba2V5XSkgPT09ICdvYmplY3QnID8gZGVlcENvcHkoZnJvbVtrZXldLCB0b1trZXldKSA6IGZyb21ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdChmcm9tLCB0bywgZm9yY2UsIHNoYWxsb3cpIHtcbiAgaWYgKHNoYWxsb3cgJiYgaXNVbmRlZih0bykpIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxuXG4gIHRvID0gdG8gfHwge307XG5cbiAgaWYgKGlzQXJyYXkoZnJvbSkpIHtcbiAgICBpZiAoIWlzQXJyYXkodG8pICYmIGZvcmNlKSB7XG4gICAgICB0byA9IFtdO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSh0bykpIHtcbiAgICAgIGZyb20uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdG9baW5kZXhdID0gbWVyZ2VPYmplY3QoaXRlbSwgdG9baW5kZXhdLCBmb3JjZSwgc2hhbGxvdyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZnJvbSkge1xuICAgIGlmICghaXNQbGFpbk9iaihmcm9tKSkge1xuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIHRvID0gZnJvbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgICAgaWYgKF90eXBlb2YoZnJvbVtrZXldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZih0b1trZXldKSkge1xuICAgICAgICAgICAgdG9ba2V5XSA9IGRlZXBDb3B5KGZyb21ba2V5XSwgdG9ba2V5XSwgc2hhbGxvdyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlT2JqZWN0KGZyb21ba2V5XSwgdG9ba2V5XSwgZm9yY2UsIHNoYWxsb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZih0b1trZXldKSB8fCBmb3JjZSkgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUodGFyZ2V0LCBrZXksIHNvdXJjZSwgc291Y2VLZXkpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghc291cmNlW2tleV0gJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICBzb3VjZUtleSA9IHNvdWNlS2V5IHx8IGtleTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gc291cmNlW3NvdWNlS2V5XTtcbiAgICB9LFxuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG52YXIgc2Nyb2xsQmFyV2lkdGggPSB2b2lkIDA7XG5mdW5jdGlvbiBnZXRHdXR0ZXIoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChpc1NlcnZlcigpKSByZXR1cm4gMDtcbiAgaWYgKHNjcm9sbEJhcldpZHRoICE9PSB1bmRlZmluZWQpIHJldHVybiBzY3JvbGxCYXJXaWR0aDtcbiAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgb3V0ZXIuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xuICBvdXRlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIG91dGVyLnN0eWxlLnRvcCA9ICctOTk5OXB4JztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG5cbiAgdmFyIHdpZHRoTm9TY3JvbGwgPSBvdXRlci5vZmZzZXRXaWR0aDtcbiAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcblxuICB2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICB2YXIgd2lkdGhXaXRoU2Nyb2xsID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuICBzY3JvbGxCYXJXaWR0aCA9IHdpZHRoTm9TY3JvbGwgLSB3aWR0aFdpdGhTY3JvbGw7XG5cbiAgcmV0dXJuIHNjcm9sbEJhcldpZHRoO1xufVxuXG5mdW5jdGlvbiBldmVudENlbnRlcihkb20sIGV2ZW50TmFtZSwgaGFuZGVyKSB7XG4gIHZhciBjYXB0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6ICdvbic7XG5cbiAgdHlwZSA9PSAnb24nID8gZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kZXIsIGNhcHR1cmUpIDogZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kZXIsIGNhcHR1cmUpO1xufVxuXG52YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgY29uc29sZS5lcnJvcignW3Z1ZXNjcm9sbF0gJyArIG1zZyk7XG59O1xudmFyIHdhcm4gPSBmdW5jdGlvbiB3YXJuKG1zZykge1xuICBjb25zb2xlLndhcm4oJ1t2dWVzY3JvbGxdICcgKyBtc2cpO1xufTtcblxuZnVuY3Rpb24gaXNDaGlsZEluUGFyZW50KGNoaWxkLCBwYXJlbnQpIHtcbiAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgaWYgKCFjaGlsZCB8fCAhcGFyZW50KSB7XG4gICAgcmV0dXJuIGZsYWc7XG4gIH1cbiAgd2hpbGUgKGNoaWxkLnBhcmVudE5vZGUgIT09IHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSA5ICYmICFjaGlsZC5wYXJlbnROb2RlLl9pc1Z1ZXNjcm9sbCkge1xuICAgIGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgfVxuICBpZiAoY2hpbGQucGFyZW50Tm9kZSA9PSBwYXJlbnQpIHtcbiAgICBmbGFnID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmxhZztcbn1cblxuZnVuY3Rpb24gZ2V0UHJlZml4KGdsb2JhbCkge1xuICB2YXIgZG9jU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG4gIHZhciBlbmdpbmU7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZ2xvYmFsLm9wZXJhICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcGVyYSkgPT09ICdbb2JqZWN0IE9wZXJhXScpIHtcbiAgICBlbmdpbmUgPSAncHJlc3RvJztcbiAgfSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL2Vsc2UgaWYgKCdNb3pBcHBlYXJhbmNlJyBpbiBkb2NTdHlsZSkge1xuICAgICAgZW5naW5lID0gJ2dlY2tvJztcbiAgICB9IGVsc2UgaWYgKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2NTdHlsZSkge1xuICAgICAgZW5naW5lID0gJ3dlYmtpdCc7XG4gICAgfSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL2Vsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IuY3B1Q2xhc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVuZ2luZSA9ICd0cmlkZW50JztcbiAgICAgIH1cbiAgdmFyIHZlbmRvclByZWZpeCA9IHtcbiAgICB0cmlkZW50OiAnbXMnLFxuICAgIGdlY2tvOiAnbW96JyxcbiAgICB3ZWJraXQ6ICd3ZWJraXQnLFxuICAgIHByZXN0bzogJ08nXG4gIH1bZW5naW5lXTtcbiAgcmV0dXJuIHZlbmRvclByZWZpeDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcGxpdGFibGVTdHlsZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1NlcnZlcigpKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGNvbXBhdGlibGVWYWx1ZSA9ICctJyArIGdldFByZWZpeCh3aW5kb3cpICsgJy0nICsgdmFsdWU7XG4gIHZhciB0ZXN0RWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbG0uc3R5bGVbcHJvcGVydHldID0gY29tcGF0aWJsZVZhbHVlO1xuICBpZiAodGVzdEVsbS5zdHlsZVtwcm9wZXJ0eV0gPT0gY29tcGF0aWJsZVZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXBhdGlibGVWYWx1ZTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSW5zZXJ0IGNoaWxkcmVuIGludG8gdXNlci1wYXNzZWQgc2xvdCBhdCB2bm9kZSBsZXZlbFxuICovXG5mdW5jdGlvbiBpbnNlcnRDaGlsZHJlbkludG9TbG90KGgpIHtcbiAgdmFyIHBhcmVudFZub2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgdmFyIGNoaWxkVk5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciBzd2FwQ2hpbGRyZW4gPSBhcmd1bWVudHNbNF07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHN3YXBDaGlsZHJlbiA/IFtdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShjaGlsZFZOb2RlKSwgdG9Db25zdW1hYmxlQXJyYXkocGFyZW50Vm5vZGUpKSA6IFtdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShwYXJlbnRWbm9kZSksIHRvQ29uc3VtYWJsZUFycmF5KGNoaWxkVk5vZGUpKTtcbiAgfVxuXG4gIHBhcmVudFZub2RlID0gcGFyZW50Vm5vZGVbMF07XG5cbiAgdmFyIF9nZXRWbm9kZUluZm8gPSBnZXRWbm9kZUluZm8ocGFyZW50Vm5vZGUpLFxuICAgICAgY2ggPSBfZ2V0Vm5vZGVJbmZvLmNoLFxuICAgICAgdGFnID0gX2dldFZub2RlSW5mby50YWcsXG4gICAgICBpc0NvbXBvbmVudCA9IF9nZXRWbm9kZUluZm8uaXNDb21wb25lbnQ7XG5cbiAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgcGFyZW50Vm5vZGUuZGF0YSA9IG1lcmdlT2JqZWN0KHsgYXR0cnM6IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhIH0sIHBhcmVudFZub2RlLmRhdGEsIGZhbHNlLCAvLyBmb3JjZTogZmFsc2VcbiAgICB0cnVlIC8vIHNoYWxsb3c6IHRydWVcbiAgICApO1xuICB9XG4gIGNoID0gc3dhcENoaWxkcmVuID8gW10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNoaWxkVk5vZGUpLCB0b0NvbnN1bWFibGVBcnJheShjaCkpIDogW10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNoKSwgdG9Db25zdW1hYmxlQXJyYXkoY2hpbGRWTm9kZSkpO1xuICBkZWxldGUgcGFyZW50Vm5vZGUuZGF0YS5zbG90O1xuXG4gIHJldHVybiBoKHRhZywgbWVyZ2VPYmplY3QoZGF0YSwgcGFyZW50Vm5vZGUuZGF0YSwgZmFsc2UsIHRydWUpLCBjaCk7XG59XG5cbi8qKlxuICogIEdldCB0aGUgaW5mbyBvZiBhIHZub2RlLFxuICogdm5vZGUgbXVzdCBiZSBwYXJlbnRWbm9kZVxuICovXG5mdW5jdGlvbiBnZXRWbm9kZUluZm8odm5vZGUpIHtcbiAgaWYgKCF2bm9kZSB8fCB2bm9kZS5sZW5ndGggPiAxKSByZXR1cm4ge307XG5cbiAgdm5vZGUgPSB2bm9kZVswXSA/IHZub2RlWzBdIDogdm5vZGU7XG4gIHZhciBpc0NvbXBvbmVudCA9ICEhdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIGNoID0gdm9pZCAwO1xuICB2YXIgdGFnID0gdm9pZCAwO1xuXG4gIGlmIChpc0NvbXBvbmVudCkge1xuICAgIGNoID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbiB8fCBbXTtcbiAgICB0YWcgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zLnRhZztcbiAgfSBlbHNlIHtcbiAgICBjaCA9IHZub2RlLmNoaWxkcmVuIHx8IFtdO1xuICAgIHRhZyA9IHZub2RlLnRhZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNDb21wb25lbnQ6IGlzQ29tcG9uZW50LFxuICAgIGNoOiBjaCxcbiAgICB0YWc6IHRhZ1xuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgdnVlc2Nyb2xsIGluc3RhbmNlIGluc3RlYWQgb2ZcbiAqIHVzZXIgcGFzcyBjb21wb25lbnQgbGlrZSBzbG90LlxuICovXG5mdW5jdGlvbiBnZXRSZWFsUGFyZW50KGN0eCkge1xuICB2YXIgcGFyZW50ID0gY3R4LiRwYXJlbnQ7XG4gIGlmICghcGFyZW50Ll9pc1Z1ZXNjcm9sbFJvb3QgJiYgcGFyZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cblxudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KF8pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoXyk7XG59O1xudmFyIGlzUGxhaW5PYmogPSBmdW5jdGlvbiBpc1BsYWluT2JqKF8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChfKSA9PSAnW29iamVjdCBPYmplY3RdJztcbn07XG52YXIgaXNVbmRlZiA9IGZ1bmN0aW9uIGlzVW5kZWYoXykge1xuICByZXR1cm4gdHlwZW9mIF8gPT09ICd1bmRlZmluZWQnO1xufTtcblxuZnVuY3Rpb24gZ2V0TnVtZXJpY1ZhbHVlKGRpc3RhbmNlLCBzaXplKSB7XG4gIHZhciBudW1iZXIgPSB2b2lkIDA7XG4gIGlmICghKG51bWJlciA9IC8oLT9cXGQrKD86XFwuXFxkKz8pPyklJC8uZXhlYyhkaXN0YW5jZSkpKSB7XG4gICAgbnVtYmVyID0gZGlzdGFuY2UgLSAwO1xuICB9IGVsc2Uge1xuICAgIG51bWJlciA9IG51bWJlclsxXSAtIDA7XG4gICAgbnVtYmVyID0gc2l6ZSAqIG51bWJlciAvIDEwMDtcbiAgfVxuICByZXR1cm4gbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZShzdHlsZUlkLCBjc3NUZXh0KSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNTZXJ2ZXIoKSB8fCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHlsZUlkKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5pZCA9IHN0eWxlSWQ7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dCkpO1xuICB9XG5cbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5cbi8vIEhpZGUgdGhlIGlvcyBuYXRpdmUgc2Nyb2xsYmFyLlxuZnVuY3Rpb24gY3JlYXRlSGlkZUJhclN0eWxlKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB7XG4gICAgdmFyIGNzc1RleHQgPSAnLl9faGlkZWJhcjo6LXdlYmtpdC1zY3JvbGxiYXIge1xcbiAgICAgIHdpZHRoOiAwO1xcbiAgICAgIGhlaWdodDogMDtcXG4gICAgfSc7XG5cbiAgICBjcmVhdGVTdHlsZSgndnVlc2Nyb2xsLWhpZGUtaW9zLWJhcicsIGNzc1RleHQpO1xuICB9XG59XG5cbi8vIGNyZWF0ZSBzbGlkZSBtb2RlIHN0eWxlXG5mdW5jdGlvbiBjcmVhdGVTbGlkZU1vZGVTdHlsZSgpIHtcbiAgdmFyIGNzc1RleHQgPSAnXFxuICAgIEAtd2Via2l0LWtleWZyYW1lcyBsb2FkaW5nLXJvdGF0ZSB7XFxuICAgICAgdG8ge1xcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxdHVybik7XFxuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxdHVybik7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEBrZXlmcmFtZXMgbG9hZGluZy1yb3RhdGUge1xcbiAgICAgIHRvIHtcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMXR1cm4pO1xcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMXR1cm4pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBALXdlYmtpdC1rZXlmcmFtZXMgbG9hZGluZy13aXBlIHtcXG4gICAgICAwJSB7XFxuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiAxLCAyMDA7XFxuICAgICAgICBzdHJva2UtZGFzaG9mZnNldDogMDtcXG4gICAgICB9XFxuICAgICAgNTAlIHtcXG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XFxuICAgICAgICBzdHJva2UtZGFzaG9mZnNldDogLTQwcHg7XFxuICAgICAgfVxcbiAgICAgIHRvIHtcXG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XFxuICAgICAgICBzdHJva2UtZGFzaG9mZnNldDogLTEyMHB4O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBAa2V5ZnJhbWVzIGxvYWRpbmctd2lwZSB7XFxuICAgICAgMCUge1xcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogMSwgMjAwO1xcbiAgICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IDA7XFxuICAgICAgfVxcbiAgICAgIDUwJSB7XFxuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA5MCwgMTUwO1xcbiAgICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC00MHB4O1xcbiAgICAgIH1cXG4gICAgICB0byB7XFxuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA5MCwgMTUwO1xcbiAgICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC0xMjBweDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLl9fdnVlc2Nyb2xsIC5fX3JlZnJlc2gsXFxuICAgIC5fX3Z1ZXNjcm9sbCAuX19sb2FkIHtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgY29sb3I6IGJsYWNrO1xcbiAgICAgIGhlaWdodDogNTBweDtcXG4gICAgICBsaW5lLWhlaWdodDogNTBweDtcXG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICB9XFxuICAgIC5fX3Z1ZXNjcm9sbCAuX19yZWZyZXNoIHN2ZyxcXG4gICAgLl9fdnVlc2Nyb2xsIC5fX2xvYWQgc3ZnIHtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxuICAgICAgd2lkdGg6IDI1cHg7XFxuICAgICAgaGVpZ2h0OiAyNXB4O1xcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBzdWI7XFxuICAgIH1cXG4gICAgLl9fdnVlc2Nyb2xsIC5fX3JlZnJlc2ggc3ZnLmFjdGl2ZSxcXG4gICAgLl9fdnVlc2Nyb2xsIC5fX2xvYWQgc3ZnLmFjdGl2ZSB7XFxuICAgICAgdHJhbnNpdGlvbjogYWxsIDAuMnM7XFxuICAgIH1cXG4gICAgLl9fdnVlc2Nyb2xsIC5fX3JlZnJlc2ggc3ZnLmFjdGl2ZS5kZWFjdGl2ZSxcXG4gICAgLl9fdnVlc2Nyb2xsIC5fX2xvYWQgc3ZnLmFjdGl2ZS5kZWFjdGl2ZSB7XFxuICAgICAgdHJhbnNmb3JtOiByb3RhdGVaKDE4MGRlZyk7XFxuICAgIH1cXG4gICAgLl9fdnVlc2Nyb2xsIC5fX3JlZnJlc2ggc3ZnIHBhdGgsXFxuICAgIC5fX3Z1ZXNjcm9sbCAuX19yZWZyZXNoIHN2ZyByZWN0LFxcbiAgICAuX192dWVzY3JvbGwgLl9fbG9hZCBzdmcgcGF0aCxcXG4gICAgLl9fdnVlc2Nyb2xsIC5fX2xvYWQgc3ZnIHJlY3Qge1xcbiAgICAgIGZpbGw6ICMyMGEwZmY7XFxuICAgIH1cXG4gICAgLl9fdnVlc2Nyb2xsIC5fX3JlZnJlc2ggc3ZnLnN0YXJ0LFxcbiAgICAuX192dWVzY3JvbGwgLl9fbG9hZCBzdmcuc3RhcnQge1xcbiAgICAgIHN0cm9rZTogIzM0MzY0MDtcXG4gICAgICBzdHJva2Utd2lkdGg6IDQ7XFxuICAgICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcbiAgICAgIC13ZWJraXQtYW5pbWF0aW9uOiBsb2FkaW5nLXJvdGF0ZSAycyBsaW5lYXIgaW5maW5pdGU7XFxuICAgICAgYW5pbWF0aW9uOiBsb2FkaW5nLXJvdGF0ZSAycyBsaW5lYXIgaW5maW5pdGU7XFxuICAgIH1cXG4gICAgLl9fdnVlc2Nyb2xsIC5fX3JlZnJlc2ggc3ZnLnN0YXJ0IC5iZy1wYXRoLFxcbiAgICAuX192dWVzY3JvbGwgLl9fbG9hZCBzdmcuc3RhcnQgLmJnLXBhdGgge1xcbiAgICAgIHN0cm9rZTogI2YyZjJmMjtcXG4gICAgICBmaWxsOiBub25lO1xcbiAgICB9XFxuICAgIC5fX3Z1ZXNjcm9sbCAuX19yZWZyZXNoIHN2Zy5zdGFydCAuYWN0aXZlLXBhdGgsXFxuICAgIC5fX3Z1ZXNjcm9sbCAuX19sb2FkIHN2Zy5zdGFydCAuYWN0aXZlLXBhdGgge1xcbiAgICAgIHN0cm9rZTogIzIwYTBmZjtcXG4gICAgICBmaWxsOiBub25lO1xcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XFxuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IDA7XFxuICAgICAgLXdlYmtpdC1hbmltYXRpb246IGxvYWRpbmctd2lwZSAxLjVzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xcbiAgICAgIGFuaW1hdGlvbjogbG9hZGluZy13aXBlIDEuNXMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XFxuICAgIH1cXG4gICc7XG5cbiAgY3JlYXRlU3R5bGUoJ3Z1ZXNjcm9sbC1zaWxkZS1tb2RlLXN0eWxlJywgY3NzVGV4dCk7XG59XG5cbnZhciBhcGkgPSB7XG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdnNJbnN0YW5jZXNbdGhpcy5fdWlkXSA9IHRoaXM7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgZGVsZXRlIHZzSW5zdGFuY2VzW3RoaXMuX3VpZF07XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIC8vIHB1YmxpYyBhcGlcbiAgICBzY3JvbGxUbzogZnVuY3Rpb24gc2Nyb2xsVG8oX3JlZiwgc3BlZWQsIGVhc2luZykge1xuICAgICAgdmFyIHggPSBfcmVmLngsXG4gICAgICAgICAgeSA9IF9yZWYueTtcblxuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICBpZiAoc3BlZWQgPT09IHRydWUgfHwgdHlwZW9mIHNwZWVkID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5tZXJnZWRPcHRpb25zLnNjcm9sbFBhbmVsLnNwZWVkO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnRlcm5hbFNjcm9sbFRvKHgsIHksIHNwZWVkLCBlYXNpbmcpO1xuICAgIH0sXG4gICAgc2Nyb2xsQnk6IGZ1bmN0aW9uIHNjcm9sbEJ5KF9yZWYyLCBzcGVlZCwgZWFzaW5nKSB7XG4gICAgICB2YXIgX3JlZjIkZHggPSBfcmVmMi5keCxcbiAgICAgICAgICBkeCA9IF9yZWYyJGR4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjIkZHgsXG4gICAgICAgICAgX3JlZjIkZHkgPSBfcmVmMi5keSxcbiAgICAgICAgICBkeSA9IF9yZWYyJGR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjIkZHk7XG5cbiAgICAgIHZhciBfZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKCksXG4gICAgICAgICAgX2dldFBvc2l0aW9uJHNjcm9sbExlID0gX2dldFBvc2l0aW9uLnNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IF9nZXRQb3NpdGlvbiRzY3JvbGxMZSA9PT0gdW5kZWZpbmVkID8gMCA6IF9nZXRQb3NpdGlvbiRzY3JvbGxMZSxcbiAgICAgICAgICBfZ2V0UG9zaXRpb24kc2Nyb2xsVG8gPSBfZ2V0UG9zaXRpb24uc2Nyb2xsVG9wLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF9nZXRQb3NpdGlvbiRzY3JvbGxUbyA9PT0gdW5kZWZpbmVkID8gMCA6IF9nZXRQb3NpdGlvbiRzY3JvbGxUbztcblxuICAgICAgaWYgKGR4KSB7XG4gICAgICAgIHNjcm9sbExlZnQgKz0gZ2V0TnVtZXJpY1ZhbHVlKGR4LCB0aGlzLnNjcm9sbFBhbmVsRWxtLnNjcm9sbFdpZHRoIC0gdGhpcy4kZWwuY2xpZW50V2lkdGgpO1xuICAgICAgfVxuICAgICAgaWYgKGR5KSB7XG4gICAgICAgIHNjcm9sbFRvcCArPSBnZXROdW1lcmljVmFsdWUoZHksIHRoaXMuc2Nyb2xsUGFuZWxFbG0uc2Nyb2xsSGVpZ2h0IC0gdGhpcy4kZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW50ZXJuYWxTY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIHNwZWVkLCBlYXNpbmcpO1xuICAgIH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsbSkge1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIHZhciBwYXJlbnRFbG0gPSB0aGlzLiRlbDtcblxuICAgICAgaWYgKHR5cGVvZiBlbG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsbSA9IHBhcmVudEVsbS5xdWVyeVNlbGVjdG9yKGVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNDaGlsZEluUGFyZW50KGVsbSwgcGFyZW50RWxtKSkge1xuICAgICAgICB3YXJuKCdUaGUgZWxlbWVudCBvciBzZWxlY3RvciB5b3UgcGFzc2VkIGlzIG5vdCB0aGUgZWxlbWVudCBvZiBWdWVzY3JvbGwsIHBsZWFzZSBwYXNzIHRoZSBlbGVtZW50IHRoYXQgaXMgaW4gVnVlc2Nyb2xsIHRvIHNjcm9sbEludG9WaWV3IEFQSS4gJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyZW50IGVsbSBsZWZ0LCB0b3BcblxuICAgICAgdmFyIF8kZWwkZ2V0Qm91bmRpbmdDbGllbiA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGxlZnQgPSBfJGVsJGdldEJvdW5kaW5nQ2xpZW4ubGVmdCxcbiAgICAgICAgICB0b3AgPSBfJGVsJGdldEJvdW5kaW5nQ2xpZW4udG9wO1xuICAgICAgLy8gY2hpbGQgZWxtIGxlZnQsIHRvcFxuXG5cbiAgICAgIHZhciBfZWxtJGdldEJvdW5kaW5nQ2xpZW4gPSBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgY2hpbGRMZWZ0ID0gX2VsbSRnZXRCb3VuZGluZ0NsaWVuLmxlZnQsXG4gICAgICAgICAgY2hpbGRUb3AgPSBfZWxtJGdldEJvdW5kaW5nQ2xpZW4udG9wO1xuXG4gICAgICB2YXIgZGlmZlggPSBsZWZ0IC0gY2hpbGRMZWZ0O1xuICAgICAgdmFyIGRpZmZZID0gdG9wIC0gY2hpbGRUb3A7XG5cbiAgICAgIHRoaXMuc2Nyb2xsQnkoe1xuICAgICAgICBkeDogLWRpZmZYLFxuICAgICAgICBkeTogLWRpZmZZXG4gICAgICB9LCBhbmltYXRlKTtcbiAgICB9LFxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB0aGlzLnJlZnJlc2hJbnRlcm5hbFN0YXR1cygpO1xuICAgICAgLy8gcmVmcmVzaCBhZ2FpbiB0byBrZWVwIHN0YXR1cyBpcyBjb3JyZWN0XG4gICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnJlZnJlc2hJbnRlcm5hbFN0YXR1cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKiogUHVibGljIEFwaSAqL1xuXG4vKipcbiAqIFJlZnJlc2ggYWxsXG4gKi9cbnZhciB2c0luc3RhbmNlcyA9IHt9O1xuZnVuY3Rpb24gcmVmcmVzaEFsbCgpIHtcbiAgZm9yICh2YXIgdnMgaW4gdnNJbnN0YW5jZXMpIHtcbiAgICB2c0luc3RhbmNlc1t2c10ucmVmcmVzaCgpO1xuICB9XG59XG5cbnZhciBiYXNlQ29uZmlnID0ge1xuICAvLyB2dWVzY3JvbGxcbiAgdnVlc2Nyb2xsOiB7XG4gICAgLy8gdnVlc2Nyb2xsJ3Mgc2l6ZShoZWlnaHQvd2lkdGgpIHNob3VsZCBiZSBhIHBlcmNlbnQoMTAwJSlcbiAgICAvLyBvciBiZSBhIG51bWJlciB0aGF0IGlzIGVxdWFsIHRvIGl0cyBwYXJlbnROb2RlJ3Mgd2lkdGggb3JcbiAgICAvLyBoZWlnaHQgP1xuICAgIHNpemVTdHJhdGVneTogJ3BlcmNlbnQnLFxuICAgIC8qKiBXaGV0aGVyIHRvIGRldGVjdCBkb20gcmVzaXplIG9yIG5vdCAqL1xuICAgIGRldGVjdFJlc2l6ZTogdHJ1ZVxuICB9LFxuICBzY3JvbGxQYW5lbDoge1xuICAgIC8vIHdoZW4gY29tcG9uZW50IG1vdW50ZWQuLiBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc2Nyb2xscy5cbiAgICBpbml0aWFsU2Nyb2xsWTogZmFsc2UsXG4gICAgaW5pdGlhbFNjcm9sbFg6IGZhbHNlLFxuICAgIC8vIGZlYXQ6ICMxMVxuICAgIHNjcm9sbGluZ1g6IHRydWUsXG4gICAgc2Nyb2xsaW5nWTogdHJ1ZSxcbiAgICBzcGVlZDogMzAwLFxuICAgIGVhc2luZzogdW5kZWZpbmVkLFxuICAgIC8vIFNvbWV0aW1lcywgdGhlIG5hdGl2ZWJhciBtYXliZSBvbiB0aGUgbGVmdCxcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1l2ZXNDb2RpbmcvdnVlc2Nyb2xsL2lzc3Vlcy82NFxuICAgIHZlcnRpY2FsTmF0aXZlQmFyUG9zOiAncmlnaHQnXG4gIH0sXG5cbiAgLy9cbiAgcmFpbDoge1xuICAgIGJhY2tncm91bmQ6ICcjMDFhOTlhJyxcbiAgICBvcGFjaXR5OiAwLFxuICAgIGJvcmRlcjogJ25vbmUnLFxuICAgIC8qKiBSYWlsJ3Mgc2l6ZShIZWlnaHQvV2lkdGgpICwgZGVmYXVsdCAtPiA2cHggKi9cbiAgICBzaXplOiAnNnB4JyxcbiAgICAvKiogU3BlY2lmeSByYWlsJ3MgYm9yZGVyLXJhZGl1cywgb3IgdGhlIGJvcmRlci1yYWRpdXMgb2YgcmFpbCBhbmQgYmFyIHdpbGwgYmUgZXF1YWwgdG8gdGhlIHJhaWwncyBzaXplLiBkZWZhdWx0IC0+IGZhbHNlICoqL1xuICAgIHNwZWNpZnlCb3JkZXJSYWRpdXM6IGZhbHNlLFxuICAgIC8qKiBSYWlsIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0d28gZW5kcyBvZiB0aGUgWCBheGlzIGFuZCBZIGF4aXMuICoqL1xuICAgIGd1dHRlck9mRW5kczogbnVsbCxcbiAgICAvKiogUmFpbCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc2lkZSBvZiBjb250YWluZXIuICoqL1xuICAgIGd1dHRlck9mU2lkZTogJzJweCcsXG4gICAgLyoqIFdoZXRoZXIgdG8ga2VlcCByYWlsIHNob3cgb3Igbm90LCBkZWZhdWx0IC0+IGZhbHNlLCBldmVudCBjb250ZW50IGhlaWdodCBpcyBub3QgZW5vdWdoICovXG4gICAga2VlcFNob3c6IGZhbHNlXG4gIH0sXG4gIGJhcjoge1xuICAgIC8qKiBIb3cgbG9uZyB0byBoaWRlIGJhciBhZnRlciBtb3VzZWxlYXZlLCBkZWZhdWx0IC0+IDUwMCAqL1xuICAgIHNob3dEZWxheTogNTAwLFxuICAgIC8qKiBTcGVjaWZ5IGJhcidzIGJvcmRlci1yYWRpdXMsIG9yIHRoZSBib3JkZXItcmFkaXVzIG9mIHJhaWwgYW5kIGJhciB3aWxsIGJlIGVxdWFsIHRvIHRoZSByYWlsJ3Mgc2l6ZS4gZGVmYXVsdCAtPiBmYWxzZSAqKi9cbiAgICBzcGVjaWZ5Qm9yZGVyUmFkaXVzOiBmYWxzZSxcbiAgICAvKiogV2hldGhlciB0byBzaG93IGJhciBvbiBzY3JvbGxpbmcsIGRlZmF1bHQgLT4gdHJ1ZSAqL1xuICAgIG9ubHlTaG93QmFyT25TY3JvbGw6IHRydWUsXG4gICAgLyoqIFdoZXRoZXIgdG8ga2VlcCBzaG93IG9yIG5vdCwgZGVmYXVsdCAtPiBmYWxzZSAqL1xuICAgIGtlZXBTaG93OiBmYWxzZSxcbiAgICAvKiogQmFyJ3MgYmFja2dyb3VuZCAsIGRlZmF1bHQgLT4gIzAwYTY1MCAqL1xuICAgIGJhY2tncm91bmQ6ICdyZ2IoMywgMTg1LCAxMTgpJyxcbiAgICAvKiogQmFyJ3Mgb3BhY2l0eSwgZGVmYXVsdCAtPiAxICAqL1xuICAgIG9wYWNpdHk6IDEsXG4gICAgLyoqIFN0eWxlcyB3aGVuIHlvdSBob3ZlciBzY3JvbGxiYXIsIGl0IHdpbGwgbWVyZ2UgaW50byB0aGUgY3VycmVudCBzdHlsZSAqL1xuICAgIGhvdmVyU3R5bGU6IGZhbHNlLFxuICAgIC8qKiBiYXIncyBzaXplKEhlaWdodC9XaWR0aCkgLCBkZWZhdWx0IC0+IDZweCAqL1xuXG4gICAgc2l6ZTogJzZweCcsXG4gICAgbWluU2l6ZTogMCxcbiAgICBkaXNhYmxlOiBmYWxzZVxuICB9LFxuICBzY3JvbGxCdXR0b246IHtcbiAgICBlbmFibGU6IGZhbHNlLFxuICAgIGJhY2tncm91bmQ6ICdyZ2IoMywgMTg1LCAxMTgpJyxcbiAgICBvcGFjaXR5OiAxLFxuICAgIHN0ZXA6IDE4MCxcbiAgICBtb3VzZWRvd25TdGVwOiAzMFxuICB9XG59O1xuLyoqXG4gKiB2YWxpZGF0ZSB0aGUgb3B0aW9uc1xuICogQGV4cG9ydFxuICogQHBhcmFtIHthbnl9IG9wc1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU9wcyhvcHMpIHtcbiAgdmFyIHJlbmRlckVycm9yID0gZmFsc2U7XG4gIHZhciBzY3JvbGxQYW5lbCA9IG9wcy5zY3JvbGxQYW5lbDtcbiAgdmFyIF9vcHMkYmFyID0gb3BzLmJhcixcbiAgICAgIHZCYXIgPSBfb3BzJGJhci52QmFyLFxuICAgICAgaEJhciA9IF9vcHMkYmFyLmhCYXI7XG4gIHZhciBfb3BzJHJhaWwgPSBvcHMucmFpbCxcbiAgICAgIHZSYWlsID0gX29wcyRyYWlsLnZSYWlsLFxuICAgICAgaFJhaWwgPSBfb3BzJHJhaWwuaFJhaWw7XG5cbiAgLy8gdmFsaWRhdGUgc2Nyb2xsUGFuZWxcblxuICB2YXIgaW5pdGlhbFNjcm9sbFkgPSBzY3JvbGxQYW5lbFsnaW5pdGlhbFNjcm9sbFknXTtcbiAgdmFyIGluaXRpYWxTY3JvbGxYID0gc2Nyb2xsUGFuZWxbJ2luaXRpYWxTY3JvbGxYJ107XG5cbiAgaWYgKGluaXRpYWxTY3JvbGxZICYmICFTdHJpbmcoaW5pdGlhbFNjcm9sbFkpLm1hdGNoKC9eXFxkKyhcXC5cXGQrKT8oJSk/JC8pKSB7XG4gICAgd2FybignVGhlIHByb3AgYGluaXRpYWxTY3JvbGxZYCBvciBgaW5pdGlhbFNjcm9sbFhgIHNob3VsZCBiZSBhIHBlcmNlbnQgbnVtYmVyIGxpa2UgYDEwJWAgb3IgYW4gZXhhY3QgbnVtYmVyIHRoYXQgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgbGlrZSBgMTAwYC4nKTtcbiAgfVxuICBpZiAoaW5pdGlhbFNjcm9sbFggJiYgIVN0cmluZyhpbml0aWFsU2Nyb2xsWCkubWF0Y2goL15cXGQrKFxcLlxcZCspPyglKT8kLykpIHtcbiAgICB3YXJuKCdUaGUgcHJvcCBgaW5pdGlhbFNjcm9sbFlgIG9yIGBpbml0aWFsU2Nyb2xsWGAgc2hvdWxkIGJlIGEgcGVyY2VudCBudW1iZXIgbGlrZSBgMTAlYCBvciBhbiBleGFjdCBudW1iZXIgdGhhdCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBsaWtlIGAxMDBgLicpO1xuICB9XG5cbiAgLy8gdmFsaWRhdGUgZGVwcmVjYXRlZCB2QmFyL2hCYXIgdlJhaWwvaFJhaWxcbiAgaWYgKHZCYXIgfHwgaEJhciB8fCB2UmFpbCB8fCBoUmFpbCkge1xuICAgIHdhcm4oJ1RoZSBvcHRpb25zOiB2UmFpbCwgaFJhaWwsIHZCYXIsIGhCYXIgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjQuNy4wLCcgKyAncGxlYXNlIHVzZSBjb3JyZXNwb25pbmcgcmFpbC9iYXIgaW5zdGVhZCEnKTtcbiAgfVxuXG4gIGlmIChfZXh0cmFWYWxpZGF0ZSkge1xuICAgIF9leHRyYVZhbGlkYXRlID0gW10uY29uY2F0KF9leHRyYVZhbGlkYXRlKTtcbiAgICBfZXh0cmFWYWxpZGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChoYXNFcnJvcikge1xuICAgICAgaWYgKGhhc0Vycm9yKG9wcykpIHtcbiAgICAgICAgcmVuZGVyRXJyb3IgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZW5kZXJFcnJvcjtcbn1cblxudmFyIF9leHRyYVZhbGlkYXRlID0gbnVsbDtcbnZhciBleHRlbmRPcHRzID0gZnVuY3Rpb24gZXh0ZW5kT3B0cyhleHRyYU9wdHMsIGV4dHJhVmFsaWRhdGUpIHtcbiAgZXh0cmFPcHRzID0gW10uY29uY2F0KGV4dHJhT3B0cyk7XG4gIGV4dHJhT3B0cy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgbWVyZ2VPYmplY3Qob3B0cywgYmFzZUNvbmZpZyk7XG4gIH0pO1xuXG4gIF9leHRyYVZhbGlkYXRlID0gZXh0cmFWYWxpZGF0ZTtcbn07XG5cbi8vIGFsbCBtb2Rlc1xudmFyIG1vZGVzID0gWydzbGlkZScsICduYXRpdmUnXTtcbi8vIGRvIG5vdGhpbmdcbnZhciBOT09QID0gZnVuY3Rpb24gTk9PUCgpIHt9O1xuLy8gc29tZSBzbWFsbCBjaGFuZ2VzLlxudmFyIHNtYWxsQ2hhbmdlQXJyYXkgPSBbJ21lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1bGxSZWZyZXNoLnRpcHMnLCAnbWVyZ2VkT3B0aW9ucy52dWVzY3JvbGwucHVzaExvYWQudGlwcycsICdtZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5zY3JvbGxlci5kaXNhYmxlJywgJ21lcmdlZE9wdGlvbnMucmFpbCcsICdtZXJnZWRPcHRpb25zLmJhciddO1xuLy8gcmVmcmVzaC9sb2FkIGRvbSByZWYva2V5Li4uXG52YXIgX19SRUZSRVNIX0RPTV9OQU1FID0gJ3JlZnJlc2hEb20nO1xudmFyIF9fTE9BRF9ET01fTkFNRSA9ICdsb2FkRG9tJztcblxuLy8gZGV0ZWN0IGNvbnRlbnQgc2l6ZSBjaGFuZ2VcbmZ1bmN0aW9uIGluc3RhbGxSZXNpemVEZXRlY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGluamVjdE9iamVjdChlbGVtZW50LCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGluamVjdE9iamVjdChlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoZWxlbWVudC5oYXNSZXNpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIE9CSkVDVF9TVFlMRSA9ICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IGJvcmRlcjogbm9uZTsgcGFkZGluZzogMDsgbWFyZ2luOiAwOyBvcGFjaXR5OiAwOyB6LWluZGV4OiAtMTAwMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7JztcbiAgLy8gZGVmaW5lIGEgd3JhcCBkdWUgdG8gaWUncyB6SW5kZXggYnVnXG4gIHZhciBvYmpXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG9ialdyYXAuc3R5bGUuY3NzVGV4dCA9IE9CSkVDVF9TVFlMRTtcbiAgdmFyIG9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29iamVjdCcpO1xuICBvYmplY3Quc3R5bGUuY3NzVGV4dCA9IE9CSkVDVF9TVFlMRTtcbiAgb2JqZWN0LnR5cGUgPSAndGV4dC9odG1sJztcbiAgb2JqZWN0LnRhYkluZGV4ID0gLTE7XG5cbiAgb2JqZWN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudENlbnRlcihvYmplY3QuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3LCAncmVzaXplJywgY2FsbGJhY2spO1xuICB9O1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yL2Jsb2IvYWFmZTlmN2VhMTFkMWVlYmRhYjcyMmM3YzViODY2MzRlNzM0YjliOC9zcmMvZGV0ZWN0aW9uLXN0cmF0ZWd5L29iamVjdC5qcyNMMTU5XG4gIGlmICghaXNJRSgpKSB7XG4gICAgb2JqZWN0LmRhdGEgPSAnYWJvdXQ6YmxhbmsnO1xuICB9XG4gIG9ialdyYXAuaXNSZXNpemVFbG0gPSB0cnVlO1xuICBvYmpXcmFwLmFwcGVuZENoaWxkKG9iamVjdCk7XG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQob2JqV3JhcCk7XG4gIGlmIChpc0lFKCkpIHtcbiAgICBvYmplY3QuZGF0YSA9ICdhYm91dDpibGFuayc7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKG9iamVjdC5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgIGV2ZW50Q2VudGVyKG9iamVjdC5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXcsICdyZXNpemUnLCBjYWxsYmFjaywgJ29mZicpO1xuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKG9ialdyYXApO1xuICAgIGVsZW1lbnQuaGFzUmVzaXplZCA9IGZhbHNlO1xuICB9O1xufVxuXG52YXIgc2Nyb2xsTWFwID0ge1xuICB2ZXJ0aWNhbDoge1xuICAgIHNpemU6ICdoZWlnaHQnLFxuICAgIG9wc1NpemU6ICd3aWR0aCcsXG4gICAgcG9zTmFtZTogJ3RvcCcsXG4gICAgb3Bwb3NOYW1lOiAnYm90dG9tJyxcbiAgICBzaWRlUG9zTmFtZTogJ3JpZ2h0JyxcbiAgICBwYWdlOiAncGFnZVknLFxuICAgIHNjcm9sbDogJ3Njcm9sbFRvcCcsXG4gICAgc2Nyb2xsU2l6ZTogJ3Njcm9sbEhlaWdodCcsXG4gICAgb2Zmc2V0OiAnb2Zmc2V0SGVpZ2h0JyxcbiAgICBjbGllbnQ6ICdjbGllbnRZJyxcbiAgICBheGlzOiAnWScsXG4gICAgc2Nyb2xsQnV0dG9uOiB7XG4gICAgICBzdGFydDogJ3RvcCcsXG4gICAgICBlbmQ6ICdib3R0b20nXG4gICAgfVxuICB9LFxuICBob3Jpem9udGFsOiB7XG4gICAgc2l6ZTogJ3dpZHRoJyxcbiAgICBvcHNTaXplOiAnaGVpZ2h0JyxcbiAgICBwb3NOYW1lOiAnbGVmdCcsXG4gICAgb3Bwb3NOYW1lOiAncmlnaHQnLFxuICAgIHNpZGVQb3NOYW1lOiAnYm90dG9tJyxcbiAgICBwYWdlOiAncGFnZVgnLFxuICAgIHNjcm9sbDogJ3Njcm9sbExlZnQnLFxuICAgIHNjcm9sbFNpemU6ICdzY3JvbGxXaWR0aCcsXG4gICAgb2Zmc2V0OiAnb2Zmc2V0V2lkdGgnLFxuICAgIGNsaWVudDogJ2NsaWVudFgnLFxuICAgIGF4aXM6ICdYJyxcbiAgICBzY3JvbGxCdXR0b246IHtcbiAgICAgIHN0YXJ0OiAnbGVmdCcsXG4gICAgICBlbmQ6ICdyaWdodCdcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShnbG9iYWwpIHtcbiAgLy8gQ2hlY2sgZm9yIHJlcXVlc3QgYW5pbWF0aW9uIEZyYW1lIHN1cHBvcnRcbiAgdmFyIHJlcXVlc3RGcmFtZSA9IGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2xvYmFsLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnbG9iYWwubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdsb2JhbC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICB2YXIgaXNOYXRpdmUgPSAhIXJlcXVlc3RGcmFtZTtcblxuICBpZiAocmVxdWVzdEZyYW1lICYmICEvcmVxdWVzdEFuaW1hdGlvbkZyYW1lXFwoXFwpXFxzKlxce1xccypcXFtuYXRpdmUgY29kZVxcXVxccypcXH0vaS50ZXN0KHJlcXVlc3RGcmFtZS50b1N0cmluZygpKSkge1xuICAgIGlzTmF0aXZlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNOYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCByb290KSB7XG4gICAgICByZXF1ZXN0RnJhbWUoY2FsbGJhY2ssIHJvb3QpO1xuICAgIH07XG4gIH1cblxuICB2YXIgVEFSR0VUX0ZQUyA9IDYwO1xuICB2YXIgcmVxdWVzdHMgPSB7fTtcbiAgdmFyIHJhZkhhbmRsZSA9IDE7XG4gIHZhciBpbnRlcnZhbEhhbmRsZSA9IG51bGw7XG4gIHZhciBsYXN0QWN0aXZlID0gK25ldyBEYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBjYWxsYmFja0hhbmRsZSA9IHJhZkhhbmRsZSsrO1xuXG4gICAgLy8gU3RvcmUgY2FsbGJhY2tcbiAgICByZXF1ZXN0c1tjYWxsYmFja0hhbmRsZV0gPSBjYWxsYmFjaztcblxuICAgIC8vIENyZWF0ZSB0aW1lb3V0IGF0IGZpcnN0IHJlcXVlc3RcbiAgICBpZiAoaW50ZXJ2YWxIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgIGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgY3VycmVudFJlcXVlc3RzID0gcmVxdWVzdHM7XG5cbiAgICAgICAgLy8gUmVzZXQgZGF0YSBzdHJ1Y3R1cmUgYmVmb3JlIGV4ZWN1dGluZyBjYWxsYmFja3NcbiAgICAgICAgcmVxdWVzdHMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJlcXVlc3RzKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRSZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVxdWVzdHNba2V5XSh0aW1lKTtcbiAgICAgICAgICAgIGxhc3RBY3RpdmUgPSB0aW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc2FibGUgdGhlIHRpbWVvdXQgd2hlbiBub3RoaW5nIGhhcHBlbnMgZm9yIGEgY2VydGFpblxuICAgICAgICAvLyBwZXJpb2Qgb2YgdGltZVxuICAgICAgICBpZiAodGltZSAtIGxhc3RBY3RpdmUgPiAyNTAwKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSk7XG4gICAgICAgICAgaW50ZXJ2YWxIYW5kbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwIC8gVEFSR0VUX0ZQUyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrSGFuZGxlO1xuICB9O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IHt9O1xudmFyIHJnYlJlZyA9IC9yZ2JcXCgvO1xudmFyIGV4dHJhY3RSZ2JDb2xvciA9IC9yZ2JcXCgoLiopXFwpLztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhckV2ZW50KGN0eCkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ21vdXNlJztcblxuICB2YXIgcGFyZW50ID0gZ2V0UmVhbFBhcmVudChjdHgpO1xuICB2YXIgbW92ZUV2ZW50TmFtZSA9IHR5cGUgPT0gJ21vdXNlJyA/ICdtb3VzZW1vdmUnIDogJ3RvdWNobW92ZSc7XG4gIHZhciBlbmRFdmVudE5hbWUgPSB0eXBlID09ICdtb3VzZScgPyAnbW91c2V1cCcgOiAndG91Y2hlbmQnO1xuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgZXZlbnQgPSB0eXBlID09ICdtb3VzZScgPyBlIDogZS50b3VjaGVzWzBdO1xuXG4gICAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGN0eC5heGlzU3RhcnRQb3MgPSBldmVudFtjdHguYmFyLmNsaWVudF0gLSBjdHguJHJlZnNbJ3RodW1iJ10uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbY3R4LmJhci5wb3NOYW1lXTtcblxuICAgIC8vIFRlbGwgcGFyZW50IHRoYXQgdGhlIG1vdXNlIGhhcyBiZWVuIGRvd24uXG4gICAgY3R4LnNldEJhckRyYWcodHJ1ZSk7XG4gICAgZXZlbnRDZW50ZXIoZG9jdW1lbnQsIG1vdmVFdmVudE5hbWUsIG1vdXNlbW92ZSk7XG4gICAgZXZlbnRDZW50ZXIoZG9jdW1lbnQsIGVuZEV2ZW50TmFtZSwgbW91c2V1cCk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZW1vdmUoZSkge1xuICAgIGlmICghY3R4LmF4aXNTdGFydFBvcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aHVibVBhcmVudCA9IGN0eC4kcmVmcy50aHVtYi5wYXJlbnROb2RlO1xuXG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PSAnbW91c2UnID8gZSA6IGUudG91Y2hlc1swXTtcblxuICAgIHZhciBkZWx0YSA9IGV2ZW50W2N0eC5iYXIuY2xpZW50XSAtIHRodWJtUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2N0eC5iYXIucG9zTmFtZV07XG4gICAgZGVsdGEgPSBkZWx0YSAvIGN0eC5iYXJSYXRpbztcblxuICAgIHZhciBwZXJjZW50ID0gKGRlbHRhIC0gY3R4LmF4aXNTdGFydFBvcykgLyB0aHVibVBhcmVudFtjdHguYmFyLm9mZnNldF07XG4gICAgcGFyZW50LnNjcm9sbFRvKGRlZmluZVByb3BlcnR5KHt9LCBjdHguYmFyLmF4aXMudG9Mb3dlckNhc2UoKSwgcGFyZW50LnNjcm9sbFBhbmVsRWxtW2N0eC5iYXIuc2Nyb2xsU2l6ZV0gKiBwZXJjZW50KSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cCgpIHtcbiAgICBjdHguc2V0QmFyRHJhZyhmYWxzZSk7XG4gICAgcGFyZW50LmhpZGVCYXIoKTtcblxuICAgIGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgPSBudWxsO1xuICAgIGN0eC5heGlzU3RhcnRQb3MgPSAwO1xuXG4gICAgZXZlbnRDZW50ZXIoZG9jdW1lbnQsIG1vdmVFdmVudE5hbWUsIG1vdXNlbW92ZSwgZmFsc2UsICdvZmYnKTtcbiAgICBldmVudENlbnRlcihkb2N1bWVudCwgZW5kRXZlbnROYW1lLCBtb3VzZXVwLCBmYWxzZSwgJ29mZicpO1xuICB9XG5cbiAgcmV0dXJuIG1vdXNlZG93bjtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNyZWF0ZVNjcm9sbEJ1dHRvbkV2ZW50KGN0eCwgdHlwZSkge1xuICB2YXIgZW52ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnbW91c2UnO1xuXG4gIHZhciBwYXJlbnQgPSBnZXRSZWFsUGFyZW50KGN0eCk7XG5cbiAgdmFyIGVuZEV2ZW50TmFtZSA9IGVudiA9PSAnbW91c2UnID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kJztcbiAgdmFyIF9jdHgkb3BzJHNjcm9sbEJ1dHRvbiA9IGN0eC5vcHMuc2Nyb2xsQnV0dG9uLFxuICAgICAgc3RlcCA9IF9jdHgkb3BzJHNjcm9sbEJ1dHRvbi5zdGVwLFxuICAgICAgbW91c2Vkb3duU3RlcCA9IF9jdHgkb3BzJHNjcm9sbEJ1dHRvbi5tb3VzZWRvd25TdGVwO1xuXG5cbiAgdmFyIHN0ZXBXaXRoRGlyZWN0aW9uID0gdHlwZSA9PSAnc3RhcnQnID8gLXN0ZXAgOiBzdGVwO1xuICB2YXIgbW91c2Vkb3duU3RlcFdpdGhEaXJlY3Rpb24gPSB0eXBlID09ICdzdGFydCcgPyAtbW91c2Vkb3duU3RlcCA6IG1vdXNlZG93blN0ZXA7XG4gIHZhciByZWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUod2luZG93KTtcblxuICAvLyBiYXIgcHJvcHM6IHR5cGVcbiAgdmFyIGJhclR5cGUgPSBjdHgudHlwZTtcblxuICB2YXIgaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgdmFyIGlzTW91c2VvdXQgPSB0cnVlO1xuICB2YXIgdGltZW91dElkID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgIGlmICgzID09IGUud2hpY2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgY2xhc3MgaG9va1xuICAgIHBhcmVudC5zZXRDbGFzc0hvb2soJ2NsaWtpbmcnICsgYmFyVHlwZSArIHR5cGUgKyAnQnV0dG9uJywgdHJ1ZSk7XG5cbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlzTW91c2VvdXQgPSBmYWxzZTtcblxuICAgIHBhcmVudC5zY3JvbGxCeShkZWZpbmVQcm9wZXJ0eSh7fSwgJ2QnICsgY3R4LmJhci5heGlzLnRvTG93ZXJDYXNlKCksIHN0ZXBXaXRoRGlyZWN0aW9uKSk7XG5cbiAgICBldmVudENlbnRlcihkb2N1bWVudCwgZW5kRXZlbnROYW1lLCBlbmRQcmVzcywgZmFsc2UpO1xuXG4gICAgaWYgKGVudiA9PSAnbW91c2UnKSB7XG4gICAgICB2YXIgZWxtID0gY3R4LiRyZWZzW3R5cGVdO1xuICAgICAgZXZlbnRDZW50ZXIoZWxtLCAnbW91c2VlbnRlcicsIGVudGVyLCBmYWxzZSk7XG4gICAgICBldmVudENlbnRlcihlbG0sICdtb3VzZWxlYXZlJywgbGVhdmUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIHJlZihwcmVzc2luZywgd2luZG93KTtcbiAgICB9LCA1MDApO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlc3NpbmcoKSB7XG4gICAgaWYgKGlzTW91c2VEb3duICYmICFpc01vdXNlb3V0KSB7XG4gICAgICBwYXJlbnQuc2Nyb2xsQnkoZGVmaW5lUHJvcGVydHkoe30sICdkJyArIGN0eC5iYXIuYXhpcy50b0xvd2VyQ2FzZSgpLCBtb3VzZWRvd25TdGVwV2l0aERpcmVjdGlvbiksIGZhbHNlKTtcbiAgICAgIHJlZihwcmVzc2luZywgd2luZG93KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRQcmVzcygpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICBpc01vdXNlRG93biA9IGZhbHNlO1xuICAgIGV2ZW50Q2VudGVyKGRvY3VtZW50LCBlbmRFdmVudE5hbWUsIGVuZFByZXNzLCBmYWxzZSwgJ29mZicpO1xuICAgIGlmIChlbnYgPT0gJ21vdXNlJykge1xuICAgICAgdmFyIGVsbSA9IGN0eC4kcmVmc1t0eXBlXTtcbiAgICAgIGV2ZW50Q2VudGVyKGVsbSwgJ21vdXNlZW50ZXInLCBlbnRlciwgZmFsc2UsICdvZmYnKTtcbiAgICAgIGV2ZW50Q2VudGVyKGVsbSwgJ21vdXNlbGVhdmUnLCBsZWF2ZSwgZmFsc2UsICdvZmYnKTtcbiAgICB9XG5cbiAgICBwYXJlbnQuc2V0Q2xhc3NIb29rKCdjbGlraW5nJyArIGJhclR5cGUgKyB0eXBlICsgJ0J1dHRvbicsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVudGVyKCkge1xuICAgIGlzTW91c2VvdXQgPSBmYWxzZTtcbiAgICBwcmVzc2luZygpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgaXNNb3VzZW91dCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gc3RhcnQ7XG59XG5cbi8vIFRyYW5zZm9ybSBhIGNvbW1vbiBjb2xvciBpbnQgb2EgYHJnYkFgIGNvbG9yXG5mdW5jdGlvbiBnZXRSZ2JBQ29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgdmFyIGlkID0gY29sb3IgKyAnJicgKyBvcGFjaXR5O1xuICBpZiAoY29sb3JDYWNoZVtpZF0pIHtcbiAgICByZXR1cm4gY29sb3JDYWNoZVtpZF07XG4gIH1cblxuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3I7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgdmFyIGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkaXYpLmJhY2tncm91bmRDb2xvcjtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXJnYlJlZy50ZXN0KGNvbXB1dGVkQ29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgcmV0dXJuIGNvbG9yQ2FjaGVbaWRdID0gJ3JnYmEoJyArIGV4dHJhY3RSZ2JDb2xvci5leGVjKGNvbXB1dGVkQ29sb3IpWzFdICsgJywgJyArIG9wYWNpdHkgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrRXZlbnQoY3R4LCB0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVDbGlja1RyYWNrKGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UmVhbFBhcmVudChjdHgpO1xuXG4gICAgdmFyIF9jdHgkYmFyID0gY3R4LmJhcixcbiAgICAgICAgY2xpZW50ID0gX2N0eCRiYXIuY2xpZW50LFxuICAgICAgICBvZmZzZXQgPSBfY3R4JGJhci5vZmZzZXQsXG4gICAgICAgIHBvc05hbWUgPSBfY3R4JGJhci5wb3NOYW1lLFxuICAgICAgICBheGlzID0gX2N0eCRiYXIuYXhpcztcblxuICAgIHZhciB0aHVtYiA9IGN0eC4kcmVmc1sndGh1bWInXTtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aHVtYikgcmV0dXJuO1xuXG4gICAgdmFyIGJhck9mZnNldCA9IHRodW1iW29mZnNldF07XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PSAndG91Y2hzdGFydCcgPyBlLnRvdWNoZXNbMF0gOiBlO1xuXG4gICAgdmFyIHBlcmNlbnQgPSAoZXZlbnRbY2xpZW50XSAtIGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwb3NOYW1lXSAtIGJhck9mZnNldCAvIDIpIC8gKGUuY3VycmVudFRhcmdldFtvZmZzZXRdIC0gYmFyT2Zmc2V0KTtcblxuICAgIHBhcmVudC5zY3JvbGxUbyhkZWZpbmVQcm9wZXJ0eSh7fSwgYXhpcy50b0xvd2VyQ2FzZSgpLCBwZXJjZW50ICogMTAwICsgJyUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjcm9sbGJhckJ1dHRvbihoLCBiYXJDb250ZXh0LCB0eXBlKSB7XG4gIHZhciBfc3R5bGU7XG5cbiAgaWYgKCFiYXJDb250ZXh0Lm9wcy5zY3JvbGxCdXR0b24uZW5hYmxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2l6ZSA9IGJhckNvbnRleHQub3BzLnJhaWwuc2l6ZTtcbiAgdmFyIGJvcmRlckNvbG9yID0gYmFyQ29udGV4dC5vcHMuc2Nyb2xsQnV0dG9uLmJhY2tncm91bmQ7XG5cbiAgdmFyIHdyYXBwZXJQcm9wcyA9IHtcbiAgICBjbGFzczogWydfX2Jhci1idXR0b24nLCAnX19iYXItYnV0dG9uLWlzLScgKyBiYXJDb250ZXh0LnR5cGUgKyAnLScgKyB0eXBlXSxcbiAgICBzdHlsZTogKF9zdHlsZSA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUsIGJhckNvbnRleHQuYmFyLnNjcm9sbEJ1dHRvblt0eXBlXSwgMCksIGRlZmluZVByb3BlcnR5KF9zdHlsZSwgJ3dpZHRoJywgc2l6ZSksIGRlZmluZVByb3BlcnR5KF9zdHlsZSwgJ2hlaWdodCcsIHNpemUpLCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpLCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUsICdjdXJzb3InLCAncG9pbnRlcicpLCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUsICdkaXNwbGF5JywgJ3RhYmxlJyksIF9zdHlsZSksXG4gICAgcmVmOiB0eXBlXG4gIH07XG5cbiAgdmFyIGlubmVyUHJvcHMgPSB7XG4gICAgY2xhc3M6ICdfX2Jhci1idXR0b24taW5uZXInLFxuICAgIHN0eWxlOiB7XG4gICAgICBib3JkZXI6ICdjYWxjKCcgKyBzaXplICsgJyAvIDIuNSkgc29saWQgdHJhbnNwYXJlbnQnLFxuICAgICAgd2lkdGg6ICcwJyxcbiAgICAgIGhlaWdodDogJzAnLFxuICAgICAgbWFyZ2luOiAnYXV0bycsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgYm90dG9tOiAnMCcsXG4gICAgICByaWdodDogJzAnLFxuICAgICAgbGVmdDogJzAnXG4gICAgfSxcbiAgICBvbjoge31cbiAgfTtcblxuICBpZiAoYmFyQ29udGV4dC50eXBlID09ICd2ZXJ0aWNhbCcpIHtcbiAgICBpZiAodHlwZSA9PSAnc3RhcnQnKSB7XG4gICAgICBpbm5lclByb3BzLnN0eWxlWydib3JkZXItYm90dG9tLWNvbG9yJ10gPSBib3JkZXJDb2xvcjtcbiAgICAgIGlubmVyUHJvcHMuc3R5bGVbJ3RyYW5zZm9ybSddID0gJ3RyYW5zbGF0ZVkoLTI1JSknO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lclByb3BzLnN0eWxlWydib3JkZXItdG9wLWNvbG9yJ10gPSBib3JkZXJDb2xvcjtcbiAgICAgIGlubmVyUHJvcHMuc3R5bGVbJ3RyYW5zZm9ybSddID0gJ3RyYW5zbGF0ZVkoMjUlKSc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlID09ICdzdGFydCcpIHtcbiAgICAgIGlubmVyUHJvcHMuc3R5bGVbJ2JvcmRlci1yaWdodC1jb2xvciddID0gYm9yZGVyQ29sb3I7XG4gICAgICBpbm5lclByb3BzLnN0eWxlWyd0cmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGVYKC0yNSUpJztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5uZXJQcm9wcy5zdHlsZVsnYm9yZGVyLWxlZnQtY29sb3InXSA9IGJvcmRlckNvbG9yO1xuICAgICAgaW5uZXJQcm9wcy5zdHlsZVsndHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlWCgyNSUpJztcbiAgICB9XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB7XG4gICAgaWYgKGlzU3VwcG9ydFRvdWNoKCkpIHtcbiAgICAgIGlubmVyUHJvcHMub25bJ3RvdWNoc3RhcnQnXSA9IGNyZWF0ZVNjcm9sbEJ1dHRvbkV2ZW50KGJhckNvbnRleHQsIHR5cGUsICd0b3VjaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lclByb3BzLm9uWydtb3VzZWRvd24nXSA9IGNyZWF0ZVNjcm9sbEJ1dHRvbkV2ZW50KGJhckNvbnRleHQsIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoKFxuICAgICdkaXYnLFxuICAgIHdyYXBwZXJQcm9wcyxcbiAgICBbaCgnZGl2JywgaW5uZXJQcm9wcyldXG4gICk7XG59XG5cbnZhciBiYXIgPSB7XG4gIG5hbWU6ICdiYXInLFxuICBwcm9wczoge1xuICAgIG9wczogT2JqZWN0LFxuICAgIHN0YXRlOiBPYmplY3QsXG4gICAgaGlkZUJhcjogQm9vbGVhbixcbiAgICBvdGhlckJhckhpZGU6IEJvb2xlYW4sXG4gICAgdHlwZTogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgYmFyOiBmdW5jdGlvbiBiYXIoKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsTWFwW3RoaXMudHlwZV07XG4gICAgfSxcbiAgICBiYXJTaXplOiBmdW5jdGlvbiBiYXJTaXplKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc3RhdGUuc2l6ZSwgdGhpcy5vcHMuYmFyLm1pblNpemUpO1xuICAgIH0sXG4gICAgYmFyUmF0aW86IGZ1bmN0aW9uIGJhclJhdGlvKCkge1xuICAgICAgcmV0dXJuICgxIC0gdGhpcy5iYXJTaXplKSAvICgxIC0gdGhpcy5zdGF0ZS5zaXplKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgX3N0eWxlMiwgX3N0eWxlMywgX2JhclN0eWxlO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvKiogR2V0IHJnYkEgZm9ybWF0IGJhY2tncm91bmQgY29sb3IgKi9cbiAgICB2YXIgcmFpbEJhY2tncm91bmRDb2xvciA9IGdldFJnYkFDb2xvcih2bS5vcHMucmFpbC5iYWNrZ3JvdW5kLCB2bS5vcHMucmFpbC5vcGFjaXR5KTtcblxuICAgIC8qKiBSYWlsIERhdGEgKi9cbiAgICB2YXIgcmFpbFNpemUgPSB2bS5vcHMucmFpbC5zaXplO1xuICAgIHZhciBlbmRQb3MgPSB2bS5vdGhlckJhckhpZGUgPyAwIDogcmFpbFNpemU7XG4gICAgdmFyIHJhaWwgPSB7XG4gICAgICBjbGFzczogJ19fcmFpbC1pcy0nICsgdm0udHlwZSxcbiAgICAgIHN0eWxlOiAoX3N0eWxlMiA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICd6LWluZGV4JzogJzEnLFxuXG4gICAgICAgIGJvcmRlclJhZGl1czogdm0ub3BzLnJhaWwuc3BlY2lmeUJvcmRlclJhZGl1cyB8fCByYWlsU2l6ZSxcbiAgICAgICAgYmFja2dyb3VuZDogcmFpbEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyOiB2bS5vcHMucmFpbC5ib3JkZXJcbiAgICAgIH0sIGRlZmluZVByb3BlcnR5KF9zdHlsZTIsIHZtLmJhci5vcHNTaXplLCByYWlsU2l6ZSksIGRlZmluZVByb3BlcnR5KF9zdHlsZTIsIHZtLmJhci5wb3NOYW1lLCB2bS5vcHMucmFpbFsnZ3V0dGVyT2ZFbmRzJ10gfHwgMCksIGRlZmluZVByb3BlcnR5KF9zdHlsZTIsIHZtLmJhci5vcHBvc05hbWUsIHZtLm9wcy5yYWlsWydndXR0ZXJPZkVuZHMnXSB8fCBlbmRQb3MpLCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUyLCB2bS5iYXIuc2lkZVBvc05hbWUsIHZtLm9wcy5yYWlsWydndXR0ZXJPZlNpZGUnXSksIF9zdHlsZTIpXG4gICAgfTtcblxuICAgIC8vIGxlZnQgc3BhY2UgZm9yIHNjcm9sbCBidXR0b25cbiAgICB2YXIgYnV0dG9uU2l6ZSA9IHZtLm9wcy5zY3JvbGxCdXR0b24uZW5hYmxlID8gcmFpbFNpemUgOiAwO1xuICAgIHZhciBiYXJXcmFwcGVyID0ge1xuICAgICAgY2xhc3M6ICdfX2Jhci13cmFwLWlzLScgKyB2bS50eXBlLFxuICAgICAgc3R5bGU6IChfc3R5bGUzID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiB2bS5vcHMucmFpbC5zcGVjaWZ5Qm9yZGVyUmFkaXVzIHx8IHJhaWxTaXplXG4gICAgICB9LCBkZWZpbmVQcm9wZXJ0eShfc3R5bGUzLCB2bS5iYXIucG9zTmFtZSwgYnV0dG9uU2l6ZSksIGRlZmluZVByb3BlcnR5KF9zdHlsZTMsIHZtLmJhci5vcHBvc05hbWUsIGJ1dHRvblNpemUpLCBfc3R5bGUzKSxcbiAgICAgIG9uOiB7fVxuICAgIH07XG5cbiAgICB2YXIgc2Nyb2xsRGlzdGFuY2UgPSB2bS5zdGF0ZS5wb3NWYWx1ZSAqIHZtLnN0YXRlLnNpemU7XG4gICAgdmFyIHBvcyA9IHNjcm9sbERpc3RhbmNlICogdm0uYmFyUmF0aW8gLyB2bS5iYXJTaXplO1xuICAgIHZhciBvcGFjaXR5ID0gdm0uc3RhdGUub3BhY2l0eTtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UmVhbFBhcmVudCh0aGlzKTtcblxuICAgIC8vIHNldCBjbGFzcyBob29rXG4gICAgcGFyZW50LnNldENsYXNzSG9vayh0aGlzLnR5cGUgPT0gJ3ZlcnRpY2FsJyA/ICd2QmFyVmlzaWJsZScgOiAnaEJhclZpc2libGUnLCAhIW9wYWNpdHkpO1xuXG4gICAgLyoqIFNjcm9sbGJhciBzdHlsZSAqL1xuICAgIHZhciBiYXJTdHlsZSA9IChfYmFyU3R5bGUgPSB7XG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgbWFyZ2luOiAnYXV0bycsXG4gICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjVzJyxcbiAgICAgICd1c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAgICdib3JkZXItcmFkaXVzJzogJ2luaGVyaXQnXG5cbiAgICB9LCBkZWZpbmVQcm9wZXJ0eShfYmFyU3R5bGUsIHZtLmJhci5zaXplLCB2bS5iYXJTaXplICogMTAwICsgJyUnKSwgZGVmaW5lUHJvcGVydHkoX2JhclN0eWxlLCAnYmFja2dyb3VuZCcsIHZtLm9wcy5iYXIuYmFja2dyb3VuZCksIGRlZmluZVByb3BlcnR5KF9iYXJTdHlsZSwgdm0uYmFyLm9wc1NpemUsIHZtLm9wcy5iYXIuc2l6ZSksIGRlZmluZVByb3BlcnR5KF9iYXJTdHlsZSwgJ29wYWNpdHknLCBvcGFjaXR5KSwgZGVmaW5lUHJvcGVydHkoX2JhclN0eWxlLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZScgKyBzY3JvbGxNYXBbdm0udHlwZV0uYXhpcyArICcoJyArIHBvcyArICclKScpLCBfYmFyU3R5bGUpO1xuICAgIHZhciBiYXIgPSB7XG4gICAgICBzdHlsZTogYmFyU3R5bGUsXG4gICAgICBjbGFzczogJ19fYmFyLWlzLScgKyB2bS50eXBlLFxuICAgICAgcmVmOiAndGh1bWInLFxuICAgICAgb246IHtcbiAgICAgICAgbW91c2VlbnRlcjogZnVuY3Rpb24gbW91c2VlbnRlcigpIHtcbiAgICAgICAgICB2bS5zZXRCYXJIb3ZlclN0eWxlcygpO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbiBtb3VzZWxlYXZlKCkge1xuICAgICAgICAgIHZtLnRyeVJlc3RvcmVCYXJTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodm0udHlwZSA9PSAndmVydGljYWwnKSB7XG4gICAgICBiYXJXcmFwcGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgLy8gTGV0IGJhciB0byBiZSBvbiB0aGUgY2VudGVyLlxuICAgICAgYmFyLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgYmFyLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBiYXIuc3R5bGUudG9wID0gMDtcbiAgICAgIGJhci5zdHlsZS5ib3R0b20gPSAwO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N1cHBvcnRUb3VjaCgpKSB7XG4gICAgICBiYXIub25bJ3RvdWNoc3RhcnQnXSA9IGNyZWF0ZUJhckV2ZW50KHRoaXMsICd0b3VjaCcpO1xuICAgICAgYmFyV3JhcHBlci5vblsndG91Y2hzdGFydCddID0gY3JlYXRlVHJhY2tFdmVudCh0aGlzLCAndG91Y2hzdGFydCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXIub25bJ21vdXNlZG93biddID0gY3JlYXRlQmFyRXZlbnQodGhpcyk7XG4gICAgICBiYXJXcmFwcGVyLm9uWydtb3VzZWRvd24nXSA9IGNyZWF0ZVRyYWNrRXZlbnQodGhpcywgJ21vdXNlZG93bicpO1xuICAgIH1cblxuICAgIHJldHVybiBoKFxuICAgICAgJ2RpdicsXG4gICAgICByYWlsLFxuICAgICAgW2NyZWF0ZVNjcm9sbGJhckJ1dHRvbihoLCB0aGlzLCAnc3RhcnQnKSwgdGhpcy5oaWRlQmFyID8gbnVsbCA6IGgoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBiYXJXcmFwcGVyLFxuICAgICAgICBbaCgnZGl2JywgYmFyKV1cbiAgICAgICksIGNyZWF0ZVNjcm9sbGJhckJ1dHRvbihoLCB0aGlzLCAnZW5kJyldXG4gICAgKTtcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gVXNlIHRvIHJlc3RvcmUgYmFyIHN0eWxlcyBhZnRlciBob3ZlcmluZyB0aGUgYmFycywgb24gZW5hYmxlXG4gICAgICAvLyB3aGVuIG9wdGlvbiBob3ZlclN0eWxlIGlzIG5vdCBgZmFsc3lgLlxuICAgICAgb3JpZ2luQmFyU3R5bGU6IG51bGwsXG4gICAgICBpc0JhckRyYWdnaW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHNldEJhckRyYWc6IGZ1bmN0aW9uIHNldEJhckRyYWcodmFsKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3tcbiAgICAgIHRoaXMuJGVtaXQoJ3NldEJhckRyYWcnLCB0aGlzLmlzQmFyRHJhZ2dpbmcgPSB2YWwpO1xuXG4gICAgICAvLyBzZXQgY2xhc3MgaG9va3NcblxuICAgICAgdmFyIHBhcmVudCA9IGdldFJlYWxQYXJlbnQodGhpcyk7XG4gICAgICAvLyBzZXQgY2xhc3MgaG9va1xuICAgICAgcGFyZW50LnNldENsYXNzSG9vayh0aGlzLnR5cGUgPT0gJ3ZlcnRpY2FsJyA/ICd2QmFyRHJhZ2dpbmcnIDogJ2hCYXJEcmFnZ2luZycsICEhdmFsKTtcblxuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgdGhpcy50cnlSZXN0b3JlQmFyU3R5bGVzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0cnlSZXN0b3JlQmFyU3R5bGVzOiBmdW5jdGlvbiB0cnlSZXN0b3JlQmFyU3R5bGVzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5pc0JhckRyYWdnaW5nIHx8ICF0aGlzLm9yaWdpbkJhclN0eWxlKSByZXR1cm47XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3JpZ2luQmFyU3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfdGhpcy4kcmVmcy50aHVtYi5zdHlsZVtrZXldID0gX3RoaXMub3JpZ2luQmFyU3R5bGVba2V5XTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0QmFySG92ZXJTdHlsZXM6IGZ1bmN0aW9uIHNldEJhckhvdmVyU3R5bGVzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBob3ZlckJhclN0eWxlID0gdGhpcy5vcHMuYmFyLmhvdmVyU3R5bGU7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKCFob3ZlckJhclN0eWxlKSByZXR1cm47XG5cbiAgICAgIGlmICghdGhpcy5vcmlnaW5CYXJTdHlsZSkge1xuICAgICAgICB0aGlzLm9yaWdpbkJhclN0eWxlID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGhvdmVyQmFyU3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIF90aGlzMi5vcmlnaW5CYXJTdHlsZVtrZXldID0gX3RoaXMyLiRyZWZzLnRodW1iLnN0eWxlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBtZXJnZU9iamVjdChob3ZlckJhclN0eWxlLCB0aGlzLiRyZWZzLnRodW1iLnN0eWxlLCB0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldEJhckRhdGEodm0sIHR5cGUpIHtcbiAgdmFyIGF4aXMgPSBzY3JvbGxNYXBbdHlwZV0uYXhpcztcbiAgLyoqIHR5cGUuY2hhckF0KDApID0gdkJhci9oQmFyICovXG4gIHZhciBiYXJUeXBlID0gdHlwZS5jaGFyQXQoMCkgKyAnQmFyJztcblxuICB2YXIgaGlkZUJhciA9ICF2bS5iYXJbYmFyVHlwZV0uc3RhdGUuc2l6ZSB8fCAhdm0ubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbFsnc2Nyb2xsaW5nJyArIGF4aXNdIHx8IHZtLnJlZnJlc2hMb2FkICYmIHR5cGUgIT09ICd2ZXJ0aWNhbCcgfHwgdm0ubWVyZ2VkT3B0aW9ucy5iYXIuZGlzYWJsZTtcblxuICB2YXIga2VlcFNob3dSYWlsID0gdm0ubWVyZ2VkT3B0aW9ucy5yYWlsLmtlZXBTaG93O1xuXG4gIGlmIChoaWRlQmFyICYmICFrZWVwU2hvd1JhaWwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBvcHM6IHtcbiAgICAgICAgYmFyOiB2bS5tZXJnZWRPcHRpb25zLmJhcixcbiAgICAgICAgcmFpbDogdm0ubWVyZ2VkT3B0aW9ucy5yYWlsLFxuICAgICAgICBzY3JvbGxCdXR0b246IHZtLm1lcmdlZE9wdGlvbnMuc2Nyb2xsQnV0dG9uXG4gICAgICB9LFxuICAgICAgc3RhdGU6IHZtLmJhcltiYXJUeXBlXS5zdGF0ZSxcbiAgICAgIGhpZGVCYXI6IGhpZGVCYXJcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBzZXRCYXJEcmFnOiB2bS5zZXRCYXJEcmFnXG4gICAgfSxcbiAgICByZWY6IHR5cGUgKyAnQmFyJyxcbiAgICBrZXk6IHR5cGVcbiAgfTtcbn1cblxuLyoqXG4gKiBjcmVhdGUgYmFyc1xuICpcbiAqIEBwYXJhbSB7YW55fSBzaXplXG4gKiBAcGFyYW0ge2FueX0gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXIoaCwgdm0pIHtcbiAgdmFyIHZlcnRpY2FsQmFyUHJvcHMgPSBnZXRCYXJEYXRhKHZtLCAndmVydGljYWwnKTtcbiAgdmFyIGhvcml6b250YWxCYXJQcm9wcyA9IGdldEJhckRhdGEodm0sICdob3Jpem9udGFsJyk7XG5cbiAgLy8gc2V0IGNsYXNzIGhvb2tzXG4gIHZtLnNldENsYXNzSG9vaygnaGFzVkJhcicsICEhdmVydGljYWxCYXJQcm9wcyk7XG4gIHZtLnNldENsYXNzSG9vaygnaGFzSEJhcicsICEhaG9yaXpvbnRhbEJhclByb3BzKTtcblxuICByZXR1cm4gW3ZlcnRpY2FsQmFyUHJvcHMgPyBoKCdiYXInLCBfZXh0ZW5kcyh7fSwgdmVydGljYWxCYXJQcm9wcywge1xuICAgIHByb3BzOiBfZXh0ZW5kcyh7IG90aGVyQmFySGlkZTogIWhvcml6b250YWxCYXJQcm9wcyB9LCB2ZXJ0aWNhbEJhclByb3BzLnByb3BzKVxuICB9KSkgOiBudWxsLCBob3Jpem9udGFsQmFyUHJvcHMgPyBoKCdiYXInLCBfZXh0ZW5kcyh7fSwgaG9yaXpvbnRhbEJhclByb3BzLCB7XG4gICAgcHJvcHM6IF9leHRlbmRzKHsgb3RoZXJCYXJIaWRlOiAhdmVydGljYWxCYXJQcm9wcyB9LCBob3Jpem9udGFsQmFyUHJvcHMucHJvcHMpXG4gIH0pKSA6IG51bGxdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgbGlrZSBhIEhPQywgSXQgZXh0cmFjdHMgdGhlIGNvbW1vbiBwYXJ0cyBvZiB0aGVcbiAqIG5hdGl2ZS1tb2RlLCBzbGlkZS1tb2RlIGFuZCBtaXgtbW9kZS5cbiAqIEVhY2ggbW9kZSBtdXN0IGltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gKiAxLiByZWZyZXNoSW50ZXJuYWxTdGF0dXMgOiB1c2UgdG8gcmVmcmVzaCB0aGUgY29tcG9uZW50XG4gKiAyLiBkZXN0cm95IDogRGVzdHJveSBzb21lIHJlZ2lzdHJ5ZWQgZXZlbnRzIGJlZm9yZSBjb21wb25lbnQgZGVzdHJveS5cbiAqIDMuIHVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50OiB1c2UgdG8gdXBkYXRlIGJhciBzdGF0ZXMgYW5kIGVtaXQgZXZlbnRzLlxuICovXG5cbnZhciBjcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoX3JlZikge1xuICB2YXIgX3JlbmRlciA9IF9yZWYucmVuZGVyLFxuICAgICAgY29tcG9uZW50cyA9IF9yZWYuY29tcG9uZW50cyxcbiAgICAgIG1peGlucyA9IF9yZWYubWl4aW5zO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICd2dWVTY3JvbGwnLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHM6IHsgdHlwZTogT2JqZWN0IH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgbWl4aW5zOiBbYXBpXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoW10uY29uY2F0KG1peGlucykpKSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLyoqXG4gICAgICAgKiBCZWdpbiB0byBtZXJnZSBvcHRpb25zXG4gICAgICAgKi9cblxuICAgICAgdmFyIF9nZmMgPSBtZXJnZU9iamVjdCh0aGlzLiR2dWVzY3JvbGxDb25maWcgfHwge30sIHt9KTtcbiAgICAgIHZhciBvcHMgPSBtZXJnZU9iamVjdChiYXNlQ29uZmlnLCBfZ2ZjKTtcblxuICAgICAgdGhpcy4kb3B0aW9ucy5wcm9wc0RhdGEub3BzID0gdGhpcy4kb3B0aW9ucy5wcm9wc0RhdGEub3BzIHx8IHt9O1xuICAgICAgT2JqZWN0LmtleXModGhpcy4kb3B0aW9ucy5wcm9wc0RhdGEub3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAge1xuICAgICAgICAgIGRlZmluZVJlYWN0aXZlKF90aGlzLm1lcmdlZE9wdGlvbnMsIGtleSwgX3RoaXMuJG9wdGlvbnMucHJvcHNEYXRhLm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gZnJvbSBvcHMgdG8gbWVyZ2VkT3B0aW9uc1xuICAgICAgbWVyZ2VPYmplY3Qob3BzLCB0aGlzLm1lcmdlZE9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9pc1Z1ZXNjcm9sbFJvb3QgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJFcnJvciA9IHZhbGlkYXRlT3BzKHRoaXMubWVyZ2VkT3B0aW9ucyk7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKHZtLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCBbW3ZtLiRzbG90c1snZGVmYXVsdCddXV0pO1xuICAgICAgfVxuXG4gICAgICAvLyB2dWVzY3JvbGwgZGF0YVxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgaGVpZ2h0OiB2bS52dWVzY3JvbGwuc3RhdGUuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB2bS52dWVzY3JvbGwuc3RhdGUud2lkdGgsXG4gICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6IF9leHRlbmRzKHsgX192dWVzY3JvbGw6IHRydWUgfSwgdm0uY2xhc3NIb29rcylcbiAgICAgIH07XG5cbiAgICAgIGlmICghaXNTdXBwb3J0VG91Y2goKSkge1xuICAgICAgICBkYXRhLm9uID0ge1xuICAgICAgICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uIG1vdXNlZW50ZXIoKSB7XG4gICAgICAgICAgICB2bS52dWVzY3JvbGwuc3RhdGUucG9pbnRlckxlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICB2bS51cGRhdGVCYXJTdGF0ZUFuZEVtaXRFdmVudCgpO1xuXG4gICAgICAgICAgICB2bS5zZXRDbGFzc0hvb2soJ21vdXNlRW50ZXInLCB0cnVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vdXNlbGVhdmU6IGZ1bmN0aW9uIG1vdXNlbGVhdmUoKSB7XG4gICAgICAgICAgICB2bS52dWVzY3JvbGwuc3RhdGUucG9pbnRlckxlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZtLmhpZGVCYXIoKTtcblxuICAgICAgICAgICAgdm0uc2V0Q2xhc3NIb29rKCdtb3VzZUVudGVyJywgZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiBtb3VzZW1vdmUoKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3tcbiAgICAgICAgICAgIHZtLnZ1ZXNjcm9sbC5zdGF0ZS5wb2ludGVyTGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZtLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL2Vsc2Uge1xuICAgICAgICAgIGRhdGEub24gPSB7XG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiB0b3VjaHN0YXJ0KCkge1xuICAgICAgICAgICAgICB2bS52dWVzY3JvbGwuc3RhdGUucG9pbnRlckxlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZtLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uIHRvdWNoZW5kKCkge1xuICAgICAgICAgICAgICB2bS52dWVzY3JvbGwuc3RhdGUucG9pbnRlckxlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdm0uaGlkZUJhcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gdG91Y2htb3ZlKCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICAgICAgICAgIHZtLnZ1ZXNjcm9sbC5zdGF0ZS5wb2ludGVyTGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdm0udXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIHZhciBjaCA9IFtfcmVuZGVyKGgsIHZtKV0uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNyZWF0ZUJhcihoLCB2bSkpKTtcblxuICAgICAgdmFyIF9jdXN0b21Db250YWluZXIgPSB0aGlzLiRzbG90c1snc2Nyb2xsLWNvbnRhaW5lciddO1xuICAgICAgaWYgKF9jdXN0b21Db250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydENoaWxkcmVuSW50b1Nsb3QoaCwgX2N1c3RvbUNvbnRhaW5lciwgY2gsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIFtjaF1cbiAgICAgICk7XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0aGlzLmluaXRWYXJpYWJsZXMoKTtcbiAgICAgICAgdGhpcy5pbml0V2F0Y2hPcHNDaGFuZ2UoKTtcbiAgICAgICAgLy8gQ2FsbCBleHRlcm5hbCBtZXJnZWQgQXBpXG4gICAgICAgIHRoaXMucmVmcmVzaEludGVybmFsU3RhdHVzKCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVkQ2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5zY3JvbGxUb0FuY2hvcigpO1xuICAgICAgICAgIC8vIG5lZWQgdG8gcmVmbG93IHRvIGRlYWwgd2l0aCB0aGVcbiAgICAgICAgICAvLyBsYXRlc3QgdGhpbmcuXG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnVwZGF0ZWRDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgY2IuY2FsbChfdGhpczMpO1xuICAgICAgfSk7XG4gICAgICAvLyBDbGVhclxuICAgICAgdGhpcy51cGRhdGVkQ2JzID0gW107XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgLy8gcmVtb3ZlIHJlZ2lzdHJ5ZWQgcmVzaXplIGV2ZW50XG4gICAgICBpZiAodGhpcy5kZXN0cm95UGFyZW50RG9tUmVzaXplKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVBhcmVudERvbVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQYXJlbnREb21SZXNpemUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENvbXB1dGVkIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHNjcm9sbFBhbmVsRWxtOiBmdW5jdGlvbiBzY3JvbGxQYW5lbEVsbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnNbJ3Njcm9sbFBhbmVsJ10uX2lzVnVlID8gdGhpcy4kcmVmc1snc2Nyb2xsUGFuZWwnXS4kZWwgOiB0aGlzLiRyZWZzWydzY3JvbGxQYW5lbCddO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZ1ZXNjcm9sbDoge1xuICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHBvaW50ZXJMZWF2ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8qKiBEZWZhdWx0IHNpemVTdHJhdGVnaWVzICovXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAvLyBjdXJyZW50IHNpemUgc3RyYXRlZ3lcbiAgICAgICAgICAgIGN1cnJlbnRTaXplU3RyYXRlZ3k6ICdwZXJjZW50J1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmFyOiB7XG4gICAgICAgICAgdkJhcjoge1xuICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgcG9zVmFsdWU6IDAsXG4gICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGhCYXI6IHtcbiAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgIHBvc1ZhbHVlOiAwLFxuICAgICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJnZWRPcHRpb25zOiB7XG4gICAgICAgICAgdnVlc2Nyb2xsOiB7fSxcbiAgICAgICAgICBzY3JvbGxQYW5lbDoge30sXG4gICAgICAgICAgc2Nyb2xsQ29udGVudDoge30sXG4gICAgICAgICAgcmFpbDoge30sXG4gICAgICAgICAgYmFyOiB7fVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVkQ2JzOiBbXSxcbiAgICAgICAgcmVuZGVyRXJyb3I6IGZhbHNlLFxuXG4gICAgICAgIGNsYXNzSG9va3M6IHtcbiAgICAgICAgICBoYXNWQmFyOiBmYWxzZSxcbiAgICAgICAgICBoYXNIQmFyOiBmYWxzZSxcblxuICAgICAgICAgIHZCYXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICBoQmFyVmlzaWJsZTogZmFsc2UsXG5cbiAgICAgICAgICB2QmFyRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgIGhCYXJEcmFnZ2luZzogZmFsc2UsXG5cbiAgICAgICAgICBjbGlraW5nVmVydGljYWxTdGFydEJ1dHRvbjogZmFsc2UsXG4gICAgICAgICAgY2xpa2luZ1ZlcnRpY2FsRW5kQnV0dG9uOiBmYWxzZSxcbiAgICAgICAgICBjbGlraW5nSG9yaXpvbnRhbFN0YXJ0QnV0dG9uOiBmYWxzZSxcbiAgICAgICAgICBjbGlraW5nSG9yaXpvbnRhbEVuZEJ1dHRvbjogZmFsc2UsXG5cbiAgICAgICAgICBtb3VzZUVudGVyOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgbWV0aG9kczoge1xuICAgICAgLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBIYW5kbGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgc2Nyb2xsaW5nQ29tcGxldGU6IGZ1bmN0aW9uIHNjcm9sbGluZ0NvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCdoYW5kbGUtc2Nyb2xsLWNvbXBsZXRlJyk7XG4gICAgICB9LFxuICAgICAgc2V0QmFyRHJhZzogZnVuY3Rpb24gc2V0QmFyRHJhZyh2YWwpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhpcy52dWVzY3JvbGwuc3RhdGUuaXNEcmFnZ2luZyA9IHZhbDtcbiAgICAgIH0sXG4gICAgICBzZXRDbGFzc0hvb2s6IGZ1bmN0aW9uIHNldENsYXNzSG9vayhuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsYXNzSG9va3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTb21lIEhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgIC8qXG4gICAgICAgKiBUbyBoYXZlIGEgZ29vZCB1eCwgaW5zdGVhZCBvZiBoaWRpbmcgYmFyIGltbWVkaWF0ZWx5LCB3ZSBoaWRlIGJhclxuICAgICAgICogYWZ0ZXIgc29tZSBzZWNvbmRzIGJ5IHVzaW5nIHRoaXMgc2ltcGxlIGRlYm91bmNlLWhpZGViYXIgbWV0aG9kLlxuICAgICAgICovXG4gICAgICBzaG93QW5kRGVmZmVyZWRIaWRlQmFyOiBmdW5jdGlvbiBzaG93QW5kRGVmZmVyZWRIaWRlQmFyKGZvcmNlSGlkZUJhcikge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB0aGlzLnNob3dCYXIoKTtcblxuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICAgIHRoaXMudGltZW91dElkID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0LnRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgX3RoaXM0LmhpZGVCYXIoZm9yY2VIaWRlQmFyKTtcbiAgICAgICAgfSwgdGhpcy5tZXJnZWRPcHRpb25zLmJhci5zaG93RGVsYXkpO1xuICAgICAgfSxcbiAgICAgIHNob3dCYXI6IGZ1bmN0aW9uIHNob3dCYXIoKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5tZXJnZWRPcHRpb25zLmJhci5vcGFjaXR5O1xuICAgICAgICB0aGlzLmJhci52QmFyLnN0YXRlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICB0aGlzLmJhci5oQmFyLnN0YXRlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgfSxcbiAgICAgIGhpZGVCYXI6IGZ1bmN0aW9uIGhpZGVCYXIoZm9yY2VIaWRlQmFyKSB7XG4gICAgICAgIC8vIHdoZW4gaW4gbm9uLW5hdGl2ZSBtb2RlIGRyYWdnaW5nIGNvbnRlbnRcbiAgICAgICAgLy8gaW4gc2xpZGUgbW9kZSwganVzdCByZXR1cm5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKHRoaXMudnVlc2Nyb2xsLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VIaWRlQmFyICYmICF0aGlzLm1lcmdlZE9wdGlvbnMuYmFyLmtlZXBTaG93KSB7XG4gICAgICAgICAgdGhpcy5iYXIuaEJhci5zdGF0ZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICB0aGlzLmJhci52QmFyLnN0YXRlLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGlzRHJhZ2dpbmcgY29uZGl0aW9uXG4gICAgICAgIC8vIHRvIHByZXZlbnQgZnJvbSBoaWRpbmcgYmFyIHdoaWxlIGRyYWdnaW5nIHRoZSBiYXJcbiAgICAgICAgaWYgKCF0aGlzLm1lcmdlZE9wdGlvbnMuYmFyLmtlZXBTaG93ICYmICF0aGlzLnZ1ZXNjcm9sbC5zdGF0ZS5pc0RyYWdnaW5nICYmIHRoaXMudnVlc2Nyb2xsLnN0YXRlLnBvaW50ZXJMZWF2ZSkge1xuICAgICAgICAgIHRoaXMuYmFyLnZCYXIuc3RhdGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgdGhpcy5iYXIuaEJhci5zdGF0ZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZU51bWJlcmljU2l6ZTogZnVuY3Rpb24gdXNlTnVtYmVyaWNTaXplKCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB0aGlzLnVzZVBlcmNlbnRTaXplKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNS52dWVzY3JvbGwuc3RhdGUuY3VycmVudFNpemVTdHJhdGVneSA9ICdudW1iZXInO1xuXG4gICAgICAgICAgdmFyIGVsID0gX3RoaXM1LiRlbC5wYXJlbnROb2RlIHx8IF90aGlzNS4kZWw7XG4gICAgICAgICAgX3RoaXM1LnZ1ZXNjcm9sbC5zdGF0ZS5oZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgIF90aGlzNS52dWVzY3JvbGwuc3RhdGUud2lkdGggPSBlbC5vZmZzZXRXaWR0aCArICdweCc7XG5cbiAgICAgICAgICBfdGhpczUudXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQoJ2hhbmRsZS1yZXNpemUnKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlUGVyY2VudFNpemU6IGZ1bmN0aW9uIHVzZVBlcmNlbnRTaXplKCkge1xuICAgICAgICB0aGlzLnZ1ZXNjcm9sbC5zdGF0ZS5jdXJyZW50U2l6ZVN0cmF0ZWd5ID0gJ3BlcmNlbnQnO1xuXG4gICAgICAgIHRoaXMudnVlc2Nyb2xsLnN0YXRlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy52dWVzY3JvbGwuc3RhdGUud2lkdGggPSAnMTAwJSc7XG4gICAgICB9LFxuXG4gICAgICAvLyBTZXQgaXRzIHNpemUgdG8gYmUgZXF1YWwgdG8gaXRzIHBhcmVudE5vZGVcbiAgICAgIHNldFZzU2l6ZTogZnVuY3Rpb24gc2V0VnNTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95UGFyZW50RG9tUmVzaXplKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95UGFyZW50RG9tUmVzaXplKCk7XG4gICAgICAgICAgdGhpcy5kZXN0cm95UGFyZW50RG9tUmVzaXplID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnNpemVTdHJhdGVneSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMudXNlTnVtYmVyaWNTaXplKCk7XG4gICAgICAgICAgdGhpcy5yZWdpc3RyeVBhcmVudFJlc2l6ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWVyZ2VkT3B0aW9ucy52dWVzY3JvbGwuc2l6ZVN0cmF0ZWd5ID09ICdwZXJjZW50Jykge1xuICAgICAgICAgIHRoaXMudXNlUGVyY2VudFNpemUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEluaXQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICBpbml0V2F0Y2hPcHNDaGFuZ2U6IGZ1bmN0aW9uIGluaXRXYXRjaE9wc0NoYW5nZSgpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHdhdGNoT3B0cyA9IHtcbiAgICAgICAgICBkZWVwOiB0cnVlLFxuICAgICAgICAgIHN5bmM6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4kd2F0Y2goJ21lcmdlZE9wdGlvbnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXM2LmlzU21hbGxDaGFuZ2VUaGlzVGljaykge1xuICAgICAgICAgICAgICBfdGhpczYuaXNTbWFsbENoYW5nZVRoaXNUaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzNi51cGRhdGVCYXJTdGF0ZUFuZEVtaXRFdmVudCgnb3B0aW9ucy1jaGFuZ2UnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXM2LnJlZnJlc2hJbnRlcm5hbFN0YXR1cygpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LCB3YXRjaE9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBhbHNvIHdhdGNoIGBzbWFsbGAgY2hhbmdlcywgYW5kIHdoZW4gc21hbGwgY2hhbmdlcyBoYXBwZW4sIHdlIHNlbmRcbiAgICAgICAgICogYSBzaWduYWwgdG8gdnVlc2Nyb2xsLCB0byB0ZWxsIGl0OlxuICAgICAgICAgKiAxLiB3ZSBkb24ndCBuZWVkIHRvIHJlZ2lzdHJ5IHJlc2l6ZVxuICAgICAgICAgKiAyLiB3ZSBkb24ndCBuZWVkIHRvIHJlZ2lzdHJ5IHNjcm9sbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgc21hbGxDaGFuZ2VBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgX3RoaXM2LiR3YXRjaChvcHRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczYuaXNTbWFsbENoYW5nZVRoaXNUaWNrID0gdHJ1ZTtcbiAgICAgICAgICB9LCB3YXRjaE9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIHNjcm9sbFRvIGhhc2gtYW5jaG9yIHdoaWxlIG1vdW50ZWQgY29tcG9uZW50IGhhdmUgbW91bnRlZC5cbiAgICAgIHNjcm9sbFRvQW5jaG9yOiBmdW5jdGlvbiBzY3JvbGxUb0FuY2hvcigpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICove1xuICAgICAgICB2YXIgdmFsaWRhdGVIYXNoU2VsZWN0b3IgPSBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hTZWxlY3RvcihoYXNoKSB7XG4gICAgICAgICAgcmV0dXJuICgvXiNbYS16QS1aX11cXGQqJC8udGVzdChoYXNoKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgaWYgKCFoYXNoIHx8IChoYXNoID0gaGFzaC5zbGljZShoYXNoLmxhc3RJbmRleE9mKCcjJykpKSAmJiAhdmFsaWRhdGVIYXNoU2VsZWN0b3IoaGFzaCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihoYXNoKTtcbiAgICAgICAgaWYgKCFpc0NoaWxkSW5QYXJlbnQoZWxtLCB0aGlzLiRlbCkgfHwgdGhpcy5tZXJnZWRPcHRpb25zLnNjcm9sbFBhbmVsLmluaXRpYWxTY3JvbGxZIHx8IHRoaXMubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5pbml0aWFsU2Nyb2xsWCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoZWxtKTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSZWdpc3RyeSBSZXNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgIHJlZ2lzdHJ5UGFyZW50UmVzaXplOiBmdW5jdGlvbiByZWdpc3RyeVBhcmVudFJlc2l6ZSgpIHtcbiAgICAgICAgdmFyIHJlc2l6ZUVuYWJsZSA9IHRoaXMubWVyZ2VkT3B0aW9ucy52dWVzY3JvbGwuZGV0ZWN0UmVzaXplO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQYXJlbnREb21SZXNpemUgPSByZXNpemVFbmFibGUgPyBpbnN0YWxsUmVzaXplRGV0ZWN0aW9uKHRoaXMuJGVsLnBhcmVudE5vZGUsIHRoaXMudXNlTnVtYmVyaWNTaXplKSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbi8vIGJlZ2luIGltcG9ydGluZ1xudmFyIHNjcm9sbFBhbmVsID0ge1xuICBuYW1lOiAnc2Nyb2xsUGFuZWwnLFxuICBwcm9wczogeyBvcHM6IHsgdHlwZTogT2JqZWN0LCByZXF1aXJlZDogdHJ1ZSB9IH0sXG4gIG1ldGhvZHM6IHtcbiAgICAvLyB0cmlnZ2VyIHNjcm9sbFBhbmVsIG9wdGlvbnMgaW5pdGlhbFNjcm9sbFgsXG4gICAgLy8gaW5pdGlhbFNjcm9sbFlcbiAgICB1cGRhdGVJbml0aWFsU2Nyb2xsOiBmdW5jdGlvbiB1cGRhdGVJbml0aWFsU2Nyb2xsKCkge1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwO1xuXG4gICAgICB2YXIgcGFyZW50ID0gZ2V0UmVhbFBhcmVudCh0aGlzKTtcblxuICAgICAgaWYgKHRoaXMub3BzLmluaXRpYWxTY3JvbGxYKSB7XG4gICAgICAgIHggPSB0aGlzLm9wcy5pbml0aWFsU2Nyb2xsWDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wcy5pbml0aWFsU2Nyb2xsWSkge1xuICAgICAgICB5ID0gdGhpcy5vcHMuaW5pdGlhbFNjcm9sbFk7XG4gICAgICB9XG4gICAgICBpZiAoeCB8fCB5KSB7XG4gICAgICAgIHBhcmVudC5zY3JvbGxUbyh7IHg6IHgsIHk6IHkgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZUluaXRpYWxTY3JvbGwoKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNsYXNzOiBbJ19fcGFuZWwnXSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcGFyZW50ID0gZ2V0UmVhbFBhcmVudCh0aGlzKTtcblxuICAgIHZhciBfY3VzdG9tUGFuZWwgPSBwYXJlbnQuJHNsb3RzWydzY3JvbGwtcGFuZWwnXTtcbiAgICBpZiAoX2N1c3RvbVBhbmVsKSB7XG4gICAgICByZXR1cm4gaW5zZXJ0Q2hpbGRyZW5JbnRvU2xvdChoLCBfY3VzdG9tUGFuZWwsIHRoaXMuJHNsb3RzLmRlZmF1bHQsIGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBoKFxuICAgICAgJ2RpdicsXG4gICAgICBkYXRhLFxuICAgICAgW1t0aGlzLiRzbG90cy5kZWZhdWx0XV1cbiAgICApO1xuICB9XG59O1xuXG4vKipcbiAqIEluaXQgZm9sbG93aW5nIHRoaW5nc1xuICogMS4gQ29tcG9uZW50XG4gKiAyLiBSZW5kZXJcbiAqIDMuIENvbmZpZ1xuICovXG5mdW5jdGlvbiBfaW5zdGFsbChjb3JlLCByZW5kZXIpIHtcbiAgdmFyIF9jb21wb25lbnRzO1xuXG4gIHZhciBleHRyYUNvbmZpZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICB2YXIgZXh0cmFWYWxpZGF0b3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXTtcblxuICB2YXIgY29tcG9uZW50cyA9IChfY29tcG9uZW50cyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfY29tcG9uZW50cywgc2Nyb2xsUGFuZWwubmFtZSwgc2Nyb2xsUGFuZWwpLCBkZWZpbmVQcm9wZXJ0eShfY29tcG9uZW50cywgYmFyLm5hbWUsIGJhciksIF9jb21wb25lbnRzKTtcblxuICB2YXIgb3B0cyA9IHt9O1xuICBvcHRzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICBvcHRzLnJlbmRlciA9IHJlbmRlcjtcbiAgb3B0cy5taXhpbnMgPSBjb3JlO1xuXG4gIHZhciBjb21wID0gY3JlYXRlQ29tcG9uZW50KG9wdHMpO1xuXG4gIC8vIEluaXQgQ29uZmlnXG4gIGV4dGVuZE9wdHMoZXh0cmFDb25maWdzLCBleHRyYVZhbGlkYXRvcnMpO1xuXG4gIHJldHVybiBjb21wO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY2hpbGRyZW4gb2YgcGFyZW50IHRob3NlIGFyZSBpbiB2aWV3cG9ydFxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50Vmlld3BvcnREb20ocGFyZW50LCBjb250YWluZXIpIHtcbiAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICB2YXIgZG9tRnJhZ21lbnQgPSBbXTtcblxuICB2YXIgaXNDdXJyZW50dmlldyA9IGZ1bmN0aW9uIGlzQ3VycmVudHZpZXcoZG9tKSB7XG4gICAgdmFyIF9kb20kZ2V0Qm91bmRpbmdDbGllbiA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgbGVmdCA9IF9kb20kZ2V0Qm91bmRpbmdDbGllbi5sZWZ0LFxuICAgICAgICB0b3AgPSBfZG9tJGdldEJvdW5kaW5nQ2xpZW4udG9wLFxuICAgICAgICB3aWR0aCA9IF9kb20kZ2V0Qm91bmRpbmdDbGllbi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2RvbSRnZXRCb3VuZGluZ0NsaWVuLmhlaWdodDtcblxuICAgIHZhciBfY29udGFpbmVyJGdldEJvdW5kaW4gPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBhcmVudExlZnQgPSBfY29udGFpbmVyJGdldEJvdW5kaW4ubGVmdCxcbiAgICAgICAgcGFyZW50VG9wID0gX2NvbnRhaW5lciRnZXRCb3VuZGluLnRvcCxcbiAgICAgICAgcGFyZW50SGVpZ2h0ID0gX2NvbnRhaW5lciRnZXRCb3VuZGluLmhlaWdodCxcbiAgICAgICAgcGFyZW50V2lkdGggPSBfY29udGFpbmVyJGdldEJvdW5kaW4ud2lkdGg7XG5cbiAgICBpZiAobGVmdCAtIHBhcmVudExlZnQgKyB3aWR0aCA+IDAgJiYgbGVmdCAtIHBhcmVudExlZnQgPCBwYXJlbnRXaWR0aCAmJiB0b3AgLSBwYXJlbnRUb3AgKyBoZWlnaHQgPiAwICYmIHRvcCAtIHBhcmVudFRvcCA8IHBhcmVudEhlaWdodCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRvbSA9IGNoaWxkcmVuLml0ZW0oaSk7XG4gICAgaWYgKGlzQ3VycmVudHZpZXcoZG9tKSAmJiAhZG9tLmlzUmVzaXplRWxtKSB7XG4gICAgICBkb21GcmFnbWVudC5wdXNoKGRvbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkb21GcmFnbWVudDtcbn1cblxuLyoqXG4gKiAgQ29tcGF0aWJsZSB0byBzY3JvbGxlcidzIGFuaW1hdGlvbiBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVFYXNpbmdGdW5jdGlvbihlYXNpbmcsIGVhc2luZ1BhdHRlcm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgcmV0dXJuIGVhc2luZ1BhdHRlcm4oZWFzaW5nLCB0aW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGVhc2luZyBwYXR0ZXJuXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vY2ZlcmRpbmFuZGkvc21vb3RoLXNjcm9sbC9ibG9iL21hc3Rlci9zcmMvanMvc21vb3RoLXNjcm9sbC5qc1xuICogbW9kaWZpZWQgYnkgd2FuZ3lpNzA5OVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgRWFzaW5nIHBhdHRlcm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRpbWUgYW5pbWF0aW9uIHNob3VsZCB0YWtlIHRvIGNvbXBsZXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBlYXNpbmdQYXR0ZXJuKGVhc2luZywgdGltZSkge1xuICB2YXIgcGF0dGVybiA9IG51bGw7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHtcbiAgICAvLyBEZWZhdWx0IEVhc2luZyBQYXR0ZXJuc1xuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlSW5RdWFkJykgcGF0dGVybiA9IHRpbWUgKiB0aW1lOyAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgaWYgKGVhc2luZyA9PT0gJ2Vhc2VPdXRRdWFkJykgcGF0dGVybiA9IHRpbWUgKiAoMiAtIHRpbWUpOyAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlSW5PdXRRdWFkJykgcGF0dGVybiA9IHRpbWUgPCAwLjUgPyAyICogdGltZSAqIHRpbWUgOiAtMSArICg0IC0gMiAqIHRpbWUpICogdGltZTsgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgaWYgKGVhc2luZyA9PT0gJ2Vhc2VJbkN1YmljJykgcGF0dGVybiA9IHRpbWUgKiB0aW1lICogdGltZTsgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlT3V0Q3ViaWMnKSBwYXR0ZXJuID0gLS10aW1lICogdGltZSAqIHRpbWUgKyAxOyAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlSW5PdXRDdWJpYycpIHBhdHRlcm4gPSB0aW1lIDwgMC41ID8gNCAqIHRpbWUgKiB0aW1lICogdGltZSA6ICh0aW1lIC0gMSkgKiAoMiAqIHRpbWUgLSAyKSAqICgyICogdGltZSAtIDIpICsgMTsgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgaWYgKGVhc2luZyA9PT0gJ2Vhc2VJblF1YXJ0JykgcGF0dGVybiA9IHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7IC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICBpZiAoZWFzaW5nID09PSAnZWFzZU91dFF1YXJ0JykgcGF0dGVybiA9IDEgLSAtLXRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7IC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgaWYgKGVhc2luZyA9PT0gJ2Vhc2VJbk91dFF1YXJ0JykgcGF0dGVybiA9IHRpbWUgPCAwLjUgPyA4ICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSA6IDEgLSA4ICogLS10aW1lICogdGltZSAqIHRpbWUgKiB0aW1lOyAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICBpZiAoZWFzaW5nID09PSAnZWFzZUluUXVpbnQnKSBwYXR0ZXJuID0gdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7IC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICBpZiAoZWFzaW5nID09PSAnZWFzZU91dFF1aW50JykgcGF0dGVybiA9IDEgKyAtLXRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lOyAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgIGlmIChlYXNpbmcgPT09ICdlYXNlSW5PdXRRdWludCcpIHBhdHRlcm4gPSB0aW1lIDwgMC41ID8gMTYgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSA6IDEgKyAxNiAqIC0tdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7IC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICB9XG4gIHJldHVybiBwYXR0ZXJuIHx8IHRpbWU7IC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIG5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcblxudmFyIFNjcm9sbENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjcm9sbENvbnRyb2woKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Nyb2xsQ29udHJvbCk7XG5cbiAgICB0aGlzLmluaXQoKTtcblxuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTY3JvbGxDb250cm9sLCBbe1xuICAgIGtleTogJ3N0YXJ0U2Nyb2xsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRTY3JvbGwoc3QsIGVkLCBzcGQpIHtcbiAgICAgIHZhciBzdGVwQ2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG5vb3A7XG4gICAgICB2YXIgY29tcGxldGVDYiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogbm9vcDtcbiAgICAgIHZhciB2ZXJ0aWZ5Q2IgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IG5vb3A7XG4gICAgICB2YXIgZWFzaW5nTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBub29wO1xuXG4gICAgICB2YXIgZGYgPSBlZCAtIHN0O1xuICAgICAgdmFyIGRpciA9IGRmID4gMCA/IC0xIDogMTtcbiAgICAgIHZhciBudCA9IG5vdygpO1xuXG4gICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlyICE9IHRoaXMuZGlyIHx8IG50IC0gdGhpcy50cyA+IDIwMCkge1xuICAgICAgICB0aGlzLnRzID0gbnQ7XG5cbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuc3QgPSBzdDtcbiAgICAgICAgdGhpcy5lZCA9IGVkO1xuICAgICAgICB0aGlzLmRmID0gZGY7XG4gICAgICB9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZiArPSBkZjtcbiAgICAgICAgfVxuXG4gICAgICB0aGlzLnNwZCA9IHNwZDtcblxuICAgICAgdGhpcy5jb21wbGV0ZUNiID0gY29tcGxldGVDYjtcbiAgICAgIHRoaXMudmVydGlmeUNiID0gdmVydGlmeUNiO1xuICAgICAgdGhpcy5zdGVwQ2IgPSBzdGVwQ2I7XG4gICAgICB0aGlzLmVhc2luZ01ldGhvZCA9IGVhc2luZ01ldGhvZDtcblxuICAgICAgdGhpcy5yZWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUod2luZG93KTtcblxuICAgICAgaWYgKCF0aGlzLmlzUnVubmluZykgdGhpcy5leGVjU2Nyb2xsKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXhlY1Njcm9sbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4ZWNTY3JvbGwoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG5cbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghX3RoaXMuaXNSdW5uaW5nIHx8ICFfdGhpcy52ZXJ0aWZ5Q2IocGVyY2VudCkpIHtcbiAgICAgICAgICBfdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwZXJjZW50ID0gKG5vdygpIC0gX3RoaXMudHMpIC8gX3RoaXMuc3BkO1xuICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5zdCArIF90aGlzLmRmICogX3RoaXMuZWFzaW5nTWV0aG9kKHBlcmNlbnQpO1xuICAgICAgICAgIF90aGlzLnN0ZXBDYih2YWx1ZSk7XG4gICAgICAgICAgX3RoaXMucmVmKGxvb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyaWdnZXIgY29tcGxldGVcbiAgICAgICAgICBfdGhpcy5zdGVwQ2IoX3RoaXMuc3QgKyBfdGhpcy5kZik7XG4gICAgICAgICAgX3RoaXMuY29tcGxldGVDYigpO1xuXG4gICAgICAgICAgX3RoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMucmVmKGxvb3ApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5zdCA9IDA7XG4gICAgICB0aGlzLmVkID0gMDtcbiAgICAgIHRoaXMuZGYgPSAwO1xuICAgICAgdGhpcy5zcGQgPSAwO1xuICAgICAgdGhpcy50cyA9IDA7XG4gICAgICB0aGlzLmRpciA9IDA7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTY3JvbGxDb250cm9sO1xufSgpO1xuXG5mdW5jdGlvbiBzY3JvbGxUbyhlbG0sIHgsIHkpIHtcbiAgdmFyIHNwZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAzMDA7XG4gIHZhciBlYXNpbmcgPSBhcmd1bWVudHNbNF07XG4gIHZhciBzY3JvbGxpbmdDb21wbGV0ZSA9IGFyZ3VtZW50c1s1XTtcblxuICB2YXIgc2Nyb2xsTGVmdCA9IHZvaWQgMCxcbiAgICAgIHNjcm9sbFRvcCA9IHZvaWQgMCxcbiAgICAgIHNjcm9sbEhlaWdodCA9IHZvaWQgMCxcbiAgICAgIHNjcm9sbFdpZHRoID0gdm9pZCAwLFxuICAgICAgY2xpZW50V2lkdGggPSB2b2lkIDAsXG4gICAgICBjbGllbnRIZWlnaHQgPSB2b2lkIDA7XG5cbiAgdmFyIF9lbG0gPSBlbG0sXG4gICAgICBub2RlVHlwZSA9IF9lbG0ubm9kZVR5cGU7XG5cbiAgdmFyIHNjcm9sbFggPSBuZXcgU2Nyb2xsQ29udHJvbCgpO1xuICB2YXIgc2Nyb2xsWSA9IG5ldyBTY3JvbGxDb250cm9sKCk7XG5cbiAgaWYgKCFub2RlVHlwZSkge1xuICAgIHdhcm4oJ1lvdSBtdXN0IHBhc3MgYSBkb20gZm9yIHRoZSBmaXJzdCBwYXJhbSwgJyArICdmb3Igd2luZG93IHNjcm9sbGluZywgJyArICd5b3UgY2FuIHBhc3MgZG9jdW1lbnQgYXMgdGhlIGZpcnN0IHBhcmFtLicpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGVUeXBlID09IDkpIHtcbiAgICAvLyBkb2N1bWVudFxuICAgIGVsbSA9IGVsbS5zY3JvbGxpbmdFbGVtZW50O1xuICB9XG5cbiAgdmFyIF9lbG0yID0gZWxtO1xuICBzY3JvbGxMZWZ0ID0gX2VsbTIuc2Nyb2xsTGVmdDtcbiAgc2Nyb2xsVG9wID0gX2VsbTIuc2Nyb2xsVG9wO1xuICBzY3JvbGxIZWlnaHQgPSBfZWxtMi5zY3JvbGxIZWlnaHQ7XG4gIHNjcm9sbFdpZHRoID0gX2VsbTIuc2Nyb2xsV2lkdGg7XG4gIGNsaWVudFdpZHRoID0gX2VsbTIuY2xpZW50V2lkdGg7XG4gIGNsaWVudEhlaWdodCA9IF9lbG0yLmNsaWVudEhlaWdodDtcblxuXG4gIGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB4ID0gc2Nyb2xsTGVmdDtcbiAgfSBlbHNlIHtcbiAgICB4ID0gZ2V0TnVtZXJpY1ZhbHVlKHgsIHNjcm9sbFdpZHRoIC0gY2xpZW50V2lkdGgpO1xuICB9XG4gIGlmICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB5ID0gc2Nyb2xsVG9wO1xuICB9IGVsc2Uge1xuICAgIHkgPSBnZXROdW1lcmljVmFsdWUoeSwgc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0KTtcbiAgfVxuXG4gIHZhciBlYXNpbmdNZXRob2QgPSBjcmVhdGVFYXNpbmdGdW5jdGlvbihlYXNpbmcsIGVhc2luZ1BhdHRlcm4pO1xuICBzY3JvbGxYLnN0YXJ0U2Nyb2xsKHNjcm9sbExlZnQsIHgsIHNwZWVkLCBmdW5jdGlvbiAoZHgpIHtcbiAgICBlbG0uc2Nyb2xsTGVmdCA9IGR4O1xuICB9LCBzY3JvbGxpbmdDb21wbGV0ZSwgdW5kZWZpbmVkLCBlYXNpbmdNZXRob2QpO1xuICBzY3JvbGxZLnN0YXJ0U2Nyb2xsKHNjcm9sbFRvcCwgeSwgc3BlZWQsIGZ1bmN0aW9uIChkeSkge1xuICAgIGVsbS5zY3JvbGxUb3AgPSBkeTtcbiAgfSwgc2Nyb2xsaW5nQ29tcGxldGUsIHVuZGVmaW5lZCwgZWFzaW5nTWV0aG9kKTtcbn1cblxudmFyIG5hdGl2ZUFwaSA9IHtcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAvLyByZWdpc3RyeSBzY3JvbGxcbiAgICB0aGlzLnNjcm9sbFggPSBuZXcgU2Nyb2xsQ29udHJvbCgpO1xuICAgIHRoaXMuc2Nyb2xsWSA9IG5ldyBTY3JvbGxDb250cm9sKCk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIG5hdGl2ZVNjcm9sbFRvOiBmdW5jdGlvbiBuYXRpdmVTY3JvbGxUbyh4LCB5LCBzcGVlZCwgZWFzaW5nKSB7XG4gICAgICBpZiAoc3BlZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5tZXJnZWRPcHRpb25zLnNjcm9sbFBhbmVsLnNwZWVkO1xuICAgICAgfVxuICAgICAgdmFyIGVsbSA9IHRoaXMuc2Nyb2xsUGFuZWxFbG07XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZWxtLnNjcm9sbFRvcCxcbiAgICAgICAgICBzY3JvbGxMZWZ0ID0gZWxtLnNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsV2lkdGggPSBlbG0uc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgY2xpZW50V2lkdGggPSBlbG0uY2xpZW50V2lkdGgsXG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gZWxtLnNjcm9sbEhlaWdodCxcbiAgICAgICAgICBjbGllbnRIZWlnaHQgPSBlbG0uY2xpZW50SGVpZ2h0O1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHggPSBzY3JvbGxMZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGdldE51bWVyaWNWYWx1ZSh4LCBzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgeSA9IHNjcm9sbFRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBnZXROdW1lcmljVmFsdWUoeSwgc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWVkKSB7XG4gICAgICAgIGVhc2luZyA9IGVhc2luZyB8fCB0aGlzLm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWwuZWFzaW5nO1xuICAgICAgICB2YXIgZWFzaW5nTWV0aG9kID0gY3JlYXRlRWFzaW5nRnVuY3Rpb24oZWFzaW5nLCBlYXNpbmdQYXR0ZXJuKTtcblxuICAgICAgICBpZiAoeCAhPSBzY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxYLnN0YXJ0U2Nyb2xsKHNjcm9sbExlZnQsIHgsIHNwZWVkLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgZWxtLnNjcm9sbExlZnQgPSB4O1xuICAgICAgICAgIH0sIHRoaXMuc2Nyb2xsaW5nQ29tcGxldGUuYmluZCh0aGlzKSwgdW5kZWZpbmVkLCBlYXNpbmdNZXRob2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgIT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxZLnN0YXJ0U2Nyb2xsKHNjcm9sbFRvcCwgeSwgc3BlZWQsIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBlbG0uc2Nyb2xsVG9wID0geTtcbiAgICAgICAgICB9LCB0aGlzLnNjcm9sbGluZ0NvbXBsZXRlLmJpbmQodGhpcyksIHVuZGVmaW5lZCwgZWFzaW5nTWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtLnNjcm9sbFRvcCA9IHk7XG4gICAgICAgIGVsbS5zY3JvbGxMZWZ0ID0geDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEN1cnJlbnR2aWV3RG9tTmF0aXZlOiBmdW5jdGlvbiBnZXRDdXJyZW50dmlld0RvbU5hdGl2ZSgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnNjcm9sbENvbnRlbnRFbG07XG4gICAgICB2YXIgZG9tRnJhZ21lbnQgPSBnZXRDdXJyZW50Vmlld3BvcnREb20ocGFyZW50LCB0aGlzLiRlbCk7XG4gICAgICByZXR1cm4gZG9tRnJhZ21lbnQ7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQYW5lbERhdGEoY29udGV4dCkge1xuICAvLyBzY3JvbGxQYW5lbCBkYXRhIHN0YXJ0XG4gIHZhciBkYXRhID0ge1xuICAgIHJlZjogJ3Njcm9sbFBhbmVsJyxcbiAgICBzdHlsZToge1xuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBvdmVyZmxvd1k6ICdzY3JvbGwnLFxuICAgICAgb3ZlcmZsb3dYOiAnc2Nyb2xsJ1xuICAgIH0sXG4gICAgY2xhc3M6IFtdLFxuICAgIG5hdGl2ZU9uOiB7XG4gICAgICAnJnNjcm9sbCc6IGNvbnRleHQuaGFuZGxlU2Nyb2xsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgb3BzOiBjb250ZXh0Lm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWxcbiAgICB9XG4gIH07XG5cbiAgY29udGV4dC5zY3JvbGxZRW5hYmxlID0gdHJ1ZTtcbiAgY29udGV4dC5zY3JvbGxYRW5hYmxlID0gdHJ1ZTtcblxuICBkYXRhLm5hdGl2ZU9uLkRPTU1vdXNlU2Nyb2xsID0gZGF0YS5uYXRpdmVPbi5tb3VzZXdoZWVsID0gY29udGV4dC5vbk1vdXNlV2hlZWw7XG5cbiAgdmFyIF9jb250ZXh0JG1lcmdlZE9wdGlvbiA9IGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbCxcbiAgICAgIHNjcm9sbGluZ1kgPSBfY29udGV4dCRtZXJnZWRPcHRpb24uc2Nyb2xsaW5nWSxcbiAgICAgIHNjcm9sbGluZ1ggPSBfY29udGV4dCRtZXJnZWRPcHRpb24uc2Nyb2xsaW5nWDtcblxuXG4gIGlmICghY29udGV4dC5iYXIuaEJhci5zdGF0ZS5zaXplIHx8ICFzY3JvbGxpbmdYKSB7XG4gICAgY29udGV4dC5zY3JvbGxYRW5hYmxlID0gZmFsc2U7XG4gICAgZGF0YS5zdHlsZS5vdmVyZmxvd1ggPSAnaGlkZGVuJztcbiAgfVxuXG4gIGlmICghY29udGV4dC5iYXIudkJhci5zdGF0ZS5zaXplIHx8ICFzY3JvbGxpbmdZKSB7XG4gICAgY29udGV4dC5zY3JvbGxZRW5hYmxlID0gZmFsc2U7XG4gICAgZGF0YS5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgfVxuXG4gIHZhciBndXR0ZXIgPSBnZXRHdXR0ZXIoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghZ3V0dGVyKSB7XG4gICAgY3JlYXRlSGlkZUJhclN0eWxlKCk7XG4gICAgZGF0YS5jbGFzcy5wdXNoKCdfX2hpZGViYXInKTtcbiAgICBpZiAoaXNJb3MoKSkge1xuICAgICAgZGF0YS5zdHlsZVsnLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmcnXSA9ICd0b3VjaCc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGhpZGUgc3lzdGVtIGJhciBieSB1c2UgYSBuZWdhdGl2ZSB2YWx1ZSBweFxuICAgIC8vIGd1dHRlciBzaG91bGQgYmUgMCB3aGVuIG1hbnVhbGx5IGRpc2FibGUgc2Nyb2xsaW5nWCAjMTRcbiAgICBpZiAoY29udGV4dC5iYXIudkJhci5zdGF0ZS5zaXplICYmIGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5zY3JvbGxpbmdZKSB7XG4gICAgICBpZiAoY29udGV4dC5tZXJnZWRPcHRpb25zLnNjcm9sbFBhbmVsLnZlcnRpY2FsTmF0aXZlQmFyUG9zID09ICdyaWdodCcpIHtcbiAgICAgICAgZGF0YS5zdHlsZS5tYXJnaW5SaWdodCA9ICctJyArIGd1dHRlciArICdweCc7XG4gICAgICB9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovZWxzZSB7XG4gICAgICAgICAgZGF0YS5zdHlsZS5tYXJnaW5MZWZ0ID0gJy0nICsgZ3V0dGVyICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5iYXIuaEJhci5zdGF0ZS5zaXplICYmIGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5zY3JvbGxpbmdYKSB7XG4gICAgICBkYXRhLnN0eWxlLmhlaWdodCA9ICdjYWxjKDEwMCUgKyAnICsgZ3V0dGVyICsgJ3B4KSc7XG4gICAgfVxuICB9XG5cbiAgLy8gY2xlYXIgbGVnZW5jeSBzdHlsZXMgb2Ygc2xpZGUgbW9kZS4uLlxuICBkYXRhLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcnO1xuICBkYXRhLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNjcm9sbFBhbmVsXG4gKlxuICogQHBhcmFtIHthbnl9IHNpemVcbiAqIEBwYXJhbSB7YW55fSBjb250ZXh0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjcmVhdGVQYW5lbChoLCBjb250ZXh0KSB7XG4gIHZhciBkYXRhID0ge307XG5cbiAgZGF0YSA9IGdldFBhbmVsRGF0YShjb250ZXh0KTtcblxuICByZXR1cm4gaChcbiAgICAnc2Nyb2xsUGFuZWwnLFxuICAgIGRhdGEsXG4gICAgW2dldFBhbmVsQ2hpbGRyZW4oaCwgY29udGV4dCldXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFBhbmVsQ2hpbGRyZW4oaCwgY29udGV4dCkge1xuICB2YXIgdmlld1N0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnLFxuICAgICdtaW4td2lkdGgnOiAnMTAwJScsXG4gICAgJ21pbi1oZWlnaHQnOiAnMTAwJSdcbiAgfTtcbiAgdmFyIGRhdGEgPSB7XG4gICAgc3R5bGU6IHZpZXdTdHlsZSxcbiAgICByZWY6ICdzY3JvbGxDb250ZW50JyxcbiAgICBjbGFzczogJ19fdmlldydcbiAgfTtcbiAgdmFyIF9jdXN0b21Db250ZW50ID0gY29udGV4dC4kc2xvdHNbJ3Njcm9sbC1jb250ZW50J107XG5cbiAgaWYgKGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5zY3JvbGxpbmdYKSB7XG4gICAgdmlld1N0eWxlLndpZHRoID0gZ2V0Q29tcGxpdGFibGVTdHlsZSgnd2lkdGgnLCAnZml0LWNvbnRlbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLnN0eWxlWyd3aWR0aCddID0gJzEwMCUnO1xuICB9XG5cbiAgaWYgKGNvbnRleHQubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbC5wYWRkaW5nKSB7XG4gICAgZGF0YS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBjb250ZXh0Lm1lcmdlZE9wdGlvbnMucmFpbC5zaXplO1xuICB9XG5cbiAgaWYgKF9jdXN0b21Db250ZW50KSB7XG4gICAgcmV0dXJuIGluc2VydENoaWxkcmVuSW50b1Nsb3QoaCwgX2N1c3RvbUNvbnRlbnQsIGNvbnRleHQuJHNsb3RzLmRlZmF1bHQsIGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGgoXG4gICAgJ2RpdicsXG4gICAgZGF0YSxcbiAgICBbY29udGV4dC4kc2xvdHMuZGVmYXVsdF1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFuZWxEYXRhJDEoY29udGV4dCkge1xuICAvLyBzY3JvbGxQYW5lbCBkYXRhIHN0YXJ0XG4gIHZhciBkYXRhID0ge1xuICAgIHJlZjogJ3Njcm9sbFBhbmVsJyxcbiAgICBzdHlsZToge1xuICAgICAgJ3VzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICAgJy13ZWJraXQtdXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgICAnbWluLXdpZHRoJzogJzEwMCUnLFxuICAgICAgJ21pbi1oZWlnaHQnOiAnMTAwJSdcbiAgICB9LFxuICAgIGNsYXNzOiBbXSxcbiAgICBwcm9wczoge1xuICAgICAgb3BzOiBjb250ZXh0Lm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWxcbiAgICB9XG4gIH07XG5cbiAgZGF0YS5jbGFzcy5wdXNoKCdfX3NsaWRlJyk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJb3MoKSkge1xuICAgIGRhdGEuc3R5bGUgPSBkZWZpbmVQcm9wZXJ0eSh7fSwgJy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nJywgJ3RvdWNoJyk7XG4gIH1cblxuICBpZiAoY29udGV4dC5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5yZW5kZXJNZXRob2QgPT0gJ3RyYW5zZm9ybScpIHtcbiAgICBkYXRhLnN0eWxlWyd0cmFuc2Zvcm0tb3JpZ2luJ10gPSAnbGVmdCB0b3AgMHB4JztcbiAgfVxuXG4gIHZhciBfY29udGV4dCRtZXJnZWRPcHRpb24gPSBjb250ZXh0Lm1lcmdlZE9wdGlvbnMuc2Nyb2xsUGFuZWwsXG4gICAgICBzY3JvbGxpbmdYID0gX2NvbnRleHQkbWVyZ2VkT3B0aW9uLnNjcm9sbGluZ1gsXG4gICAgICBzY3JvbGxpbmdZID0gX2NvbnRleHQkbWVyZ2VkT3B0aW9uLnNjcm9sbGluZ1ksXG4gICAgICBwYWRkaW5nID0gX2NvbnRleHQkbWVyZ2VkT3B0aW9uLnBhZGRpbmc7XG5cblxuICBpZiAoc2Nyb2xsaW5nWCAmJiAhY29udGV4dC5yZWZyZXNoTG9hZCkge1xuICAgIHZhciB3aWR0aCA9IGdldENvbXBsaXRhYmxlU3R5bGUoJ3dpZHRoJywgJ2ZpdC1jb250ZW50Jyk7XG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICBkYXRhLnN0eWxlWyd3aWR0aCddID0gd2lkdGg7XG4gICAgfSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL2Vsc2Uge1xuICAgICAgICBkYXRhWydkaXNwbGF5J10gPSAnaW5saW5lLWJsb2NrJztcbiAgICAgIH1cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXNjcm9sbGluZ1gpIHtcbiAgICBkYXRhLmNsYXNzLnB1c2goJ3gtaGlkZGVuJyk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghc2Nyb2xsaW5nWSkge1xuICAgIGRhdGEuY2xhc3MucHVzaCgneS1oaWRkZW4nKTtcbiAgfVxuXG4gIGlmIChwYWRkaW5nKSB7XG4gICAgZGF0YS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBjb250ZXh0Lm1lcmdlZE9wdGlvbnMucmFpbC5zaXplO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGdldFBhbmVsQ2hpbGRyZW4kMShoLCBjb250ZXh0KSB7XG4gIHZhciByZW5kZXJDaGlsZHJlbiA9IGdldFZub2RlSW5mbyhjb250ZXh0LiRzbG90c1snc2Nyb2xsLXBhbmVsJ10pLmNoIHx8IGNvbnRleHQuJHNsb3RzLmRlZmF1bHQ7XG4gIHZhciBmaW5hbENoaWxkcmVuID0gW107XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghcmVuZGVyQ2hpbGRyZW4pIHtcbiAgICBjb250ZXh0LiRzbG90cy5kZWZhdWx0ID0gcmVuZGVyQ2hpbGRyZW4gPSBbXTtcbiAgfVxuXG4gIC8vIGhhbmRsZSByZWZyZXNoXG4gIGlmIChjb250ZXh0Lm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1bGxSZWZyZXNoLmVuYWJsZSkge1xuICAgIGZpbmFsQ2hpbGRyZW4ucHVzaChoKFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgICdjbGFzcyc6ICdfX3JlZnJlc2gnLFxuICAgICAgICBzdHlsZTogeyB2aXNpYmlsaXR5OiBjb250ZXh0LnJlZnJlaERvbVZpc2lhYmxlID8gJycgOiAnaGlkZGVuJyB9LFxuICAgICAgICByZWY6IF9fUkVGUkVTSF9ET01fTkFNRSxcbiAgICAgICAga2V5OiBfX1JFRlJFU0hfRE9NX05BTUVcbiAgICAgIH0sXG4gICAgICBbY3JlYXRlVGlwRG9tKGgsIGNvbnRleHQsICdyZWZyZXNoJywgY29udGV4dC5wdWxsUmVmcmVzaFRpcCldXG4gICAgKSk7XG4gIH1cblxuICBmaW5hbENoaWxkcmVuLnB1c2gocmVuZGVyQ2hpbGRyZW4pO1xuXG4gIC8vIGhhbmRsZSBsb2FkXG4gIGlmIChjb250ZXh0Lm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1c2hMb2FkLmVuYWJsZSkge1xuICAgIGZpbmFsQ2hpbGRyZW4ucHVzaChoKFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIHJlZjogX19MT0FEX0RPTV9OQU1FLFxuICAgICAgICBrZXk6IF9fTE9BRF9ET01fTkFNRSxcbiAgICAgICAgJ2NsYXNzJzogJ19fbG9hZCcsXG4gICAgICAgIHN0eWxlOiB7IHZpc2liaWxpdHk6IGNvbnRleHQubG9hZERvbVZpc2lhYmxlID8gJycgOiAnaGlkZGVuJyB9XG4gICAgICB9LFxuICAgICAgW2NyZWF0ZVRpcERvbShoLCBjb250ZXh0LCAnbG9hZCcsIGNvbnRleHQucHVzaExvYWRUaXApXVxuICAgICkpO1xuICB9XG5cbiAgcmV0dXJuIGZpbmFsQ2hpbGRyZW47XG59XG5cbi8vIENyZWF0ZSBsb2FkIG9yIHJlZnJlc2ggdGlwIGRvbSBvZiBlYWNoIHN0YWdlc1xuZnVuY3Rpb24gY3JlYXRlVGlwRG9tKGgsIGNvbnRleHQsIHR5cGUsIHRpcCkge1xuICB2YXIgc3RhZ2UgPSBjb250ZXh0LnZ1ZXNjcm9sbC5zdGF0ZVt0eXBlICsgJ1N0YWdlJ107XG4gIHZhciBkb20gPSBudWxsO1xuICAvLyBSZXR1cm4gdXNlciBzcGVjaWZpZWQgYW5pbWF0aW9uIGRvbVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRvbSA9IGNvbnRleHQuJHNsb3RzW3R5cGUgKyAnLScgKyBzdGFnZV0pIHtcbiAgICByZXR1cm4gZG9tO1xuICB9XG5cbiAgc3dpdGNoIChzdGFnZSkge1xuICAgIC8vIFRoZSBkb20gd2lsbCBzaG93IGF0IGRlYWN0aXZlIHN0YWdlXG4gICAgY2FzZSAnZGVhY3RpdmUnOlxuICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnYWN0aXZlJztcbiAgICAgICAgaWYgKHN0YWdlID09ICdkZWFjdGl2ZScpIHtcbiAgICAgICAgICBjbGFzc05hbWUgKz0gJyBkZWFjdGl2ZSc7XG4gICAgICAgIH1cblxuICAgICAgICBkb20gPSBoKFxuICAgICAgICAgICdzdmcnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICdjbGFzcyc6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgIGF0dHJzOiB7IHZlcnNpb246ICcxLjEnLFxuICAgICAgICAgICAgICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgICAgICAgeG1sbnNYbGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICAgICAgICAgICB4OiAnMHB4JyxcbiAgICAgICAgICAgICAgeTogJzBweCcsXG4gICAgICAgICAgICAgIHZpZXdCb3g6ICcwIDAgMTAwMCAxMDAwJyxcbiAgICAgICAgICAgICAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ25ldyAwIDAgMTAwMCAxMDAwJyxcbiAgICAgICAgICAgICAgeG1sU3BhY2U6ICdwcmVzZXJ2ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFtoKCdtZXRhZGF0YScsIFsnIFN2ZyBWZWN0b3IgSWNvbnMgOiBodHRwOi8vd3d3LnNmb250LmNuICddKSwgaCgnZycsIFtoKFxuICAgICAgICAgICAgJ2cnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhdHRyczogeyB0cmFuc2Zvcm06ICdtYXRyaXgoMSAwIDAgLTEgMCAxMDA4KScgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtoKCdwYXRoJywge1xuICAgICAgICAgICAgICBhdHRyczogeyBkOiAnTTEwLDU0M2w0OTAsNDU1bDQ5MC00NTVMODg1LDQzOEw1NzAsNzM1LjVWMThINDMwdjcxNy41TDExNSw0MzhMMTAsNTQzeicgfVxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgKV0pXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgZG9tID0gaChcbiAgICAgICAgJ3N2ZycsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyczogeyB2aWV3Qm94OiAnMCAwIDUwIDUwJyB9LFxuICAgICAgICAgICdjbGFzcyc6ICdzdGFydCcgfSxcbiAgICAgICAgW2goJ2NpcmNsZScsIHtcbiAgICAgICAgICBhdHRyczogeyBzdHJva2U6ICd0cnVlJywgY3g6ICcyNScsIGN5OiAnMjUnLCByOiAnMjAnIH0sXG4gICAgICAgICAgJ2NsYXNzJzogJ2JnLXBhdGgnIH0pLCBoKCdjaXJjbGUnLCB7XG4gICAgICAgICAgYXR0cnM6IHsgY3g6ICcyNScsIGN5OiAnMjUnLCByOiAnMjAnIH0sXG4gICAgICAgICAgJ2NsYXNzJzogJ2FjdGl2ZS1wYXRoJyB9KV1cbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiZWZvcmVEZWFjdGl2ZSc6XG4gICAgICBkb20gPSBoKFxuICAgICAgICAnc3ZnJyxcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB2aWV3Qm94OiAnMCAwIDEwMjQgMTAyNCcsXG4gICAgICAgICAgICB2ZXJzaW9uOiAnMS4xJyxcbiAgICAgICAgICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAgICAgJ3AtaWQnOiAnMzU2MidcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtoKCdwYXRoJywge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBkOiAnTTUxMiAwQzIyOS43MDY4MzEgMCAwIDIyOS42Njc0NDYgMCA1MTJzMjI5LjY2NzQ0NiA1MTIgNTEyIDUxMmMyODIuMjkzMTY5IDAgNTEyLTIyOS42Njc0NDYgNTEyLTUxMlM3OTQuMzMyNTU0IDAgNTEyIDB6IG0yODIuOTk0MjE1IDM1My40MDYwMzFMNDMzLjI1NDQgNzE1LjE0NTg0NmEzMS40ODQwNjIgMzEuNDg0MDYyIDAgMCAxLTIyLjI3NTkzOCA5LjIzMTc1NGgtMC40MDk2YTMxLjU4NjQ2MiAzMS41ODY0NjIgMCAwIDEtMjIuNDQ5MjMxLTkuODE0NjQ2TDIyOC40MzA3NjkgNTQ2LjMyNzYzMWEzMS41MDc2OTIgMzEuNTA3NjkyIDAgMCAxIDQ1LjcwMTkwOC00My4zODYwOTNsMTM3LjQyMDggMTQ0Ljc4NTcyNEw3NTAuNDQyMzM4IDMwOC44NTQxNTRhMzEuNTA3NjkyIDMxLjUwNzY5MiAwIDEgMSA0NC41NTE4NzcgNDQuNTUxODc3eicsXG4gICAgICAgICAgICBmaWxsOiAnJyxcbiAgICAgICAgICAgICdwLWlkJzogJzM1NjMnXG4gICAgICAgICAgfVxuICAgICAgICB9KV1cbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gW2RvbSwgdGlwXTtcbn1cblxuLyoqXG4gKiBjcmVhdGUgYSBzY3JvbGxQYW5lbFxuICpcbiAqIEBwYXJhbSB7YW55fSBzaXplXG4gKiBAcGFyYW0ge2FueX0gY29udGV4dFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFuZWwkMShoLCBjb250ZXh0KSB7XG4gIHZhciBkYXRhID0gZ2V0UGFuZWxEYXRhJDEoY29udGV4dCk7XG5cbiAgcmV0dXJuIGgoXG4gICAgJ3Njcm9sbFBhbmVsJyxcbiAgICBkYXRhLFxuICAgIFtnZXRQYW5lbENoaWxkcmVuJDEoaCwgY29udGV4dCldXG4gICk7XG59XG5cbi8vIGJlZ2luIGltcG9ydGluZ1xuLyoqXG4gKiBjcmVhdGUgYSBzY3JvbGxQYW5lbFxuICpcbiAqIEBwYXJhbSB7YW55fSBzaXplXG4gKiBAcGFyYW0ge2FueX0gdm1cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhbmVsJDIoaCwgdm0pIHtcbiAgaWYgKHZtLm1vZGUgPT0gJ25hdGl2ZScpIHtcbiAgICByZXR1cm4gY3JlYXRlUGFuZWwoaCwgdm0pO1xuICB9IGVsc2UgaWYgKHZtLm1vZGUgPT0gJ3NsaWRlJykge1xuICAgIHJldHVybiBjcmVhdGVQYW5lbCQxKGgsIHZtKTtcbiAgfVxufVxuXG52YXIgc2xpZGVBcGkgPSB7XG4gIG1ldGhvZHM6IHtcbiAgICBzbGlkZVNjcm9sbFRvOiBmdW5jdGlvbiBzbGlkZVNjcm9sbFRvKHgsIHksIHNwZWVkLCBlYXNpbmcpIHtcbiAgICAgIHZhciBfZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKCksXG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IF9nZXRQb3NpdGlvbi5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF9nZXRQb3NpdGlvbi5zY3JvbGxUb3A7XG5cbiAgICAgIHggPSBnZXROdW1lcmljVmFsdWUoeCB8fCBzY3JvbGxMZWZ0LCB0aGlzLnNjcm9sbGVyLl9fbWF4U2Nyb2xsTGVmdCk7XG4gICAgICB5ID0gZ2V0TnVtZXJpY1ZhbHVlKHkgfHwgc2Nyb2xsVG9wLCB0aGlzLnNjcm9sbGVyLl9fbWF4U2Nyb2xsVG9wKTtcblxuICAgICAgdGhpcy5zY3JvbGxlci5zY3JvbGxUbyh4LCB5LCBzcGVlZCA+IDAsIHVuZGVmaW5lZCwgZmFsc2UsIHNwZWVkLCBlYXNpbmcpO1xuICAgIH0sXG4gICAgem9vbUJ5OiBmdW5jdGlvbiB6b29tQnkoZmFjdG9yLCBhbmltYXRlLCBvcmlnaW5MZWZ0LCBvcmlnaW5Ub3AsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgd2Fybignem9vbUJ5IGFuZCB6b29tVG8gYXJlIG9ubHkgZm9yIHNsaWRlIG1vZGUhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsZXIuem9vbUJ5KGZhY3RvciwgYW5pbWF0ZSwgb3JpZ2luTGVmdCwgb3JpZ2luVG9wLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICB6b29tVG86IGZ1bmN0aW9uIHpvb21UbyhsZXZlbCkge1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIG9yaWdpbkxlZnQgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgb3JpZ2luVG9wID0gYXJndW1lbnRzWzNdO1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzRdO1xuXG4gICAgICBpZiAoIXRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgd2Fybignem9vbUJ5IGFuZCB6b29tVG8gYXJlIG9ubHkgZm9yIHNsaWRlIG1vZGUhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsZXIuem9vbVRvKGxldmVsLCBhbmltYXRlLCBvcmlnaW5MZWZ0LCBvcmlnaW5Ub3AsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGdldEN1cnJlbnRQYWdlOiBmdW5jdGlvbiBnZXRDdXJyZW50UGFnZSgpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxlciB8fCAhdGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5wYWdpbmcpIHtcbiAgICAgICAgd2FybignZ2V0Q3VycmVudFBhZ2UgYW5kIGdvVG9QYWdlIGFyZSBvbmx5IGZvciBzbGlkZSBtb2RlIGFuZCBwYWdpbmcgaXMgZW5ibGUhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbGVyLmdldEN1cnJlbnRQYWdlKCk7XG4gICAgfSxcbiAgICBnb1RvUGFnZTogZnVuY3Rpb24gZ29Ub1BhZ2UoZGVzdCkge1xuICAgICAgdmFyIGFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuc2Nyb2xsZXIgfHwgIXRoaXMubWVyZ2VkT3B0aW9ucy52dWVzY3JvbGwucGFnaW5nKSB7XG4gICAgICAgIHdhcm4oJ2dldEN1cnJlbnRQYWdlIGFuZCBnb1RvUGFnZSBhcmUgb25seSBmb3Igc2xpZGUgbW9kZSBhbmQgcGFnaW5nIGlzIGVuYmxlIScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNjcm9sbGVyLmdvVG9QYWdlKGRlc3QsIGFuaW1hdGUpO1xuICAgIH0sXG4gICAgdHJpZ2dlclJlZnJlc2hPckxvYWQ6IGZ1bmN0aW9uIHRyaWdnZXJSZWZyZXNoT3JMb2FkKHR5cGUpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxlcikge1xuICAgICAgICB3YXJuKCdZb3UgY2FuIG9ubHkgdXNlIHRyaWdnZXJSZWZyZXNoT3JMb2FkIGluIHNsaWRlIG1vZGUhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzUmVmcmVzaCA9IHRoaXMubWVyZ2VkT3B0aW9ucy52dWVzY3JvbGwucHVsbFJlZnJlc2guZW5hYmxlO1xuICAgICAgdmFyIGlzTG9hZCA9IHRoaXMubWVyZ2VkT3B0aW9ucy52dWVzY3JvbGwucHVzaExvYWQuZW5hYmxlO1xuXG4gICAgICBpZiAodHlwZSA9PSAncmVmcmVzaCcgJiYgIWlzUmVmcmVzaCkge1xuICAgICAgICB3YXJuKCdyZWZyZXNoIG11c3QgYmUgZW5hYmxlZCEnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdsb2FkJyAmJiAhaXNMb2FkKSB7XG4gICAgICAgIHdhcm4oJ2xvYWQgbXVzdCBiZSBlbmFibGVkIGFuZCBjb250ZW50XFwncyBoZWlnaHQgPiBjb250YWluZXJcXCdzIGhlaWdodCEnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAncmVmcmVzaCcgJiYgdHlwZSAhPT0gJ2xvYWQnKSB7XG4gICAgICAgIHdhcm4oJ3BhcmFtIG11c3QgYmUgb25lIG9mIGxvYWQgYW5kIHJlZnJlc2ghJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy52dWVzY3JvbGwuc3RhdGVbdHlwZSArICdTdGFnZSddID09ICdzdGFydCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbGVyLnRyaWdnZXJSZWZyZXNoT3JMb2FkKHR5cGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXRDdXJyZW50dmlld0RvbVNsaWRlOiBmdW5jdGlvbiBnZXRDdXJyZW50dmlld0RvbVNsaWRlKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc2Nyb2xsUGFuZWxFbG07XG4gICAgICB2YXIgZG9tRnJhZ21lbnQgPSBnZXRDdXJyZW50Vmlld3BvcnREb20ocGFyZW50LCB0aGlzLiRlbCk7XG4gICAgICByZXR1cm4gZG9tRnJhZ21lbnQ7XG4gICAgfVxuICB9XG59O1xuXG52YXIgYXBpJDEgPSB7XG4gIC8vIG1peCBzbGlkZSBhbmQgbml0aXZlIG1vZGVzIGFwaXMuXG4gIG1peGluczogW3NsaWRlQXBpLCBuYXRpdmVBcGldLFxuICBtZXRob2RzOiB7XG4gICAgLy8gcHJpdmF0ZSBhcGlcbiAgICBpbnRlcm5hbFNjcm9sbFRvOiBmdW5jdGlvbiBpbnRlcm5hbFNjcm9sbFRvKGRlc3RYLCBkZXN0WSwgc3BlZWQsIGVhc2luZykge1xuICAgICAgaWYgKHRoaXMubW9kZSA9PSAnbmF0aXZlJykge1xuICAgICAgICB0aGlzLm5hdGl2ZVNjcm9sbFRvKGRlc3RYLCBkZXN0WSwgc3BlZWQsIGVhc2luZyk7XG4gICAgICB9XG4gICAgICAvLyBmb3Igbm9uLW5hdGl2ZSB3ZSB1c2Ugc2Nyb2xsZXIncyBzY29ybGxUb1xuICAgICAgZWxzZSBpZiAodGhpcy5tb2RlID09ICdzbGlkZScpIHtcbiAgICAgICAgICB0aGlzLnNsaWRlU2Nyb2xsVG8oZGVzdFgsIGRlc3RZLCBzcGVlZCwgZWFzaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Q3VycmVudHZpZXdEb206IGZ1bmN0aW9uIGdldEN1cnJlbnR2aWV3RG9tKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAnc2xpZGUnID8gdGhpcy5nZXRDdXJyZW50dmlld0RvbVNsaWRlKCkgOiB0aGlzLmdldEN1cnJlbnR2aWV3RG9tTmF0aXZlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKlxuICogU2Nyb2xsZXJcbiAqIGh0dHA6Ly9naXRodWIuY29tL3p5bmdhL3Njcm9sbGVyXG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFp5bmdhIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20venluZ2Evc2Nyb2xsZXIvbWFzdGVyL01JVC1MSUNFTlNFLnR4dFxuICpcbiAqIEJhc2VkIG9uIHRoZSB3b3JrIG9mOiBVbmlmeSBQcm9qZWN0ICh1bmlmeS1wcm9qZWN0Lm9yZylcbiAqIGh0dHA6Ly91bmlmeS1wcm9qZWN0Lm9yZ1xuICogQ29weXJpZ2h0IDIwMTEsIERldXRzY2hlIFRlbGVrb20gQUdcbiAqIExpY2Vuc2U6IE1JVCArIEFwYWNoZSAoVjIpXG4gKi9cblxuLyoqXG4gKiBHZW5lcmljIGFuaW1hdGlvbiBjbGFzcyB3aXRoIHN1cHBvcnQgZm9yIGRyb3BwZWQgZnJhbWVzIGJvdGggb3B0aW9uYWwgZWFzaW5nIGFuZCBkdXJhdGlvbi5cbiAqXG4gKiBPcHRpb25hbCBkdXJhdGlvbiBpcyB1c2VmdWwgd2hlbiB0aGUgbGlmZXRpbWUgaXMgZGVmaW5lZCBieSBhbm90aGVyIGNvbmRpdGlvbiB0aGFuIHRpbWVcbiAqIGUuZy4gc3BlZWQgb2YgYW4gYW5pbWF0aW5nIG9iamVjdCwgZXRjLlxuICpcbiAqIERyb3BwZWQgZnJhbWUgbG9naWMgYWxsb3dzIHRvIGtlZXAgdXNpbmcgdGhlIHNhbWUgdXBkYXRlciBsb2dpYyBpbmRlcGVuZGVudCBmcm9tIHRoZSBhY3R1YWxcbiAqIHJlbmRlcmluZy4gVGhpcyBlYXNlcyBhIGxvdCBvZiBjYXNlcyB3aGVyZSBpdCBtaWdodCBiZSBwcmV0dHkgY29tcGxleCB0byBicmVhayBkb3duIGEgc3RhdGVcbiAqIGJhc2VkIG9uIHRoZSBwdXJlIHRpbWUgZGlmZmVyZW5jZS5cbiAqL1xudmFyIHRpbWUgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiArbmV3IERhdGUoKTtcbn07XG52YXIgZGVzaXJlZEZyYW1lcyA9IDYwO1xudmFyIG1pbGxpc2Vjb25kc1BlclNlY29uZCA9IDEwMDA7XG52YXIgcnVubmluZyA9IHt9O1xudmFyIGNvdW50ZXIgPSAxO1xuXG52YXIgY29yZSA9IHsgZWZmZWN0OiB7fSB9O1xudmFyIGdsb2JhbCQxID0gbnVsbDtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbCQxID0gd2luZG93O1xufSBlbHNlIHtcbiAgZ2xvYmFsJDEgPSB7fTtcbn1cblxuY29yZS5lZmZlY3QuQW5pbWF0ZSA9IHtcbiAgLyoqXG4gICAqIEEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdyYXBwZXIgLyBwb2x5ZmlsbC5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn0gVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYmVmb3JlIHRoZSBuZXh0IHJlcGFpbnQuXG4gICAqIEBwYXJhbSByb290IHtIVE1MRWxlbWVudH0gVGhlIHJvb3QgZWxlbWVudCBmb3IgdGhlIHJlcGFpbnRcbiAgICovXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZTogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGdsb2JhbCQxKSxcbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBnaXZlbiBhbmltYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBpZCB7SW50ZWdlcn0gVW5pcXVlIGFuaW1hdGlvbiBJRFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBhbmltYXRpb24gd2FzIHN0b3BwZWQgKGFrYSwgd2FzIHJ1bm5pbmcgYmVmb3JlKVxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gc3RvcChpZCkge1xuICAgIHZhciBjbGVhcmVkID0gcnVubmluZ1tpZF0gIT0gbnVsbDtcbiAgICBpZiAoY2xlYXJlZCkge1xuICAgICAgcnVubmluZ1tpZF0gPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjbGVhcmVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnaXZlbiBhbmltYXRpb24gaXMgc3RpbGwgcnVubmluZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIHtJbnRlZ2VyfSBVbmlxdWUgYW5pbWF0aW9uIElEXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGFuaW1hdGlvbiBpcyBzdGlsbCBydW5uaW5nXG4gICAqL1xuICBpc1J1bm5pbmc6IGZ1bmN0aW9uIGlzUnVubmluZyhpZCkge1xuICAgIHJldHVybiBydW5uaW5nW2lkXSAhPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc3RlcENhbGxiYWNrIHtGdW5jdGlvbn0gUG9pbnRlciB0byBmdW5jdGlvbiB3aGljaCBpcyBleGVjdXRlZCBvbiBldmVyeSBzdGVwLlxuICAgKiAgIFNpZ25hdHVyZSBvZiB0aGUgbWV0aG9kIHNob3VsZCBiZSBgZnVuY3Rpb24ocGVyY2VudCwgbm93LCB2aXJ0dWFsKSB7IHJldHVybiBjb250aW51ZVdpdGhBbmltYXRpb247IH1gXG4gICAqIEBwYXJhbSB2ZXJpZnlDYWxsYmFjayB7RnVuY3Rpb259IEV4ZWN1dGVkIGJlZm9yZSBldmVyeSBhbmltYXRpb24gc3RlcC5cbiAgICogICBTaWduYXR1cmUgb2YgdGhlIG1ldGhvZCBzaG91bGQgYmUgYGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udGludWVXaXRoQW5pbWF0aW9uOyB9YFxuICAgKiBAcGFyYW0gY29tcGxldGVkQ2FsbGJhY2sge0Z1bmN0aW9ufVxuICAgKiAgIFNpZ25hdHVyZSBvZiB0aGUgbWV0aG9kIHNob3VsZCBiZSBgZnVuY3Rpb24oZHJvcHBlZEZyYW1lcywgZmluaXNoZWRBbmltYXRpb24pIHt9YFxuICAgKiBAcGFyYW0gZHVyYXRpb24ge0ludGVnZXJ9IE1pbGxpc2Vjb25kcyB0byBydW4gdGhlIGFuaW1hdGlvblxuICAgKiBAcGFyYW0gZWFzaW5nTWV0aG9kIHtGdW5jdGlvbn0gUG9pbnRlciB0byBlYXNpbmcgZnVuY3Rpb25cbiAgICogICBTaWduYXR1cmUgb2YgdGhlIG1ldGhvZCBzaG91bGQgYmUgYGZ1bmN0aW9uKHBlcmNlbnQpIHsgcmV0dXJuIG1vZGlmaWVkVmFsdWU7IH1gXG4gICAqIEBwYXJhbSByb290IHtFbGVtZW50ID8gZG9jdW1lbnQuYm9keX0gUmVuZGVyIHJvb3QsIHdoZW4gYXZhaWxhYmxlLiBVc2VkIGZvciBpbnRlcm5hbFxuICAgKiAgIHVzYWdlIG9mIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cbiAgICogQHJldHVybiB7SW50ZWdlcn0gSWRlbnRpZmllciBvZiBhbmltYXRpb24uIENhbiBiZSB1c2VkIHRvIHN0b3AgaXQgYW55IHRpbWUuXG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gc3RhcnQoc3RlcENhbGxiYWNrLCB2ZXJpZnlDYWxsYmFjaywgY29tcGxldGVkQ2FsbGJhY2ssIGR1cmF0aW9uLCBlYXNpbmdNZXRob2QsIHJvb3QpIHtcbiAgICB2YXIgc3RhcnQgPSB0aW1lKCk7XG4gICAgdmFyIGxhc3RGcmFtZSA9IHN0YXJ0O1xuICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICB2YXIgZHJvcENvdW50ZXIgPSAwO1xuICAgIHZhciBpZCA9IGNvdW50ZXIrKztcblxuICAgIGlmICghcm9vdCkge1xuICAgICAgcm9vdCA9IGRvY3VtZW50LmJvZHk7XG4gICAgfVxuXG4gICAgLy8gQ29tcGFjdGluZyBydW5uaW5nIGRiIGF1dG9tYXRpY2FsbHkgZXZlcnkgZmV3IG5ldyBhbmltYXRpb25zXG4gICAgaWYgKGlkICUgMjAgPT09IDApIHtcbiAgICAgIHZhciBuZXdSdW5uaW5nID0ge307XG4gICAgICBmb3IgKHZhciB1c2VkSWQgaW4gcnVubmluZykge1xuICAgICAgICBuZXdSdW5uaW5nW3VzZWRJZF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcnVubmluZyA9IG5ld1J1bm5pbmc7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgaW50ZXJuYWwgc3RlcCBtZXRob2Qgd2hpY2ggaXMgY2FsbGVkIGV2ZXJ5IGZldyBtaWxsaXNlY29uZHNcbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uIHN0ZXAodmlydHVhbCkge1xuICAgICAgLy8gTm9ybWFsaXplIHZpcnR1YWwgdmFsdWVcbiAgICAgIHZhciByZW5kZXIgPSB2aXJ0dWFsICE9PSB0cnVlO1xuXG4gICAgICAvLyBHZXQgY3VycmVudCB0aW1lXG4gICAgICB2YXIgbm93ID0gdGltZSgpO1xuXG4gICAgICAvLyBWZXJpZmljYXRpb24gaXMgZXhlY3V0ZWQgYmVmb3JlIG5leHQgYW5pbWF0aW9uIHN0ZXBcbiAgICAgIGlmICghcnVubmluZ1tpZF0gfHwgdmVyaWZ5Q2FsbGJhY2sgJiYgIXZlcmlmeUNhbGxiYWNrKGlkKSkge1xuICAgICAgICBydW5uaW5nW2lkXSA9IG51bGw7XG4gICAgICAgIGNvbXBsZXRlZENhbGxiYWNrICYmIGNvbXBsZXRlZENhbGxiYWNrKGRlc2lyZWRGcmFtZXMgLSBkcm9wQ291bnRlciAvICgobm93IC0gc3RhcnQpIC8gbWlsbGlzZWNvbmRzUGVyU2Vjb25kKSwgaWQsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIHRvIGFwcGx5IGxldCdzIHVwZGF0ZSBvbWl0dGVkIHN0ZXBzIGluIG1lbW9yeS5cbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIGJyaW5nIGludGVybmFsIHN0YXRlIHZhcmlhYmxlcyB1cC10by1kYXRlIHdpdGggcHJvZ3Jlc3MgaW4gdGltZS5cbiAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgdmFyIGRyb3BwZWRGcmFtZXMgPSBNYXRoLnJvdW5kKChub3cgLSBsYXN0RnJhbWUpIC8gKG1pbGxpc2Vjb25kc1BlclNlY29uZCAvIGRlc2lyZWRGcmFtZXMpKSAtIDE7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgTWF0aC5taW4oZHJvcHBlZEZyYW1lcywgNCk7IGorKykge1xuICAgICAgICAgIHN0ZXAodHJ1ZSk7XG4gICAgICAgICAgZHJvcENvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJ1bm5pbmdbaWRdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tcHV0ZSBwZXJjZW50IHZhbHVlXG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgcGVyY2VudCA9IChub3cgLSBzdGFydCkgLyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRXhlY3V0ZSBzdGVwIGNhbGxiYWNrLCB0aGVuLi4uXG4gICAgICB2YXIgdmFsdWUgPSBlYXNpbmdNZXRob2QgPyBlYXNpbmdNZXRob2QocGVyY2VudCkgOiBwZXJjZW50O1xuICAgICAgaWYgKChzdGVwQ2FsbGJhY2sodmFsdWUsIG5vdywgcmVuZGVyKSA9PT0gZmFsc2UgfHwgcGVyY2VudCA9PT0gMSkgJiYgcmVuZGVyKSB7XG4gICAgICAgIHJ1bm5pbmdbaWRdID0gbnVsbDtcbiAgICAgICAgY29tcGxldGVkQ2FsbGJhY2sgJiYgY29tcGxldGVkQ2FsbGJhY2soZGVzaXJlZEZyYW1lcyAtIGRyb3BDb3VudGVyIC8gKChub3cgLSBzdGFydCkgLyBtaWxsaXNlY29uZHNQZXJTZWNvbmQpLCBpZCwgcGVyY2VudCA9PT0gMSB8fCBkdXJhdGlvbiA9PSBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyKSB7XG4gICAgICAgIGxhc3RGcmFtZSA9IG5vdztcbiAgICAgICAgY29yZS5lZmZlY3QuQW5pbWF0ZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCwgcm9vdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIE1hcmsgYXMgcnVubmluZ1xuICAgIHJ1bm5pbmdbaWRdID0gdHJ1ZTtcblxuICAgIC8vIEluaXQgZmlyc3Qgc3RlcFxuICAgIGNvcmUuZWZmZWN0LkFuaW1hdGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXAsIHJvb3QpO1xuXG4gICAgLy8gUmV0dXJuIHVuaXF1ZSBhbmltYXRpb24gSURcbiAgICByZXR1cm4gaWQ7XG4gIH1cbn07XG5cbi8qXG4gKiBTY3JvbGxlclxuICogaHR0cDovL2dpdGh1Yi5jb20venluZ2Evc2Nyb2xsZXJcbiAqXG4gKiBtb2RpZmllZCBieSB3YW5neWk3MDk5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFp5bmdhIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20venluZ2Evc2Nyb2xsZXIvbWFzdGVyL01JVC1MSUNFTlNFLnR4dFxuICpcbiAqIEJhc2VkIG9uIHRoZSB3b3JrIG9mOiBVbmlmeSBQcm9qZWN0ICh1bmlmeS1wcm9qZWN0Lm9yZylcbiAqIGh0dHA6Ly91bmlmeS1wcm9qZWN0Lm9yZ1xuICogQ29weXJpZ2h0IDIwMTEsIERldXRzY2hlIFRlbGVrb20gQUdcbiAqIExpY2Vuc2U6IE1JVCArIEFwYWNoZSAoVjIpXG4gKi9cbnZhciBhbmltYXRpbmdNZXRob2QgPSBudWxsO1xuXG52YXIgbm9BbmltYXRpbmdNZXRob2QgPSBudWxsO1xuXG5mdW5jdGlvbiBTY3JvbGxlcihjYWxsYmFjaywgb3B0aW9ucykge1xuICB0aGlzLl9fY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgLyoqIEVuYWJsZSBzY3JvbGxpbmcgb24geC1heGlzICovXG4gICAgc2Nyb2xsaW5nWDogdHJ1ZSxcblxuICAgIC8qKiBFbmFibGUgc2Nyb2xsaW5nIG9uIHktYXhpcyAqL1xuICAgIHNjcm9sbGluZ1k6IHRydWUsXG5cbiAgICAvKiogRW5hYmxlIGFuaW1hdGlvbnMgZm9yIGRlY2VsZXJhdGlvbiwgc25hcCBiYWNrLCB6b29taW5nIGFuZCBzY3JvbGxpbmcgKi9cbiAgICBhbmltYXRpbmc6IHRydWUsXG5cbiAgICAvKiogZHVyYXRpb24gZm9yIGFuaW1hdGlvbnMgdHJpZ2dlcmVkIGJ5IHNjcm9sbFRvL3pvb21UbyAqL1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAyNTAsXG5cbiAgICAvKiogRW5hYmxlIGJvdW5jaW5nIChjb250ZW50IGNhbiBiZSBzbG93bHkgbW92ZWQgb3V0c2lkZSBhbmQganVtcHMgYmFjayBhZnRlciByZWxlYXNpbmcpICovXG4gICAgYm91bmNpbmc6IHtcbiAgICAgIHRvcDogMTAwLFxuICAgICAgYm90dG9tOiAxMDAsXG4gICAgICBsZWZ0OiAxMDAsXG4gICAgICByaWdodDogMTAwXG4gICAgfSxcblxuICAgIC8qKiBFbmFibGUgbG9ja2luZyB0byB0aGUgbWFpbiBheGlzIGlmIHVzZXIgbW92ZXMgb25seSBzbGlnaHRseSBvbiBvbmUgb2YgdGhlbSBhdCBzdGFydCAqL1xuICAgIGxvY2tpbmc6IHRydWUsXG5cbiAgICAvKiogRW5hYmxlIHBhZ2luYXRpb24gbW9kZSAoc3dpdGNoaW5nIGJldHdlZW4gZnVsbCBwYWdlIGNvbnRlbnQgcGFuZXMpICovXG4gICAgcGFnaW5nOiBmYWxzZSxcblxuICAgIC8qKiBFbmFibGUgc25hcHBpbmcgb2YgY29udGVudCB0byBhIGNvbmZpZ3VyZWQgcGl4ZWwgZ3JpZCAqL1xuICAgIHNuYXBwaW5nOiBmYWxzZSxcblxuICAgIC8qKiBFbmFibGUgem9vbWluZyBvZiBjb250ZW50IHZpYSBBUEksIGZpbmdlcnMgYW5kIG1vdXNlIHdoZWVsICovXG4gICAgem9vbWluZzogZmFsc2UsXG5cbiAgICAvKiogTWluaW11bSB6b29tIGxldmVsICovXG4gICAgbWluWm9vbTogMC41LFxuXG4gICAgLyoqIE1heGltdW0gem9vbSBsZXZlbCAqL1xuICAgIG1heFpvb206IDMsXG5cbiAgICAvKiogTXVsdGlwbHkgb3IgZGVjcmVhc2Ugc2Nyb2xsaW5nIHNwZWVkICoqL1xuICAgIHNwZWVkTXVsdGlwbGllcjogMSxcblxuICAgIC8qKiBDYWxsYmFjayB0aGF0IGlzIGZpcmVkIG9uIHRoZSBsYXRlciBvZiB0b3VjaCBlbmQgb3IgZGVjZWxlcmF0aW9uIGVuZCxcbiAgICBwcm92aWRlZCB0aGF0IGFub3RoZXIgc2Nyb2xsaW5nIGFjdGlvbiBoYXMgbm90IGJlZ3VuLiBVc2VkIHRvIGtub3dcbiAgICB3aGVuIHRvIGZhZGUgb3V0IGEgc2Nyb2xsYmFyLiAqL1xuICAgIHNjcm9sbGluZ0NvbXBsZXRlOiBOT09QLFxuXG4gICAgYW5pbWF0aW5nRWFzaW5nOiAnZWFzZU91dEN1YmljJyxcblxuICAgIG5vQW5pbWF0aW5nRWFzaW5nOiAnZWFzZUluT3V0Q3ViaWMnLFxuXG4gICAgLyoqIFRoaXMgY29uZmlndXJlcyB0aGUgYW1vdW50IG9mIGNoYW5nZSBhcHBsaWVkIHRvIGRlY2VsZXJhdGlvbiB3aGVuIHJlYWNoaW5nIGJvdW5kYXJpZXMgICoqL1xuICAgIHBlbmV0cmF0aW9uRGVjZWxlcmF0aW9uOiAwLjAzLFxuXG4gICAgLyoqIFRoaXMgY29uZmlndXJlcyB0aGUgYW1vdW50IG9mIGNoYW5nZSBhcHBsaWVkIHRvIGFjY2VsZXJhdGlvbiB3aGVuIHJlYWNoaW5nIGJvdW5kYXJpZXMgICoqL1xuICAgIHBlbmV0cmF0aW9uQWNjZWxlcmF0aW9uOiAwLjA4XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGFuaW1hdGluZ01ldGhvZCA9IGNyZWF0ZUVhc2luZ0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5hbmltYXRpbmdFYXNpbmcsIGVhc2luZ1BhdHRlcm4pO1xuICBub0FuaW1hdGluZ01ldGhvZCA9IGNyZWF0ZUVhc2luZ0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5ub0FuaW1hdGluZ0Vhc2luZywgZWFzaW5nUGF0dGVybik7XG59XG5cbnZhciBtZW1iZXJzID0ge1xuICAvKlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgSU5URVJOQUwgRklFTERTIDo6IFNUQVRVU1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgKi9cblxuICAvKioge0Jvb2xlYW59IFdoZXRoZXIgb25seSBhIHNpbmdsZSBmaW5nZXIgaXMgdXNlZCBpbiB0b3VjaCBoYW5kbGluZyAqL1xuICBfX2lzU2luZ2xlVG91Y2g6IGZhbHNlLFxuXG4gIC8qKiB7Qm9vbGVhbn0gV2hldGhlciBhIHRvdWNoIGV2ZW50IHNlcXVlbmNlIGlzIGluIHByb2dyZXNzICovXG4gIF9faXNUcmFja2luZzogZmFsc2UsXG5cbiAgLyoqIHtCb29sZWFufSBXaGV0aGVyIGEgZGVjZWxlcmF0aW9uIGFuaW1hdGlvbiB3ZW50IHRvIGNvbXBsZXRpb24uICovXG4gIF9fZGlkRGVjZWxlcmF0aW9uQ29tcGxldGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiB7Qm9vbGVhbn0gV2hldGhlciBhIGdlc3R1cmUgem9vbS9yb3RhdGUgZXZlbnQgaXMgaW4gcHJvZ3Jlc3MuIEFjdGl2YXRlcyB3aGVuXG4gICAqIGEgZ2VzdHVyZXN0YXJ0IGV2ZW50IGhhcHBlbnMuIFRoaXMgaGFzIGhpZ2hlciBwcmlvcml0eSB0aGFuIGRyYWdnaW5nLlxuICAgKi9cbiAgX19pc0dlc3R1cmluZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHtCb29sZWFufSBXaGV0aGVyIHRoZSB1c2VyIGhhcyBtb3ZlZCBieSBzdWNoIGEgZGlzdGFuY2UgdGhhdCB3ZSBoYXZlIGVuYWJsZWRcbiAgICogZHJhZ2dpbmcgbW9kZS4gSGludDogSXQncyBvbmx5IGVuYWJsZWQgYWZ0ZXIgc29tZSBwaXhlbHMgb2YgbW92ZW1lbnQgdG9cbiAgICogbm90IGludGVycnVwdCB3aXRoIGNsaWNrcyBldGMuXG4gICAqL1xuICBfX2lzRHJhZ2dpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiB7Qm9vbGVhbn0gTm90IHRvdWNoaW5nIGFuZCBkcmFnZ2luZyBhbnltb3JlLCBhbmQgc21vb3RobHkgYW5pbWF0aW5nIHRoZVxuICAgKiB0b3VjaCBzZXF1ZW5jZSB1c2luZyBkZWNlbGVyYXRpb24uXG4gICAqL1xuICBfX2lzRGVjZWxlcmF0aW5nOiBmYWxzZSxcblxuICAvKipcbiAgICoge0Jvb2xlYW59IFNtb290aGx5IGFuaW1hdGluZyB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgY2hhbmdlXG4gICAqL1xuICBfX2lzQW5pbWF0aW5nOiBmYWxzZSxcblxuICAvKlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgSU5URVJOQUwgRklFTERTIDo6IERJTUVOU0lPTlNcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICovXG5cbiAgLyoqIHtJbnRlZ2VyfSBBdmFpbGFibGUgb3V0ZXIgbGVmdCBwb3NpdGlvbiAoZnJvbSBkb2N1bWVudCBwZXJzcGVjdGl2ZSkgKi9cbiAgX19jbGllbnRMZWZ0OiAwLFxuXG4gIC8qKiB7SW50ZWdlcn0gQXZhaWxhYmxlIG91dGVyIHRvcCBwb3NpdGlvbiAoZnJvbSBkb2N1bWVudCBwZXJzcGVjdGl2ZSkgKi9cbiAgX19jbGllbnRUb3A6IDAsXG5cbiAgLyoqIHtJbnRlZ2VyfSBBdmFpbGFibGUgb3V0ZXIgd2lkdGggKi9cbiAgX19jbGllbnRXaWR0aDogMCxcblxuICAvKioge0ludGVnZXJ9IEF2YWlsYWJsZSBvdXRlciBoZWlnaHQgKi9cbiAgX19jbGllbnRIZWlnaHQ6IDAsXG5cbiAgLyoqIHtJbnRlZ2VyfSBPdXRlciB3aWR0aCBvZiBjb250ZW50ICovXG4gIF9fY29udGVudFdpZHRoOiAwLFxuXG4gIC8qKiB7SW50ZWdlcn0gT3V0ZXIgaGVpZ2h0IG9mIGNvbnRlbnQgKi9cbiAgX19jb250ZW50SGVpZ2h0OiAwLFxuXG4gIC8qKiB7SW50ZWdlcn0gU25hcHBpbmcgd2lkdGggZm9yIGNvbnRlbnQgKi9cbiAgX19zbmFwV2lkdGg6IDEwMCxcblxuICAvKioge0ludGVnZXJ9IFNuYXBwaW5nIGhlaWdodCBmb3IgY29udGVudCAqL1xuICBfX3NuYXBIZWlnaHQ6IDEwMCxcblxuICAvKioge0ludGVnZXJ9IEhlaWdodCB0byBhc3NpZ24gdG8gcmVmcmVzaCBhcmVhICovXG4gIF9fcmVmcmVzaEhlaWdodDogbnVsbCxcbiAgLyoqIHtJbnRlZ2VyfSBIZWlnaHQgdG8gYXNzaWduIHRvIHJlZnJlc2ggYXJlYSAqL1xuICBfX2xvYWRIZWlnaHQ6IG51bGwsXG4gIC8qKiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcmVmcmVzaCBwcm9jZXNzIGlzIGVuYWJsZWQgd2hlbiB0aGUgZXZlbnQgaXMgcmVsZWFzZWQgbm93ICovXG4gIF9fcmVmcmVzaEFjdGl2ZTogZmFsc2UsXG5cbiAgLyoqIHtGdW5jdGlvbn0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiBhY3RpdmF0aW9uLiBUaGlzIGlzIGZvciBzaWduYWxsaW5nIHRoZSB1c2VyIGFib3V0IGEgcmVmcmVzaCBpcyBhYm91dCB0byBoYXBwZW4gd2hlbiBoZSByZWxlYXNlICovXG4gIF9fcmVmcmVzaEFjdGl2YXRlOiBudWxsLFxuXG4gIF9fcmVmcmVzaEJlZm9yZURlYWN0aXZhdGU6IG51bGwsXG5cbiAgLyoqIHtGdW5jdGlvbn0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiBkZWFjdGl2YXRpb24uIFRoaXMgaXMgZm9yIHNpZ25hbGxpbmcgdGhlIHVzZXIgYWJvdXQgdGhlIHJlZnJlc2ggYmVpbmcgY2FuY2VsbGVkICovXG4gIF9fcmVmcmVzaERlYWN0aXZhdGU6IG51bGwsXG5cbiAgLyoqIHtGdW5jdGlvbn0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB0byBzdGFydCB0aGUgYWN0dWFsIHJlZnJlc2guIENhbGwge0BsaW5rICNyZWZyZXNoRmluaXNofSB3aGVuIGRvbmUgKi9cbiAgX19yZWZyZXNoU3RhcnQ6IG51bGwsXG5cbiAgX19sb2FkQWN0aXZlOiBudWxsLFxuXG4gIF9fbG9hZEFjdGl2YXRlOiBudWxsLFxuXG4gIF9fbG9hZEJlZm9yZURlYWN0aXZhdGU6IG51bGwsXG5cbiAgX19sb2FkRGVhY3RpdmF0ZTogbnVsbCxcblxuICBfX2xvYWRTdGFydDogbnVsbCxcbiAgLyoqIHtOdW1iZXJ9IFpvb20gbGV2ZWwgKi9cbiAgX196b29tTGV2ZWw6IDEsXG5cbiAgLyoqIHtOdW1iZXJ9IFNjcm9sbCBwb3NpdGlvbiBvbiB4LWF4aXMgKi9cbiAgX19zY3JvbGxMZWZ0OiAwLFxuXG4gIC8qKiB7TnVtYmVyfSBTY3JvbGwgcG9zaXRpb24gb24geS1heGlzICovXG4gIF9fc2Nyb2xsVG9wOiAwLFxuXG4gIC8qKiB7SW50ZWdlcn0gTWF4aW11bSBhbGxvd2VkIHNjcm9sbCBwb3NpdGlvbiBvbiB4LWF4aXMgKi9cbiAgX19tYXhTY3JvbGxMZWZ0OiAwLFxuXG4gIC8qKiB7SW50ZWdlcn0gTWF4aW11bSBhbGxvd2VkIHNjcm9sbCBwb3NpdGlvbiBvbiB5LWF4aXMgKi9cbiAgX19tYXhTY3JvbGxUb3A6IDAsXG5cbiAgLyoge051bWJlcn0gU2NoZWR1bGVkIGxlZnQgcG9zaXRpb24gKGZpbmFsIHBvc2l0aW9uIHdoZW4gYW5pbWF0aW5nKSAqL1xuICBfX3NjaGVkdWxlZExlZnQ6IDAsXG5cbiAgLyoge051bWJlcn0gU2NoZWR1bGVkIHRvcCBwb3NpdGlvbiAoZmluYWwgcG9zaXRpb24gd2hlbiBhbmltYXRpbmcpICovXG4gIF9fc2NoZWR1bGVkVG9wOiAwLFxuXG4gIC8qIHtOdW1iZXJ9IFNjaGVkdWxlZCB6b29tIGxldmVsIChmaW5hbCBzY2FsZSB3aGVuIGFuaW1hdGluZykgKi9cbiAgX19zY2hlZHVsZWRab29tOiAwLFxuXG4gIC8qKlxuICAgKiBjdXJyZW50IHBhZ2VcbiAgICovXG4gIF9fY3VycmVudFBhZ2VYOiBudWxsLFxuXG4gIF9fY3VycmVudFBhZ2VZOiBudWxsLFxuXG4gIC8qKlxuICAgKiB0b3RhbCBwYWdlXG4gICAqL1xuICBfX3RvdGFsWFBhZ2U6IG51bGwsXG5cbiAgX190b3RhbFlQYWdlOiBudWxsLFxuICAvKlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgSU5URVJOQUwgRklFTERTIDo6IExBU1QgUE9TSVRJT05TXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAqL1xuICAvKiogd2hldGhlciB0aGUgc2Nyb2xsZXIgaXMgZGlzYWJsZWQgb3Igbm90ICovXG4gIF9fZGlzYWJsZTogZmFsc2UsXG4gIC8qKiB7TnVtYmVyfSBMZWZ0IHBvc2l0aW9uIG9mIGZpbmdlciBhdCBzdGFydCAqL1xuICBfX2xhc3RUb3VjaExlZnQ6IG51bGwsXG5cbiAgLyoqIHtOdW1iZXJ9IFRvcCBwb3NpdGlvbiBvZiBmaW5nZXIgYXQgc3RhcnQgKi9cbiAgX19sYXN0VG91Y2hUb3A6IG51bGwsXG5cbiAgLyoqIHtEYXRlfSBUaW1lc3RhbXAgb2YgbGFzdCBtb3ZlIG9mIGZpbmdlci4gVXNlZCB0byBsaW1pdCB0cmFja2luZyByYW5nZSBmb3IgZGVjZWxlcmF0aW9uIHNwZWVkLiAqL1xuICBfX2xhc3RUb3VjaE1vdmU6IG51bGwsXG5cbiAgLyoqIHtBcnJheX0gTGlzdCBvZiBwb3NpdGlvbnMsIHVzZXMgdGhyZWUgaW5kZXhlcyBmb3IgZWFjaCBzdGF0ZTogbGVmdCwgdG9wLCB0aW1lc3RhbXAgKi9cbiAgX19wb3NpdGlvbnM6IG51bGwsXG5cbiAgLypcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIElOVEVSTkFMIEZJRUxEUyA6OiBERUNFTEVSQVRJT04gU1VQUE9SVFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgKi9cblxuICAvKioge0ludGVnZXJ9IE1pbmltdW0gbGVmdCBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIGRlY2VsZXJhdGlvbiAqL1xuICBfX21pbkRlY2VsZXJhdGlvblNjcm9sbExlZnQ6IG51bGwsXG5cbiAgLyoqIHtJbnRlZ2VyfSBNaW5pbXVtIHRvcCBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIGRlY2VsZXJhdGlvbiAqL1xuICBfX21pbkRlY2VsZXJhdGlvblNjcm9sbFRvcDogbnVsbCxcblxuICAvKioge0ludGVnZXJ9IE1heGltdW0gbGVmdCBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIGRlY2VsZXJhdGlvbiAqL1xuICBfX21heERlY2VsZXJhdGlvblNjcm9sbExlZnQ6IG51bGwsXG5cbiAgLyoqIHtJbnRlZ2VyfSBNYXhpbXVtIHRvcCBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIGRlY2VsZXJhdGlvbiAqL1xuICBfX21heERlY2VsZXJhdGlvblNjcm9sbFRvcDogbnVsbCxcblxuICAvKioge051bWJlcn0gQ3VycmVudCBmYWN0b3IgdG8gbW9kaWZ5IGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uIHdpdGggb24gZXZlcnkgc3RlcCAqL1xuICBfX2RlY2VsZXJhdGlvblZlbG9jaXR5WDogbnVsbCxcblxuICAvKioge051bWJlcn0gQ3VycmVudCBmYWN0b3IgdG8gbW9kaWZ5IHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiB3aXRoIG9uIGV2ZXJ5IHN0ZXAgKi9cbiAgX19kZWNlbGVyYXRpb25WZWxvY2l0eVk6IG51bGwsXG5cbiAgLypcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFBVQkxJQyBBUElcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICovXG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNsaWVudCAob3V0ZXIpIGFuZCBjb250ZW50IChpbm5lcikgZWxlbWVudHMuXG4gICAqIFJlcXVpcmVzIHRoZSBhdmFpbGFibGUgc3BhY2UgZm9yIHRoZSBvdXRlciBlbGVtZW50IGFuZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgaW5uZXIgZWxlbWVudC5cbiAgICogQWxsIHZhbHVlcyB3aGljaCBhcmUgZmFsc3kgKG51bGwgb3IgemVybyBldGMuKSBhcmUgaWdub3JlZCBhbmQgdGhlIG9sZCB2YWx1ZSBpcyBrZXB0LlxuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50V2lkdGgge0ludGVnZXIgPyBudWxsfSBJbm5lciB3aWR0aCBvZiBvdXRlciBlbGVtZW50XG4gICAqIEBwYXJhbSBjbGllbnRIZWlnaHQge0ludGVnZXIgPyBudWxsfSBJbm5lciBoZWlnaHQgb2Ygb3V0ZXIgZWxlbWVudFxuICAgKiBAcGFyYW0gY29udGVudFdpZHRoIHtJbnRlZ2VyID8gbnVsbH0gT3V0ZXIgd2lkdGggb2YgaW5uZXIgZWxlbWVudFxuICAgKiBAcGFyYW0gY29udGVudEhlaWdodCB7SW50ZWdlciA/IG51bGx9IE91dGVyIGhlaWdodCBvZiBpbm5lciBlbGVtZW50XG4gICAqL1xuICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbiBzZXREaW1lbnNpb25zKGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQsIGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCwgYW5pbWF0ZSkge1xuICAgIHZhciBub1Njcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBPbmx5IHVwZGF0ZSB2YWx1ZXMgd2hpY2ggYXJlIGRlZmluZWRcbiAgICBpZiAoY2xpZW50V2lkdGggPT09ICtjbGllbnRXaWR0aCkge1xuICAgICAgc2VsZi5fX2NsaWVudFdpZHRoID0gY2xpZW50V2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGNsaWVudEhlaWdodCA9PT0gK2NsaWVudEhlaWdodCkge1xuICAgICAgc2VsZi5fX2NsaWVudEhlaWdodCA9IGNsaWVudEhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoY29udGVudFdpZHRoID09PSArY29udGVudFdpZHRoKSB7XG4gICAgICBzZWxmLl9fY29udGVudFdpZHRoID0gY29udGVudFdpZHRoO1xuICAgIH1cblxuICAgIGlmIChjb250ZW50SGVpZ2h0ID09PSArY29udGVudEhlaWdodCkge1xuICAgICAgc2VsZi5fX2NvbnRlbnRIZWlnaHQgPSBjb250ZW50SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFJlZnJlc2ggbWF4aW11bXNcbiAgICBzZWxmLl9fY29tcHV0ZVNjcm9sbE1heCgpO1xuXG4gICAgaWYgKCFub1Njcm9sbCkge1xuICAgICAgLy8gUmVmcmVzaCBzY3JvbGwgcG9zaXRpb25cbiAgICAgIHNlbGYuc2Nyb2xsVG8oc2VsZi5fX3Njcm9sbExlZnQsIHNlbGYuX19zY3JvbGxUb3AsIGFuaW1hdGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgY2xpZW50IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIGxlZnQge0ludGVnZXIgPyAwfSBMZWZ0IHBvc2l0aW9uIG9mIG91dGVyIGVsZW1lbnRcbiAgICogQHBhcmFtIHRvcCB7SW50ZWdlciA/IDB9IFRvcCBwb3NpdGlvbiBvZiBvdXRlciBlbGVtZW50XG4gICAqL1xuICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gc2V0UG9zaXRpb24obGVmdCwgdG9wKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi5fX2NsaWVudExlZnQgPSBsZWZ0IHx8IDA7XG4gICAgc2VsZi5fX2NsaWVudFRvcCA9IHRvcCB8fCAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHRoZSBzbmFwcGluZyAod2hlbiBzbmFwcGluZyBpcyBhY3RpdmUpXG4gICAqXG4gICAqIEBwYXJhbSB3aWR0aCB7SW50ZWdlcn0gU25hcHBpbmcgd2lkdGhcbiAgICogQHBhcmFtIGhlaWdodCB7SW50ZWdlcn0gU25hcHBpbmcgaGVpZ2h0XG4gICAqL1xuICBzZXRTbmFwU2l6ZTogZnVuY3Rpb24gc2V0U25hcFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHNlbGYuX19zbmFwV2lkdGggPSB3aWR0aDtcbiAgICBzZWxmLl9fc25hcEhlaWdodCA9IGhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogQWN0aXZhdGVzIHB1bGwtdG8tcmVmcmVzaC4gQSBzcGVjaWFsIHpvbmUgb24gdGhlIHRvcCBvZiB0aGUgbGlzdCB0byBzdGFydCBhIGxpc3QgcmVmcmVzaCB3aGVuZXZlclxuICAgKiB0aGUgdXNlciBldmVudCBpcyByZWxlYXNlZCBkdXJpbmcgdmlzaWJpbGl0eSBvZiB0aGlzIHpvbmUuIFRoaXMgd2FzIGludHJvZHVjZWQgYnkgc29tZSBhcHBzIG9uIGlPUyBsaWtlXG4gICAqIHRoZSBvZmZpY2lhbCBUd2l0dGVyIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIGhlaWdodCB7SW50ZWdlcn0gSGVpZ2h0IG9mIHB1bGwtdG8tcmVmcmVzaCB6b25lIG9uIHRvcCBvZiByZW5kZXJlZCBsaXN0XG4gICAqIEBwYXJhbSBhY3RpdmF0ZUNhbGxiYWNrIHtGdW5jdGlvbn0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiBhY3RpdmF0aW9uLiBUaGlzIGlzIGZvciBzaWduYWxsaW5nIHRoZSB1c2VyIGFib3V0IGEgcmVmcmVzaCBpcyBhYm91dCB0byBoYXBwZW4gd2hlbiBoZSByZWxlYXNlLlxuICAgKiBAcGFyYW0gZGVhY3RpdmF0ZUNhbGxiYWNrIHtGdW5jdGlvbn0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiBkZWFjdGl2YXRpb24uIFRoaXMgaXMgZm9yIHNpZ25hbGxpbmcgdGhlIHVzZXIgYWJvdXQgdGhlIHJlZnJlc2ggYmVpbmcgY2FuY2VsbGVkLlxuICAgKiBAcGFyYW0gc3RhcnRDYWxsYmFjayB7RnVuY3Rpb259IENhbGxiYWNrIHRvIGV4ZWN1dGUgdG8gc3RhcnQgdGhlIHJlYWwgYXN5bmMgcmVmcmVzaCBhY3Rpb24uIENhbGwge0BsaW5rICNmaW5pc2hQdWxsVG9SZWZyZXNofSBhZnRlciBmaW5pc2ggb2YgcmVmcmVzaC5cbiAgICovXG4gIGFjdGl2YXRlUHVsbFRvUmVmcmVzaDogZnVuY3Rpb24gYWN0aXZhdGVQdWxsVG9SZWZyZXNoKGhlaWdodCwgX3JlZikge1xuICAgIHZhciBhY3RpdmF0ZUNhbGxiYWNrID0gX3JlZi5hY3RpdmF0ZUNhbGxiYWNrLFxuICAgICAgICBkZWFjdGl2YXRlQ2FsbGJhY2sgPSBfcmVmLmRlYWN0aXZhdGVDYWxsYmFjayxcbiAgICAgICAgc3RhcnRDYWxsYmFjayA9IF9yZWYuc3RhcnRDYWxsYmFjayxcbiAgICAgICAgYmVmb3JlRGVhY3RpdmF0ZUNhbGxiYWNrID0gX3JlZi5iZWZvcmVEZWFjdGl2YXRlQ2FsbGJhY2ssXG4gICAgICAgIGJlZm9yZURlYWN0aXZlRW5kID0gX3JlZi5iZWZvcmVEZWFjdGl2ZUVuZDtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHNlbGYuX19yZWZyZXNoSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHNlbGYuX19yZWZyZXNoQWN0aXZhdGUgPSBhY3RpdmF0ZUNhbGxiYWNrO1xuICAgIHNlbGYuX19yZWZyZXNoQmVmb3JlRGVhY3RpdmF0ZSA9IGJlZm9yZURlYWN0aXZhdGVDYWxsYmFjaztcbiAgICBzZWxmLl9fcmVmcmVzaEJlZm9yZURlYWN0aXZlRW5kID0gYmVmb3JlRGVhY3RpdmVFbmQ7XG4gICAgc2VsZi5fX3JlZnJlc2hEZWFjdGl2YXRlID0gZGVhY3RpdmF0ZUNhbGxiYWNrO1xuICAgIHNlbGYuX19yZWZyZXNoU3RhcnQgPSBzdGFydENhbGxiYWNrO1xuICB9LFxuICBhY3RpdmF0ZVB1c2hUb0xvYWQ6IGZ1bmN0aW9uIGFjdGl2YXRlUHVzaFRvTG9hZChoZWlnaHQsIF9yZWYyKSB7XG4gICAgdmFyIGFjdGl2YXRlQ2FsbGJhY2sgPSBfcmVmMi5hY3RpdmF0ZUNhbGxiYWNrLFxuICAgICAgICBkZWFjdGl2YXRlQ2FsbGJhY2sgPSBfcmVmMi5kZWFjdGl2YXRlQ2FsbGJhY2ssXG4gICAgICAgIHN0YXJ0Q2FsbGJhY2sgPSBfcmVmMi5zdGFydENhbGxiYWNrLFxuICAgICAgICBiZWZvcmVEZWFjdGl2YXRlQ2FsbGJhY2sgPSBfcmVmMi5iZWZvcmVEZWFjdGl2YXRlQ2FsbGJhY2ssXG4gICAgICAgIGJlZm9yZURlYWN0aXZlRW5kID0gX3JlZjIuYmVmb3JlRGVhY3RpdmVFbmQ7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLl9fbG9hZEhlaWdodCA9IGhlaWdodDtcbiAgICBzZWxmLl9fbG9hZEFjdGl2YXRlID0gYWN0aXZhdGVDYWxsYmFjaztcbiAgICBzZWxmLl9fbG9hZEJlZm9yZURlYWN0aXZhdGUgPSBiZWZvcmVEZWFjdGl2YXRlQ2FsbGJhY2s7XG4gICAgc2VsZi5fX2xvYWRCZWZvcmVEZWFjdGl2ZUVuZCA9IGJlZm9yZURlYWN0aXZlRW5kO1xuICAgIHNlbGYuX19sb2FkRGVhY3RpdmF0ZSA9IGRlYWN0aXZhdGVDYWxsYmFjaztcbiAgICBzZWxmLl9fbG9hZFN0YXJ0ID0gc3RhcnRDYWxsYmFjaztcbiAgfSxcblxuICAvKipcbiAgICogU3RhcnRzIHB1bGwtdG8tcmVmcmVzaCBtYW51YWxseS5cbiAgICovXG4gIHRyaWdnZXJSZWZyZXNoT3JMb2FkOiBmdW5jdGlvbiB0cmlnZ2VyUmVmcmVzaE9yTG9hZCgpIHtcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3JlZnJlc2gnO1xuXG4gICAgdmFyIHdhc0RlY2VsZXJhdGluZyA9IHRoaXMuX19pc0RlY2VsZXJhdGluZztcbiAgICBpZiAod2FzRGVjZWxlcmF0aW5nKSB7XG4gICAgICBjb3JlLmVmZmVjdC5BbmltYXRlLnN0b3Aod2FzRGVjZWxlcmF0aW5nKTtcbiAgICAgIHRoaXMuX19pc0RlY2VsZXJhdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBVc2UgcHVibGlzaCBpbnN0ZWFkIG9mIHNjcm9sbFRvIHRvIGFsbG93IHNjcm9sbGluZyB0byBvdXQgb2YgYm91bmRhcnkgcG9zaXRpb25cbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIG5vcm1hbGl6ZSBzY3JvbGxMZWZ0LCB6b29tTGV2ZWwsIGV0Yy4gaGVyZSBiZWNhdXNlIHdlIG9ubHkgeS1zY3JvbGxpbmcgd2hlbiBwdWxsLXRvLXJlZnJlc2ggaXMgZW5hYmxlZFxuICAgIGlmICh0eXBlID09ICdyZWZyZXNoJykge1xuICAgICAgaWYgKHRoaXMuX19yZWZyZXNoQWN0aXZlIHx8IHRoaXMuX19yZWZyZXNoQmVmb3JlRGVhY3RpdmVTdGFydGVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX19wdWJsaXNoKHRoaXMuX19zY3JvbGxMZWZ0LCAtdGhpcy5fX3JlZnJlc2hIZWlnaHQsIHRoaXMuX196b29tTGV2ZWwsIHRydWUpO1xuICAgICAgaWYgKHRoaXMuX19yZWZyZXNoU3RhcnQpIHtcbiAgICAgICAgdGhpcy5fX3JlZnJlc2hTdGFydCgpO1xuICAgICAgICB0aGlzLl9fcmVmcmVzaEFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdsb2FkJykge1xuICAgICAgaWYgKHRoaXMuX19sb2FkQWN0aXZlIHx8IHRoaXMuX19sb2FkQmVmb3JlRGVhY3RpdmVTdGFydGVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX19wdWJsaXNoKHRoaXMuX19zY3JvbGxMZWZ0LCB0aGlzLl9fbWF4U2Nyb2xsVG9wICsgdGhpcy5fX2xvYWRIZWlnaHQsIHRoaXMuX196b29tTGV2ZWwsIHRydWUpO1xuICAgICAgaWYgKHRoaXMuX19sb2FkU3RhcnQpIHtcbiAgICAgICAgdGhpcy5fX2xvYWRTdGFydCgpO1xuICAgICAgICB0aGlzLl9fbG9hZEFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaWduYWxpemVzIHRoYXQgcHVsbC10by1yZWZyZXNoIGlzIGZpbmlzaGVkLlxuICAgKi9cbiAgZmluaXNoUmVmcmVzaE9yTG9hZDogZnVuY3Rpb24gZmluaXNoUmVmcmVzaE9yTG9hZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoc2VsZi5fX3JlZnJlc2hBY3RpdmUpIHtcbiAgICAgIHNlbGYuX19yZWZyZXNoQWN0aXZlID0gZmFsc2U7XG4gICAgICB2YXIgZW5kUmVmcmVzaEFjdGl2ZSA9IGZ1bmN0aW9uIGVuZFJlZnJlc2hBY3RpdmUoKSB7XG4gICAgICAgIGlmIChzZWxmLl9fcmVmcmVzaEJlZm9yZURlYWN0aXZlRW5kKSB7XG4gICAgICAgICAgc2VsZi5fX3JlZnJlc2hCZWZvcmVEZWFjdGl2ZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX19yZWZyZXNoQmVmb3JlRGVhY3RpdmVTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5zY3JvbGxUbyhzZWxmLl9fc2Nyb2xsTGVmdCwgc2VsZi5fX3Njcm9sbFRvcCwgdHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VsZi5fX3JlZnJlc2hCZWZvcmVEZWFjdGl2YXRlKSB7XG4gICAgICAgIHNlbGYuX19yZWZyZXNoQmVmb3JlRGVhY3RpdmF0ZShlbmRSZWZyZXNoQWN0aXZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFJlZnJlc2hBY3RpdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fX2xvYWRBY3RpdmUpIHtcbiAgICAgIHNlbGYuX19sb2FkQWN0aXZlID0gZmFsc2U7XG4gICAgICB2YXIgZW5kTG9hZEFjdGl2ZSA9IGZ1bmN0aW9uIGVuZExvYWRBY3RpdmUoKSB7XG4gICAgICAgIGlmIChzZWxmLl9fbG9hZEJlZm9yZURlYWN0aXZlRW5kKSB7XG4gICAgICAgICAgc2VsZi5fX2xvYWRCZWZvcmVEZWFjdGl2ZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX19sb2FkQmVmb3JlRGVhY3RpdmVTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5zY3JvbGxUbyhzZWxmLl9fc2Nyb2xsTGVmdCwgc2VsZi5fX3Njcm9sbFRvcCwgdHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VsZi5fX2xvYWRCZWZvcmVEZWFjdGl2YXRlKSB7XG4gICAgICAgIHNlbGYuX19sb2FkQmVmb3JlRGVhY3RpdmF0ZShlbmRMb2FkQWN0aXZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZExvYWRBY3RpdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjcm9sbCBwb3NpdGlvbiBhbmQgem9vbWluZyB2YWx1ZXNcbiAgICpcbiAgICogQHJldHVybiB7TWFwfSBgbGVmdGAgYW5kIGB0b3BgIHNjcm9sbCBwb3NpdGlvbiBhbmQgYHpvb21gIGxldmVsXG4gICAqL1xuICBnZXRWYWx1ZXM6IGZ1bmN0aW9uIGdldFZhbHVlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogc2VsZi5fX3Njcm9sbExlZnQsXG4gICAgICB0b3A6IHNlbGYuX19zY3JvbGxUb3AsXG4gICAgICB6b29tOiBzZWxmLl9fem9vbUxldmVsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBzY3JvbGwgdmFsdWVzXG4gICAqXG4gICAqIEByZXR1cm4ge01hcH0gYGxlZnRgIGFuZCBgdG9wYCBtYXhpbXVtIHNjcm9sbCB2YWx1ZXNcbiAgICovXG4gIGdldFNjcm9sbE1heDogZnVuY3Rpb24gZ2V0U2Nyb2xsTWF4KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBzZWxmLl9fbWF4U2Nyb2xsTGVmdCxcbiAgICAgIHRvcDogc2VsZi5fX21heFNjcm9sbFRvcFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFpvb21zIHRvIHRoZSBnaXZlbiBsZXZlbC4gU3VwcG9ydHMgb3B0aW9uYWwgYW5pbWF0aW9uLiBab29tc1xuICAgKiB0aGUgY2VudGVyIHdoZW4gbm8gY29vcmRpbmF0ZXMgYXJlIGdpdmVuLlxuICAgKlxuICAgKiBAcGFyYW0gbGV2ZWwge051bWJlcn0gTGV2ZWwgdG8gem9vbSB0b1xuICAgKiBAcGFyYW0gYW5pbWF0ZSB7Qm9vbGVhbiA/IGZhbHNlfSBXaGV0aGVyIHRvIHVzZSBhbmltYXRpb25cbiAgICogQHBhcmFtIG9yaWdpbkxlZnQge051bWJlciA/IG51bGx9IFpvb20gaW4gYXQgZ2l2ZW4gbGVmdCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSBvcmlnaW5Ub3Age051bWJlciA/IG51bGx9IFpvb20gaW4gYXQgZ2l2ZW4gdG9wIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbiA/IG51bGx9IEEgY2FsbGJhY2sgdGhhdCBnZXRzIGZpcmVkIHdoZW4gdGhlIHpvb20gaXMgY29tcGxldGUuXG4gICAqL1xuICB6b29tVG86IGZ1bmN0aW9uIHpvb21UbyhsZXZlbCwgYW5pbWF0ZSwgb3JpZ2luTGVmdCwgb3JpZ2luVG9wLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghc2VsZi5vcHRpb25zLnpvb21pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWm9vbWluZyBpcyBub3QgZW5hYmxlZCEnKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgY2FsbGJhY2sgaWYgZXhpc3RzXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBzZWxmLl9fem9vbUNvbXBsZXRlID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgLy8gU3RvcCBkZWNlbGVyYXRpb25cbiAgICBpZiAoc2VsZi5fX2lzRGVjZWxlcmF0aW5nKSB7XG4gICAgICBjb3JlLmVmZmVjdC5BbmltYXRlLnN0b3Aoc2VsZi5fX2lzRGVjZWxlcmF0aW5nKTtcbiAgICAgIHNlbGYuX19pc0RlY2VsZXJhdGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvbGRMZXZlbCA9IHNlbGYuX196b29tTGV2ZWw7XG5cbiAgICAvLyBOb3JtYWxpemUgaW5wdXQgb3JpZ2luIHRvIGNlbnRlciBvZiB2aWV3cG9ydCBpZiBub3QgZGVmaW5lZFxuICAgIGlmIChvcmlnaW5MZWZ0ID09IG51bGwpIHtcbiAgICAgIG9yaWdpbkxlZnQgPSBzZWxmLl9fY2xpZW50V2lkdGggLyAyO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW5Ub3AgPT0gbnVsbCkge1xuICAgICAgb3JpZ2luVG9wID0gc2VsZi5fX2NsaWVudEhlaWdodCAvIDI7XG4gICAgfVxuXG4gICAgLy8gTGltaXQgbGV2ZWwgYWNjb3JkaW5nIHRvIGNvbmZpZ3VyYXRpb25cbiAgICBsZXZlbCA9IE1hdGgubWF4KE1hdGgubWluKGxldmVsLCBzZWxmLm9wdGlvbnMubWF4Wm9vbSksIHNlbGYub3B0aW9ucy5taW5ab29tKTtcblxuICAgIC8vIFJlY29tcHV0ZSBtYXhpbXVtIHZhbHVlcyB3aGlsZSB0ZW1wb3JhcnkgdHdlYWtpbmcgbWF4aW11bSBzY3JvbGwgcmFuZ2VzXG4gICAgc2VsZi5fX2NvbXB1dGVTY3JvbGxNYXgobGV2ZWwpO1xuXG4gICAgLy8gUmVjb21wdXRlIGxlZnQgYW5kIHRvcCBjb29yZGluYXRlcyBiYXNlZCBvbiBuZXcgem9vbSBsZXZlbFxuICAgIHZhciBsZWZ0ID0gKG9yaWdpbkxlZnQgKyBzZWxmLl9fc2Nyb2xsTGVmdCkgKiBsZXZlbCAvIG9sZExldmVsIC0gb3JpZ2luTGVmdDtcbiAgICB2YXIgdG9wID0gKG9yaWdpblRvcCArIHNlbGYuX19zY3JvbGxUb3ApICogbGV2ZWwgLyBvbGRMZXZlbCAtIG9yaWdpblRvcDtcblxuICAgIC8vIExpbWl0IHgtYXhpc1xuICAgIGlmIChsZWZ0ID4gc2VsZi5fX21heFNjcm9sbExlZnQpIHtcbiAgICAgIGxlZnQgPSBzZWxmLl9fbWF4U2Nyb2xsTGVmdDtcbiAgICB9IGVsc2UgaWYgKGxlZnQgPCAwKSB7XG4gICAgICBsZWZ0ID0gMDtcbiAgICB9XG5cbiAgICAvLyBMaW1pdCB5LWF4aXNcbiAgICBpZiAodG9wID4gc2VsZi5fX21heFNjcm9sbFRvcCkge1xuICAgICAgdG9wID0gc2VsZi5fX21heFNjcm9sbFRvcDtcbiAgICB9IGVsc2UgaWYgKHRvcCA8IDApIHtcbiAgICAgIHRvcCA9IDA7XG4gICAgfVxuXG4gICAgLy8gUHVzaCB2YWx1ZXMgb3V0XG4gICAgc2VsZi5fX3B1Ymxpc2gobGVmdCwgdG9wLCBsZXZlbCwgYW5pbWF0ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFpvb21zIHRoZSBjb250ZW50IGJ5IHRoZSBnaXZlbiBmYWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBmYWN0b3Ige051bWJlcn0gWm9vbSBieSBnaXZlbiBmYWN0b3JcbiAgICogQHBhcmFtIGFuaW1hdGUge0Jvb2xlYW4gPyBmYWxzZX0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uXG4gICAqIEBwYXJhbSBvcmlnaW5MZWZ0IHtOdW1iZXIgPyAwfSBab29tIGluIGF0IGdpdmVuIGxlZnQgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0gb3JpZ2luVG9wIHtOdW1iZXIgPyAwfSBab29tIGluIGF0IGdpdmVuIHRvcCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb24gPyBudWxsfSBBIGNhbGxiYWNrIHRoYXQgZ2V0cyBmaXJlZCB3aGVuIHRoZSB6b29tIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgem9vbUJ5OiBmdW5jdGlvbiB6b29tQnkoZmFjdG9yLCBhbmltYXRlLCBvcmlnaW5MZWZ0LCBvcmlnaW5Ub3AsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi56b29tVG8oc2VsZi5fX3pvb21MZXZlbCAqIGZhY3RvciwgYW5pbWF0ZSwgb3JpZ2luTGVmdCwgb3JpZ2luVG9wLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNjcm9sbHMgdG8gdGhlIGdpdmVuIHBvc2l0aW9uLiBSZXNwZWN0IGxpbWl0YXRpb25zIGFuZCBzbmFwcGluZyBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0gbGVmdCB7TnVtYmVyP251bGx9IEhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uLCBrZWVwcyBjdXJyZW50IGlmIHZhbHVlIGlzIDxjb2RlPm51bGw8L2NvZGU+XG4gICAqIEBwYXJhbSB0b3Age051bWJlcj9udWxsfSBWZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24sIGtlZXBzIGN1cnJlbnQgaWYgdmFsdWUgaXMgPGNvZGU+bnVsbDwvY29kZT5cbiAgICogQHBhcmFtIGFuaW1hdGUge0Jvb2xlYW4/ZmFsc2V9IFdoZXRoZXIgdGhlIHNjcm9sbGluZyBzaG91bGQgaGFwcGVuIHVzaW5nIGFuIGFuaW1hdGlvblxuICAgKiBAcGFyYW0gem9vbSB7TnVtYmVyP251bGx9IFpvb20gbGV2ZWwgdG8gZ28gdG9cbiAgICovXG4gIHNjcm9sbFRvOiBmdW5jdGlvbiBzY3JvbGxUbyhsZWZ0LCB0b3AsIGFuaW1hdGUsIHpvb20sIGZvcmNlLCBzcGVlZCwgZWFzaW5nKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCBkZWNlbGVyYXRpb25cbiAgICBpZiAoc2VsZi5fX2lzRGVjZWxlcmF0aW5nKSB7XG4gICAgICBjb3JlLmVmZmVjdC5BbmltYXRlLnN0b3Aoc2VsZi5fX2lzRGVjZWxlcmF0aW5nKTtcbiAgICAgIHNlbGYuX19pc0RlY2VsZXJhdGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENvcnJlY3QgY29vcmRpbmF0ZXMgYmFzZWQgb24gbmV3IHpvb20gbGV2ZWxcbiAgICBpZiAoem9vbSAhPSBudWxsICYmIHpvb20gIT09IHNlbGYuX196b29tTGV2ZWwpIHtcbiAgICAgIGlmICghc2VsZi5vcHRpb25zLnpvb21pbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdab29taW5nIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgfVxuXG4gICAgICBsZWZ0ICo9IHpvb207XG4gICAgICB0b3AgKj0gem9vbTtcblxuICAgICAgLy8gUmVjb21wdXRlIG1heGltdW0gdmFsdWVzIHdoaWxlIHRlbXBvcmFyeSB0d2Vha2luZyBtYXhpbXVtIHNjcm9sbCByYW5nZXNcbiAgICAgIHNlbGYuX19jb21wdXRlU2Nyb2xsTWF4KHpvb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBLZWVwIHpvb20gd2hlbiBub3QgZGVmaW5lZFxuICAgICAgem9vbSA9IHNlbGYuX196b29tTGV2ZWw7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuc2Nyb2xsaW5nWCAmJiAhZm9yY2UpIHtcbiAgICAgIGxlZnQgPSBzZWxmLl9fc2Nyb2xsTGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlbGYub3B0aW9ucy5wYWdpbmcpIHtcbiAgICAgICAgbGVmdCA9IE1hdGgucm91bmQobGVmdCAvIHNlbGYuX19jbGllbnRXaWR0aCkgKiBzZWxmLl9fY2xpZW50V2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYub3B0aW9ucy5zbmFwcGluZykge1xuICAgICAgICBsZWZ0ID0gTWF0aC5yb3VuZChsZWZ0IC8gc2VsZi5fX3NuYXBXaWR0aCkgKiBzZWxmLl9fc25hcFdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2VsZi5vcHRpb25zLnNjcm9sbGluZ1kgJiYgIWZvcmNlKSB7XG4gICAgICB0b3AgPSBzZWxmLl9fc2Nyb2xsVG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLnBhZ2luZykge1xuICAgICAgICB0b3AgPSBNYXRoLnJvdW5kKHRvcCAvIHNlbGYuX19jbGllbnRIZWlnaHQpICogc2VsZi5fX2NsaWVudEhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5vcHRpb25zLnNuYXBwaW5nKSB7XG4gICAgICAgIHRvcCA9IE1hdGgucm91bmQodG9wIC8gc2VsZi5fX3NuYXBIZWlnaHQpICogc2VsZi5fX3NuYXBIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgLy8gTGltaXQgZm9yIGFsbG93ZWQgcmFuZ2VzXG4gICAgICBsZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4oc2VsZi5fX21heFNjcm9sbExlZnQsIGxlZnQpLCAwKTtcbiAgICAgIHRvcCA9IE1hdGgubWF4KE1hdGgubWluKHNlbGYuX19tYXhTY3JvbGxUb3AsIHRvcCksIDApO1xuICAgIH1cblxuICAgIC8vIERvbid0IGFuaW1hdGUgd2hlbiBubyBjaGFuZ2UgZGV0ZWN0ZWQsIHN0aWxsIGNhbGwgcHVibGlzaCB0byBtYWtlIHN1cmVcbiAgICAvLyB0aGF0IHJlbmRlcmVkIHBvc2l0aW9uIGlzIHJlYWxseSBpbi1zeW5jIHdpdGggaW50ZXJuYWwgZGF0YVxuICAgIGlmIChsZWZ0ID09PSBzZWxmLl9fc2Nyb2xsTGVmdCAmJiB0b3AgPT09IHNlbGYuX19zY3JvbGxUb3ApIHtcbiAgICAgIGFuaW1hdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaXNoIG5ldyB2YWx1ZXNcbiAgICBpZiAoIXNlbGYuX19pc1RyYWNraW5nKSB7XG4gICAgICBzZWxmLl9fcHVibGlzaChsZWZ0LCB0b3AsIHpvb20sIGFuaW1hdGUsIHNwZWVkLCBlYXNpbmcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2Nyb2xsIGJ5IHRoZSBnaXZlbiBvZmZzZXRcbiAgICpcbiAgICogQHBhcmFtIGxlZnQge051bWJlciA/IDB9IFNjcm9sbCB4LWF4aXMgYnkgZ2l2ZW4gb2Zmc2V0XG4gICAqIEBwYXJhbSB0b3Age051bWJlciA/IDB9IFNjcm9sbCB4LWF4aXMgYnkgZ2l2ZW4gb2Zmc2V0XG4gICAqIEBwYXJhbSBhbmltYXRlIHtCb29sZWFuID8gZmFsc2V9IFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgZ2l2ZW4gY2hhbmdlXG4gICAqL1xuICBzY3JvbGxCeTogZnVuY3Rpb24gc2Nyb2xsQnkobGVmdCwgdG9wLCBhbmltYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXJ0TGVmdCA9IHNlbGYuX19pc0FuaW1hdGluZyA/IHNlbGYuX19zY2hlZHVsZWRMZWZ0IDogc2VsZi5fX3Njcm9sbExlZnQ7XG4gICAgdmFyIHN0YXJ0VG9wID0gc2VsZi5fX2lzQW5pbWF0aW5nID8gc2VsZi5fX3NjaGVkdWxlZFRvcCA6IHNlbGYuX19zY3JvbGxUb3A7XG5cbiAgICBzZWxmLnNjcm9sbFRvKHN0YXJ0TGVmdCArIChsZWZ0IHx8IDApLCBzdGFydFRvcCArICh0b3AgfHwgMCksIGFuaW1hdGUpO1xuICB9LFxuICBnZXRDdXJyZW50UGFnZTogZnVuY3Rpb24gZ2V0Q3VycmVudFBhZ2UoKSB7XG4gICAgdGhpcy5fX2NvbXB1dGVQYWdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMuX19jdXJyZW50UGFnZVgsXG4gICAgICB5OiB0aGlzLl9fY3VycmVudFBhZ2VZXG4gICAgfTtcbiAgfSxcbiAgZ29Ub1BhZ2U6IGZ1bmN0aW9uIGdvVG9QYWdlKF9yZWYzLCBhbmltYXRlKSB7XG4gICAgdmFyIHggPSBfcmVmMy54LFxuICAgICAgICB5ID0gX3JlZjMueTtcblxuICAgIGlmIChpc05hTih4KSkge1xuICAgICAgeCA9IDE7XG4gICAgfVxuICAgIGlmIChpc05hTih5KSkge1xuICAgICAgeSA9IDE7XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsVG8oKHggLSAxKSAqIHRoaXMuX19jbGllbnRXaWR0aCwgKHkgLSAxKSAqIHRoaXMuX19jbGllbnRIZWlnaHQsIGFuaW1hdGUpO1xuICB9LFxuXG5cbiAgLypcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIEVWRU5UIENBTExCQUNLU1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgKi9cblxuICAvKipcbiAgICogTW91c2Ugd2hlZWwgaGFuZGxlciBmb3Igem9vbWluZyBzdXBwb3J0XG4gICAqL1xuICBkb01vdXNlWm9vbTogZnVuY3Rpb24gZG9Nb3VzZVpvb20od2hlZWxEZWx0YSwgdGltZVN0YW1wLCBwYWdlWCwgcGFnZVkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoYW5nZSA9IHdoZWVsRGVsdGEgPiAwID8gMC45NyA6IDEuMDM7XG5cbiAgICByZXR1cm4gc2VsZi56b29tVG8oc2VsZi5fX3pvb21MZXZlbCAqIGNoYW5nZSwgZmFsc2UsIHBhZ2VYIC0gc2VsZi5fX2NsaWVudExlZnQsIHBhZ2VZIC0gc2VsZi5fX2NsaWVudFRvcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNoIHN0YXJ0IGhhbmRsZXIgZm9yIHNjcm9sbGluZyBzdXBwb3J0XG4gICAqL1xuICBkb1RvdWNoU3RhcnQ6IGZ1bmN0aW9uIGRvVG91Y2hTdGFydCh0b3VjaGVzLCB0aW1lU3RhbXApIHtcbiAgICAvLyBBcnJheS1saWtlIGNoZWNrIGlzIGVub3VnaCBoZXJlXG4gICAgaWYgKHRvdWNoZXMubGVuZ3RoID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b3VjaCBsaXN0OiAnICsgdG91Y2hlcyk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVTdGFtcCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHRpbWVTdGFtcCA9IHRpbWVTdGFtcC52YWx1ZU9mKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGltZVN0YW1wICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRpbWVzdGFtcCB2YWx1ZTogJyArIHRpbWVTdGFtcCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gUmVzZXQgaW50ZXJydXB0ZWRBbmltYXRpb24gZmxhZ1xuICAgIHNlbGYuX19pbnRlcnJ1cHRlZEFuaW1hdGlvbiA9IHRydWU7XG5cbiAgICAvLyBTdG9wIGRlY2VsZXJhdGlvblxuICAgIGlmIChzZWxmLl9faXNEZWNlbGVyYXRpbmcpIHtcbiAgICAgIGNvcmUuZWZmZWN0LkFuaW1hdGUuc3RvcChzZWxmLl9faXNEZWNlbGVyYXRpbmcpO1xuICAgICAgc2VsZi5fX2lzRGVjZWxlcmF0aW5nID0gZmFsc2U7XG4gICAgICBzZWxmLl9faW50ZXJydXB0ZWRBbmltYXRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFN0b3AgYW5pbWF0aW9uXG4gICAgaWYgKHNlbGYuX19pc0FuaW1hdGluZykge1xuICAgICAgY29yZS5lZmZlY3QuQW5pbWF0ZS5zdG9wKHNlbGYuX19pc0FuaW1hdGluZyk7XG4gICAgICBzZWxmLl9faXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYuX19pbnRlcnJ1cHRlZEFuaW1hdGlvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVXNlIGNlbnRlciBwb2ludCB3aGVuIGRlYWxpbmcgd2l0aCB0d28gZmluZ2Vyc1xuICAgIHZhciBjdXJyZW50VG91Y2hMZWZ0LCBjdXJyZW50VG91Y2hUb3A7XG4gICAgdmFyIGlzU2luZ2xlVG91Y2ggPSB0b3VjaGVzLmxlbmd0aCA9PT0gMTtcbiAgICBpZiAoaXNTaW5nbGVUb3VjaCkge1xuICAgICAgY3VycmVudFRvdWNoTGVmdCA9IHRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICBjdXJyZW50VG91Y2hUb3AgPSB0b3VjaGVzWzBdLnBhZ2VZO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50VG91Y2hMZWZ0ID0gTWF0aC5hYnModG91Y2hlc1swXS5wYWdlWCArIHRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgIGN1cnJlbnRUb3VjaFRvcCA9IE1hdGguYWJzKHRvdWNoZXNbMF0ucGFnZVkgKyB0b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgaW5pdGlhbCBwb3NpdGlvbnNcbiAgICBzZWxmLl9faW5pdGlhbFRvdWNoTGVmdCA9IGN1cnJlbnRUb3VjaExlZnQ7XG4gICAgc2VsZi5fX2luaXRpYWxUb3VjaFRvcCA9IGN1cnJlbnRUb3VjaFRvcDtcblxuICAgIC8vIFN0b3JlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgIHNlbGYuX196b29tTGV2ZWxTdGFydCA9IHNlbGYuX196b29tTGV2ZWw7XG5cbiAgICAvLyBTdG9yZSBpbml0aWFsIHRvdWNoIHBvc2l0aW9uc1xuICAgIHNlbGYuX19sYXN0VG91Y2hMZWZ0ID0gY3VycmVudFRvdWNoTGVmdDtcbiAgICBzZWxmLl9fbGFzdFRvdWNoVG9wID0gY3VycmVudFRvdWNoVG9wO1xuXG4gICAgLy8gU3RvcmUgaW5pdGlhbCBtb3ZlIHRpbWUgc3RhbXBcbiAgICBzZWxmLl9fbGFzdFRvdWNoTW92ZSA9IHRpbWVTdGFtcDtcblxuICAgIC8vIFJlc2V0IGluaXRpYWwgc2NhbGVcbiAgICBzZWxmLl9fbGFzdFNjYWxlID0gMTtcblxuICAgIC8vIFJlc2V0IGxvY2tpbmcgZmxhZ3NcbiAgICBzZWxmLl9fZW5hYmxlU2Nyb2xsWCA9ICFpc1NpbmdsZVRvdWNoICYmIHNlbGYub3B0aW9ucy5zY3JvbGxpbmdYO1xuICAgIHNlbGYuX19lbmFibGVTY3JvbGxZID0gIWlzU2luZ2xlVG91Y2ggJiYgc2VsZi5vcHRpb25zLnNjcm9sbGluZ1k7XG5cbiAgICAvLyBSZXNldCB0cmFja2luZyBmbGFnXG4gICAgc2VsZi5fX2lzVHJhY2tpbmcgPSB0cnVlO1xuXG4gICAgLy8gUmVzZXQgZGVjZWxlcmF0aW9uIGNvbXBsZXRlIGZsYWdcbiAgICBzZWxmLl9fZGlkRGVjZWxlcmF0aW9uQ29tcGxldGUgPSBmYWxzZTtcblxuICAgIC8vIERyYWdnaW5nIHN0YXJ0cyBkaXJlY3RseSB3aXRoIHR3byBmaW5nZXJzLCBvdGhlcndpc2UgbGF6eSB3aXRoIGFuIG9mZnNldFxuICAgIHNlbGYuX19pc0RyYWdnaW5nID0gIWlzU2luZ2xlVG91Y2g7XG5cbiAgICAvLyBTb21lIGZlYXR1cmVzIGFyZSAgaW4gbXVsdGkgdG91Y2ggc2NlbmFyaW9zXG4gICAgc2VsZi5fX2lzU2luZ2xlVG91Y2ggPSBpc1NpbmdsZVRvdWNoO1xuXG4gICAgLy8gQ2xlYXJpbmcgZGF0YSBzdHJ1Y3R1cmVcbiAgICBzZWxmLl9fcG9zaXRpb25zID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNoIG1vdmUgaGFuZGxlciBmb3Igc2Nyb2xsaW5nIHN1cHBvcnRcbiAgICovXG4gIGRvVG91Y2hNb3ZlOiBmdW5jdGlvbiBkb1RvdWNoTW92ZSh0b3VjaGVzLCB0aW1lU3RhbXAsIHNjYWxlKSB7XG4gICAgLy8gQXJyYXktbGlrZSBjaGVjayBpcyBlbm91Z2ggaGVyZVxuICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG91Y2ggbGlzdDogJyArIHRvdWNoZXMpO1xuICAgIH1cblxuICAgIGlmICh0aW1lU3RhbXAgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICB0aW1lU3RhbXAgPSB0aW1lU3RhbXAudmFsdWVPZigpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRpbWVTdGFtcCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0aW1lc3RhbXAgdmFsdWU6ICcgKyB0aW1lU3RhbXApO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIElnbm9yZSBldmVudCB3aGVuIHRyYWNraW5nIGlzIG5vdCBlbmFibGVkIChldmVudCBtaWdodCBiZSBvdXRzaWRlIG9mIGVsZW1lbnQpXG4gICAgaWYgKCFzZWxmLl9faXNUcmFja2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VG91Y2hMZWZ0LCBjdXJyZW50VG91Y2hUb3A7XG5cbiAgICAvLyBDb21wdXRlIG1vdmUgYmFzZWQgYXJvdW5kIG9mIGNlbnRlciBvZiBmaW5nZXJzXG4gICAgaWYgKHRvdWNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICBjdXJyZW50VG91Y2hMZWZ0ID0gTWF0aC5hYnModG91Y2hlc1swXS5wYWdlWCArIHRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgIGN1cnJlbnRUb3VjaFRvcCA9IE1hdGguYWJzKHRvdWNoZXNbMF0ucGFnZVkgKyB0b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRUb3VjaExlZnQgPSB0b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgY3VycmVudFRvdWNoVG9wID0gdG91Y2hlc1swXS5wYWdlWTtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb25zID0gc2VsZi5fX3Bvc2l0aW9ucztcblxuICAgIC8vIEFyZSB3ZSBhbHJlYWR5IGlzIGRyYWdnaW5nIG1vZGU/XG4gICAgaWYgKHNlbGYuX19pc0RyYWdnaW5nKSB7XG4gICAgICAvLyBDb21wdXRlIG1vdmUgZGlzdGFuY2VcbiAgICAgIHZhciBtb3ZlWCA9IGN1cnJlbnRUb3VjaExlZnQgLSBzZWxmLl9fbGFzdFRvdWNoTGVmdDtcbiAgICAgIHZhciBtb3ZlWSA9IGN1cnJlbnRUb3VjaFRvcCAtIHNlbGYuX19sYXN0VG91Y2hUb3A7XG5cbiAgICAgIC8vIFJlYWQgcHJldmlvdXMgc2Nyb2xsIHBvc2l0aW9uIGFuZCB6b29taW5nXG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IHNlbGYuX19zY3JvbGxMZWZ0O1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IHNlbGYuX19zY3JvbGxUb3A7XG4gICAgICB2YXIgbGV2ZWwgPSBzZWxmLl9fem9vbUxldmVsO1xuXG4gICAgICAvLyBXb3JrIHdpdGggc2NhbGluZ1xuICAgICAgaWYgKHNjYWxlICE9IG51bGwgJiYgc2VsZi5vcHRpb25zLnpvb21pbmcpIHtcbiAgICAgICAgdmFyIG9sZExldmVsID0gbGV2ZWw7XG5cbiAgICAgICAgLy8gUmVjb21wdXRlIGxldmVsIGJhc2VkIG9uIHByZXZpb3VzIHNjYWxlIGFuZCBuZXcgc2NhbGVcbiAgICAgICAgbGV2ZWwgPSBsZXZlbCAvIHNlbGYuX19sYXN0U2NhbGUgKiBzY2FsZTtcblxuICAgICAgICAvLyBMaW1pdCBsZXZlbCBhY2NvcmRpbmcgdG8gY29uZmlndXJhdGlvblxuICAgICAgICBsZXZlbCA9IE1hdGgubWF4KE1hdGgubWluKGxldmVsLCBzZWxmLm9wdGlvbnMubWF4Wm9vbSksIHNlbGYub3B0aW9ucy5taW5ab29tKTtcblxuICAgICAgICAvLyBPbmx5IGRvIGZ1cnRoZXIgY29tcHV0aW9uIHdoZW4gY2hhbmdlIGhhcHBlbmVkXG4gICAgICAgIGlmIChvbGRMZXZlbCAhPT0gbGV2ZWwpIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHJlbGF0aXZlIGV2ZW50IHBvc2l0aW9uIHRvIGNvbnRhaW5lclxuICAgICAgICAgIHZhciBjdXJyZW50VG91Y2hMZWZ0UmVsID0gY3VycmVudFRvdWNoTGVmdCAtIHNlbGYuX19jbGllbnRMZWZ0O1xuICAgICAgICAgIHZhciBjdXJyZW50VG91Y2hUb3BSZWwgPSBjdXJyZW50VG91Y2hUb3AgLSBzZWxmLl9fY2xpZW50VG9wO1xuXG4gICAgICAgICAgLy8gUmVjb21wdXRlIGxlZnQgYW5kIHRvcCBjb29yZGluYXRlcyBiYXNlZCBvbiBuZXcgem9vbSBsZXZlbFxuICAgICAgICAgIHNjcm9sbExlZnQgPSAoY3VycmVudFRvdWNoTGVmdFJlbCArIHNjcm9sbExlZnQpICogbGV2ZWwgLyBvbGRMZXZlbCAtIGN1cnJlbnRUb3VjaExlZnRSZWw7XG4gICAgICAgICAgc2Nyb2xsVG9wID0gKGN1cnJlbnRUb3VjaFRvcFJlbCArIHNjcm9sbFRvcCkgKiBsZXZlbCAvIG9sZExldmVsIC0gY3VycmVudFRvdWNoVG9wUmVsO1xuXG4gICAgICAgICAgLy8gUmVjb21wdXRlIG1heCBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgc2VsZi5fX2NvbXB1dGVTY3JvbGxNYXgobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBib3VuY2luZyA9IHNlbGYub3B0aW9ucy5ib3VuY2luZztcblxuICAgICAgaWYgKHNlbGYuX19lbmFibGVTY3JvbGxYKSB7XG4gICAgICAgIHNjcm9sbExlZnQgLT0gbW92ZVggKiB0aGlzLm9wdGlvbnMuc3BlZWRNdWx0aXBsaWVyO1xuICAgICAgICB2YXIgbWF4U2Nyb2xsTGVmdCA9IHNlbGYuX19tYXhTY3JvbGxMZWZ0O1xuXG4gICAgICAgIGlmIChzY3JvbGxMZWZ0ID4gbWF4U2Nyb2xsTGVmdCB8fCBzY3JvbGxMZWZ0IDwgMCkge1xuICAgICAgICAgIHNjcm9sbExlZnQgKz0gbW92ZVggLyAyICogdGhpcy5vcHRpb25zLnNwZWVkTXVsdGlwbGllcjtcblxuICAgICAgICAgIC8vIGZpeCBzY3JvbGxMZWZ0XG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IE1hdGgubWluKE1hdGgubWF4KC1ib3VuY2luZy5sZWZ0LCBzY3JvbGxMZWZ0KSwgbWF4U2Nyb2xsTGVmdCArIGJvdW5jaW5nLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wdXRlIG5ldyB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb25cbiAgICAgIGlmIChzZWxmLl9fZW5hYmxlU2Nyb2xsWSkge1xuICAgICAgICBzY3JvbGxUb3AgLT0gbW92ZVkgKiB0aGlzLm9wdGlvbnMuc3BlZWRNdWx0aXBsaWVyO1xuICAgICAgICB2YXIgbWF4U2Nyb2xsVG9wID0gc2VsZi5fX21heFNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoc2Nyb2xsVG9wID4gbWF4U2Nyb2xsVG9wIHx8IHNjcm9sbFRvcCA8IDApIHtcbiAgICAgICAgICBzY3JvbGxUb3AgKz0gbW92ZVkgLyAyICogdGhpcy5vcHRpb25zLnNwZWVkTXVsdGlwbGllcjtcblxuICAgICAgICAgIC8vIGZpeCBzY3JvbGxUb3BcbiAgICAgICAgICBzY3JvbGxUb3AgPSBNYXRoLm1pbihNYXRoLm1heCgtYm91bmNpbmcudG9wLCBzY3JvbGxUb3ApLCBtYXhTY3JvbGxUb3AgKyBib3VuY2luZy5ib3R0b20pO1xuXG4gICAgICAgICAgLy8gVHJpZ2dlciBwdWxsIHRvIHJlZnJlc2ggb3IgcHVzaCB0byBsb2FkXG4gICAgICAgICAgaWYgKCFzZWxmLl9fZW5hYmxlU2Nyb2xsWCAmJiAoc2VsZi5fX3JlZnJlc2hIZWlnaHQgIT0gbnVsbCB8fCBzZWxmLl9fbG9hZEhlaWdodCAhPSBudWxsKSkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLl9fcmVmcmVzaEFjdGl2ZSAmJiBzY3JvbGxUb3AgPD0gLXNlbGYuX19yZWZyZXNoSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHNlbGYuX19yZWZyZXNoQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuX19yZWZyZXNoQWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9fcmVmcmVzaEFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5fX3JlZnJlc2hBY3RpdmUgJiYgc2Nyb2xsVG9wID4gLXNlbGYuX19yZWZyZXNoSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHNlbGYuX19yZWZyZXNoQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChzZWxmLl9fcmVmcmVzaERlYWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9fcmVmcmVzaERlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIGZvciBwdXNoLWxvYWRcbiAgICAgICAgICAgIGVsc2UgaWYgKCFzZWxmLl9fbG9hZEFjdGl2ZSAmJiBzY3JvbGxUb3AgPj0gc2VsZi5fX21heFNjcm9sbFRvcCArIHNlbGYuX19sb2FkSGVpZ2h0ICYmIHNlbGYuX19sb2FkSGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX19sb2FkQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX2xvYWRBY3RpdmF0ZSkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5fX2xvYWRBY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9fbG9hZEFjdGl2ZSAmJiBzY3JvbGxUb3AgPCBzZWxmLl9fbWF4U2Nyb2xsVG9wICsgc2VsZi5fX2xvYWRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9fbG9hZEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9fbG9hZERlYWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX19sb2FkRGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIGxpc3QgZnJvbSBncm93aW5nIGluZmluaXRlbHkgKGhvbGRpbmcgbWluIDEwLCBtYXggMjAgbWVhc3VyZSBwb2ludHMpXG4gICAgICBpZiAocG9zaXRpb25zLmxlbmd0aCA+IDYwKSB7XG4gICAgICAgIHBvc2l0aW9ucy5zcGxpY2UoMCwgMzApO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmFjayBzY3JvbGwgbW92ZW1lbnQgZm9yIGRlY2xlcmF0aW9uXG4gICAgICBwb3NpdGlvbnMucHVzaChzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIHRpbWVTdGFtcCk7XG5cbiAgICAgIC8vIFN5bmMgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICBzZWxmLl9fcHVibGlzaChzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIGxldmVsKTtcblxuICAgICAgLy8gT3RoZXJ3aXNlIGZpZ3VyZSBvdXQgd2hldGhlciB3ZSBhcmUgc3dpdGNoaW5nIGludG8gZHJhZ2dpbmcgbW9kZSBub3cuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtaW5pbXVtVHJhY2tpbmdGb3JTY3JvbGwgPSBzZWxmLm9wdGlvbnMubG9ja2luZyA/IDMgOiAwO1xuICAgICAgdmFyIG1pbmltdW1UcmFja2luZ0ZvckRyYWcgPSA1O1xuXG4gICAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5hYnMoY3VycmVudFRvdWNoTGVmdCAtIHNlbGYuX19pbml0aWFsVG91Y2hMZWZ0KTtcbiAgICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLmFicyhjdXJyZW50VG91Y2hUb3AgLSBzZWxmLl9faW5pdGlhbFRvdWNoVG9wKTtcblxuICAgICAgc2VsZi5fX2VuYWJsZVNjcm9sbFggPSBzZWxmLm9wdGlvbnMuc2Nyb2xsaW5nWCAmJiBkaXN0YW5jZVggPj0gbWluaW11bVRyYWNraW5nRm9yU2Nyb2xsO1xuICAgICAgc2VsZi5fX2VuYWJsZVNjcm9sbFkgPSBzZWxmLm9wdGlvbnMuc2Nyb2xsaW5nWSAmJiBkaXN0YW5jZVkgPj0gbWluaW11bVRyYWNraW5nRm9yU2Nyb2xsO1xuXG4gICAgICBwb3NpdGlvbnMucHVzaChzZWxmLl9fc2Nyb2xsTGVmdCwgc2VsZi5fX3Njcm9sbFRvcCwgdGltZVN0YW1wKTtcblxuICAgICAgc2VsZi5fX2lzRHJhZ2dpbmcgPSAoc2VsZi5fX2VuYWJsZVNjcm9sbFggfHwgc2VsZi5fX2VuYWJsZVNjcm9sbFkpICYmIChkaXN0YW5jZVggPj0gbWluaW11bVRyYWNraW5nRm9yRHJhZyB8fCBkaXN0YW5jZVkgPj0gbWluaW11bVRyYWNraW5nRm9yRHJhZyk7XG4gICAgICBpZiAoc2VsZi5fX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgc2VsZi5fX2ludGVycnVwdGVkQW5pbWF0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGxhc3QgdG91Y2ggcG9zaXRpb25zIGFuZCB0aW1lIHN0YW1wIGZvciBuZXh0IGV2ZW50XG4gICAgc2VsZi5fX2xhc3RUb3VjaExlZnQgPSBjdXJyZW50VG91Y2hMZWZ0O1xuICAgIHNlbGYuX19sYXN0VG91Y2hUb3AgPSBjdXJyZW50VG91Y2hUb3A7XG4gICAgc2VsZi5fX2xhc3RUb3VjaE1vdmUgPSB0aW1lU3RhbXA7XG4gICAgc2VsZi5fX2xhc3RTY2FsZSA9IHNjYWxlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaCBlbmQgaGFuZGxlciBmb3Igc2Nyb2xsaW5nIHN1cHBvcnRcbiAgICovXG4gIGRvVG91Y2hFbmQ6IGZ1bmN0aW9uIGRvVG91Y2hFbmQodGltZVN0YW1wKSB7XG4gICAgaWYgKHRpbWVTdGFtcCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHRpbWVTdGFtcCA9IHRpbWVTdGFtcC52YWx1ZU9mKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGltZVN0YW1wICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRpbWVzdGFtcCB2YWx1ZTogJyArIHRpbWVTdGFtcCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gSWdub3JlIGV2ZW50IHdoZW4gdHJhY2tpbmcgaXMgbm90IGVuYWJsZWQgKG5vIHRvdWNoc3RhcnQgZXZlbnQgb24gZWxlbWVudClcbiAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIGFzIHRoaXMgbGlzdGVuZXIgKCd0b3VjaG1vdmUnKSBzaXRzIG9uIHRoZSBkb2N1bWVudCBhbmQgbm90IG9uIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICBpZiAoIXNlbGYuX19pc1RyYWNraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm90IHRvdWNoaW5nIGFueW1vcmUgKHdoZW4gdHdvIGZpbmdlciBoaXQgdGhlIHNjcmVlbiB0aGVyZSBhcmUgdHdvIHRvdWNoIGVuZCBldmVudHMpXG4gICAgc2VsZi5fX2lzVHJhY2tpbmcgPSBmYWxzZTtcblxuICAgIC8vIEJlIHN1cmUgdG8gcmVzZXQgdGhlIGRyYWdnaW5nIGZsYWcgbm93LiBIZXJlIHdlIGFsc28gZGV0ZWN0IHdoZXRoZXJcbiAgICAvLyB0aGUgZmluZ2VyIGhhcyBtb3ZlZCBmYXN0IGVub3VnaCB0byBzd2l0Y2ggaW50byBhIGRlY2VsZXJhdGlvbiBhbmltYXRpb24uXG4gICAgaWYgKHNlbGYuX19pc0RyYWdnaW5nKSB7XG4gICAgICAvLyBSZXNldCBkcmFnZ2luZyBmbGFnXG4gICAgICBzZWxmLl9faXNEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAvLyBTdGFydCBkZWNlbGVyYXRpb25cbiAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBsYXN0IG1vdmUgZGV0ZWN0ZWQgd2FzIGluIHNvbWUgcmVsZXZhbnQgdGltZSBmcmFtZVxuICAgICAgaWYgKHNlbGYuX19pc1NpbmdsZVRvdWNoICYmIHNlbGYub3B0aW9ucy5hbmltYXRpbmcgJiYgdGltZVN0YW1wIC0gc2VsZi5fX2xhc3RUb3VjaE1vdmUgPD0gMTAwKSB7XG4gICAgICAgIC8vIFRoZW4gZmlndXJlIG91dCB3aGF0IHRoZSBzY3JvbGwgcG9zaXRpb24gd2FzIGFib3V0IDEwMG1zIGFnb1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gc2VsZi5fX3Bvc2l0aW9ucztcbiAgICAgICAgdmFyIGVuZFBvcyA9IHBvc2l0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSBlbmRQb3M7XG5cbiAgICAgICAgLy8gTW92ZSBwb2ludGVyIHRvIHBvc2l0aW9uIG1lYXN1cmVkIDEwMG1zIGFnb1xuICAgICAgICBmb3IgKHZhciBpID0gZW5kUG9zOyBpID4gMCAmJiBwb3NpdGlvbnNbaV0gPiBzZWxmLl9fbGFzdFRvdWNoTW92ZSAtIDEwMDsgaSAtPSAzKSB7XG4gICAgICAgICAgc3RhcnRQb3MgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgc3RhcnQgYW5kIHN0b3AgcG9zaXRpb24gaXMgaWRlbnRpY2FsIGluIGEgMTAwbXMgdGltZWZyYW1lLFxuICAgICAgICAvLyB3ZSBjYW5ub3QgY29tcHV0ZSBhbnkgdXNlZnVsIGRlY2VsZXJhdGlvbi5cbiAgICAgICAgaWYgKHN0YXJ0UG9zICE9PSBlbmRQb3MpIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHJlbGF0aXZlIG1vdmVtZW50IGJldHdlZW4gdGhlc2UgdHdvIHBvaW50c1xuICAgICAgICAgIHZhciB0aW1lT2Zmc2V0ID0gcG9zaXRpb25zW2VuZFBvc10gLSBwb3NpdGlvbnNbc3RhcnRQb3NdO1xuICAgICAgICAgIHZhciBtb3ZlZExlZnQgPSBzZWxmLl9fc2Nyb2xsTGVmdCAtIHBvc2l0aW9uc1tzdGFydFBvcyAtIDJdO1xuICAgICAgICAgIHZhciBtb3ZlZFRvcCA9IHNlbGYuX19zY3JvbGxUb3AgLSBwb3NpdGlvbnNbc3RhcnRQb3MgLSAxXTtcblxuICAgICAgICAgIC8vIEJhc2VkIG9uIDUwbXMgY29tcHV0ZSB0aGUgbW92ZW1lbnQgdG8gYXBwbHkgZm9yIGVhY2ggcmVuZGVyIHN0ZXBcbiAgICAgICAgICBzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlYID0gbW92ZWRMZWZ0IC8gdGltZU9mZnNldCAqICgxMDAwIC8gNjApO1xuICAgICAgICAgIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVkgPSBtb3ZlZFRvcCAvIHRpbWVPZmZzZXQgKiAoMTAwMCAvIDYwKTtcblxuICAgICAgICAgIC8vIEhvdyBtdWNoIHZlbG9jaXR5IGlzIHJlcXVpcmVkIHRvIHN0YXJ0IHRoZSBkZWNlbGVyYXRpb25cbiAgICAgICAgICB2YXIgbWluVmVsb2NpdHlUb1N0YXJ0RGVjZWxlcmF0aW9uID0gc2VsZi5vcHRpb25zLnBhZ2luZyB8fCBzZWxmLm9wdGlvbnMuc25hcHBpbmcgPyA0IDogMTtcblxuICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHdlIGhhdmUgZW5vdWdoIHZlbG9jaXR5IHRvIHN0YXJ0IGRlY2VsZXJhdGlvblxuICAgICAgICAgIGlmIChNYXRoLmFicyhzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlYKSA+IG1pblZlbG9jaXR5VG9TdGFydERlY2VsZXJhdGlvbiB8fCBNYXRoLmFicyhzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZKSA+IG1pblZlbG9jaXR5VG9TdGFydERlY2VsZXJhdGlvbikge1xuICAgICAgICAgICAgLy8gRGVhY3RpdmF0ZSBwdWxsLXRvLXJlZnJlc2ggd2hlbiBkZWNlbGVyYXRpbmdcbiAgICAgICAgICAgIGlmICghc2VsZi5fX3JlZnJlc2hBY3RpdmUgJiYgIXNlbGYuX19sb2FkQWN0aXZlKSB7XG4gICAgICAgICAgICAgIHNlbGYuX19zdGFydERlY2VsZXJhdGlvbih0aW1lU3RhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLl9fc2Nyb2xsQ29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5fX3Njcm9sbENvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGltZVN0YW1wIC0gc2VsZi5fX2xhc3RUb3VjaE1vdmUgPiAxMDApIHtcbiAgICAgICAgc2VsZi5fX3Njcm9sbENvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3YXMgYSBzbG93ZXIgbW92ZSBpdCBpcyBwZXIgZGVmYXVsdCBub24gZGVjZWxlcmF0ZWQsIGJ1dCB0aGlzXG4gICAgLy8gc3RpbGwgbWVhbnMgdGhhdCB3ZSB3YW50IHNuYXAgYmFjayB0byB0aGUgYm91bmRzIHdoaWNoIGlzIGRvbmUgaGVyZS5cbiAgICAvLyBUaGlzIGlzIHBsYWNlZCBvdXRzaWRlIHRoZSBjb25kaXRpb24gYWJvdmUgdG8gaW1wcm92ZSBlZGdlIGNhc2Ugc3RhYmlsaXR5XG4gICAgLy8gZS5nLiB0b3VjaGVuZCBmaXJlZCB3aXRob3V0IGVuYWJsZWQgZHJhZ2dpbmcuIFRoaXMgc2hvdWxkIG5vcm1hbGx5IGRvIG5vdFxuICAgIC8vIGhhdmUgbW9kaWZpZWQgdGhlIHNjcm9sbCBwb3NpdGlvbnMgb3IgZXZlbiBzaG93ZWQgdGhlIHNjcm9sbGJhcnMgdGhvdWdoLlxuICAgIGlmICghc2VsZi5fX2lzRGVjZWxlcmF0aW5nKSB7XG4gICAgICBpZiAoc2VsZi5fX3JlZnJlc2hBY3RpdmUgJiYgc2VsZi5fX3JlZnJlc2hTdGFydCkge1xuICAgICAgICAvLyBVc2UgcHVibGlzaCBpbnN0ZWFkIG9mIHNjcm9sbFRvIHRvIGFsbG93IHNjcm9sbGluZyB0byBvdXQgb2YgYm91bmRhcnkgcG9zaXRpb25cbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBub3JtYWxpemUgc2Nyb2xsTGVmdCwgem9vbUxldmVsLCBldGMuIGhlcmUgYmVjYXVzZSB3ZSBvbmx5IHktc2Nyb2xsaW5nIHdoZW4gcHVsbC10by1yZWZyZXNoIGlzIGVuYWJsZWRcbiAgICAgICAgc2VsZi5fX3B1Ymxpc2goc2VsZi5fX3Njcm9sbExlZnQsIC1zZWxmLl9fcmVmcmVzaEhlaWdodCwgc2VsZi5fX3pvb21MZXZlbCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX19yZWZyZXNoU3RhcnQpIHtcbiAgICAgICAgICBzZWxmLl9fcmVmcmVzaFN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5fX2xvYWRBY3RpdmUgJiYgc2VsZi5fX2xvYWRTdGFydCkge1xuICAgICAgICAvLyBVc2UgcHVibGlzaCBpbnN0ZWFkIG9mIHNjcm9sbFRvIHRvIGFsbG93IHNjcm9sbGluZyB0byBvdXQgb2YgYm91bmRhcnkgcG9zaXRpb25cbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBub3JtYWxpemUgc2Nyb2xsTGVmdCwgem9vbUxldmVsLCBldGMuIGhlcmUgYmVjYXVzZSB3ZSBvbmx5IHktc2Nyb2xsaW5nIHdoZW4gcHVsbC10by1yZWZyZXNoIGlzIGVuYWJsZWRcbiAgICAgICAgc2VsZi5fX3B1Ymxpc2goc2VsZi5fX3Njcm9sbExlZnQsIHNlbGYuX19tYXhTY3JvbGxUb3AgKyBzZWxmLl9fbG9hZEhlaWdodCwgc2VsZi5fX3pvb21MZXZlbCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX19sb2FkU3RhcnQpIHtcbiAgICAgICAgICBzZWxmLl9fbG9hZFN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzZWxmLl9faW50ZXJydXB0ZWRBbmltYXRpb24gfHwgc2VsZi5fX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgICBzZWxmLl9fc2Nyb2xsQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnNjcm9sbFRvKHNlbGYuX19zY3JvbGxMZWZ0LCBzZWxmLl9fc2Nyb2xsVG9wLCB0cnVlLCBzZWxmLl9fem9vbUxldmVsKTtcblxuICAgICAgICAvLyBEaXJlY3RseSBzaWduYWxpemUgZGVhY3RpdmF0aW9uIChub3RoaW5nIHRvZG8gb24gcmVmcmVzaD8pXG4gICAgICAgIGlmIChzZWxmLl9fcmVmcmVzaEFjdGl2ZSkge1xuICAgICAgICAgIHNlbGYuX19yZWZyZXNoQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHNlbGYuX19yZWZyZXNoRGVhY3RpdmF0ZSkge1xuICAgICAgICAgICAgc2VsZi5fX3JlZnJlc2hEZWFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuX19sb2FkQWN0aXZlKSB7XG4gICAgICAgICAgc2VsZi5fX2xvYWRBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoc2VsZi5fX2xvYWREZWFjdGl2YXRlKSB7XG4gICAgICAgICAgICBzZWxmLl9fbG9hZERlYWN0aXZhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGdWxseSBjbGVhbnVwIGxpc3RcbiAgICBzZWxmLl9fcG9zaXRpb25zLmxlbmd0aCA9IDA7XG4gIH0sXG5cbiAgLyoqIEhhbmRsZSBmb3Igc2Nyb2xsL3B1Ymxpc2ggKi9cbiAgb25TY3JvbGw6IE5PT1AsXG5cbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLl9fZGlzYWJsZSA9IHRydWU7XG4gIH0sXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLl9fZGlzYWJsZSA9IHRydWU7XG4gIH0sXG4gIC8qXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBQUklWQVRFIEFQSVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgKi9cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBjb250ZW50IGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGxlZnQge051bWJlcn0gTGVmdCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHBhcmFtIHRvcCB7TnVtYmVyfSBUb3Agc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSBhbmltYXRlIHtCb29sZWFuP2ZhbHNlfSBXaGV0aGVyIGFuaW1hdGlvbiBzaG91bGQgYmUgdXNlZCB0byBtb3ZlIHRvIHRoZSBuZXcgY29vcmRpbmF0ZXNcbiAgICovXG4gIF9fcHVibGlzaDogZnVuY3Rpb24gX19wdWJsaXNoKGxlZnQsIHRvcCwgem9vbSwgYW5pbWF0ZSwgc3BlZWQsIGVhc2luZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5fX2Rpc2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGxlZnQpKSB7XG4gICAgICBsZWZ0ID0gdGhpcy5fX3Njcm9sbExlZnQ7XG4gICAgfVxuICAgIGlmIChpc05hTih0b3ApKSB7XG4gICAgICB0b3AgPSB0aGlzLl9fc2Nyb2xsVG9wO1xuICAgIH1cbiAgICAvLyBSZW1lbWJlciB3aGV0aGVyIHdlIGhhZCBhbiBhbmltYXRpb24sIHRoZW4gd2UgdHJ5IHRvIGNvbnRpbnVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IFwiZHJpdmVcIiBvZiB0aGUgYW5pbWF0aW9uXG4gICAgdmFyIHdhc0FuaW1hdGluZyA9IHNlbGYuX19pc0FuaW1hdGluZztcbiAgICBpZiAod2FzQW5pbWF0aW5nKSB7XG4gICAgICBjb3JlLmVmZmVjdC5BbmltYXRlLnN0b3Aod2FzQW5pbWF0aW5nKTtcbiAgICAgIHNlbGYuX19pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRlICYmIChzZWxmLm9wdGlvbnMuYW5pbWF0aW5nIHx8IHNwZWVkKSkge1xuICAgICAgLy8gS2VlcCBzY2hlZHVsZWQgcG9zaXRpb25zIGZvciBzY3JvbGxCeS96b29tQnkgZnVuY3Rpb25hbGl0eVxuICAgICAgc2VsZi5fX3NjaGVkdWxlZExlZnQgPSBsZWZ0O1xuICAgICAgc2VsZi5fX3NjaGVkdWxlZFRvcCA9IHRvcDtcbiAgICAgIHNlbGYuX19zY2hlZHVsZWRab29tID0gem9vbTtcblxuICAgICAgdmFyIG9sZExlZnQgPSBzZWxmLl9fc2Nyb2xsTGVmdDtcbiAgICAgIHZhciBvbGRUb3AgPSBzZWxmLl9fc2Nyb2xsVG9wO1xuICAgICAgdmFyIG9sZFpvb20gPSBzZWxmLl9fem9vbUxldmVsO1xuXG4gICAgICB2YXIgZGlmZkxlZnQgPSBsZWZ0IC0gb2xkTGVmdDtcbiAgICAgIHZhciBkaWZmVG9wID0gdG9wIC0gb2xkVG9wO1xuICAgICAgdmFyIGRpZmZab29tID0gem9vbSAtIG9sZFpvb207XG5cbiAgICAgIHZhciBzdGVwID0gZnVuY3Rpb24gc3RlcChwZXJjZW50LCBub3csIHJlbmRlcikge1xuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgc2VsZi5fX3Njcm9sbExlZnQgPSBvbGRMZWZ0ICsgZGlmZkxlZnQgKiBwZXJjZW50O1xuICAgICAgICAgIHNlbGYuX19zY3JvbGxUb3AgPSBvbGRUb3AgKyBkaWZmVG9wICogcGVyY2VudDtcbiAgICAgICAgICBzZWxmLl9fem9vbUxldmVsID0gb2xkWm9vbSArIGRpZmZab29tICogcGVyY2VudDtcblxuICAgICAgICAgIC8vIFB1c2ggdmFsdWVzIG91dFxuICAgICAgICAgIGlmIChzZWxmLl9fY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNlbGYuX19jYWxsYmFjayhzZWxmLl9fc2Nyb2xsTGVmdCwgc2VsZi5fX3Njcm9sbFRvcCwgc2VsZi5fX3pvb21MZXZlbCk7XG4gICAgICAgICAgICBzZWxmLm9uU2Nyb2xsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgdmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9faXNBbmltYXRpbmcgPT09IGlkO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uIGNvbXBsZXRlZChyZW5kZXJlZEZyYW1lc1BlclNlY29uZCwgYW5pbWF0aW9uSWQsIHdhc0ZpbmlzaGVkKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25JZCA9PT0gc2VsZi5fX2lzQW5pbWF0aW5nKSB7XG4gICAgICAgICAgc2VsZi5fX2lzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuX19kaWREZWNlbGVyYXRpb25Db21wbGV0ZSB8fCB3YXNGaW5pc2hlZCkge1xuICAgICAgICAgIHNlbGYuX19zY3JvbGxDb21wbGV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy56b29taW5nKSB7XG4gICAgICAgICAgc2VsZi5fX2NvbXB1dGVTY3JvbGxNYXgoKTtcbiAgICAgICAgICBpZiAoc2VsZi5fX3pvb21Db21wbGV0ZSkge1xuICAgICAgICAgICAgc2VsZi5fX3pvb21Db21wbGV0ZSgpO1xuICAgICAgICAgICAgc2VsZi5fX3pvb21Db21wbGV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuX19yZWZyZXNoQmVmb3JlRGVhY3RpdmVTdGFydGVkKSB7XG4gICAgICAgICAgc2VsZi5fX3JlZnJlc2hCZWZvcmVEZWFjdGl2ZVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoc2VsZi5fX3JlZnJlc2hEZWFjdGl2YXRlKSBzZWxmLl9fcmVmcmVzaERlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9fbG9hZEJlZm9yZURlYWN0aXZlU3RhcnRlZCkge1xuICAgICAgICAgIHNlbGYuX19sb2FkQmVmb3JlRGVhY3RpdmVTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHNlbGYuX19sb2FkRGVhY3RpdmF0ZSkgc2VsZi5fX2xvYWREZWFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBlYXNpbmdGdW5jdGlvbiA9IGFuaW1hdGluZ01ldGhvZDtcbiAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgZWFzaW5nRnVuY3Rpb24gPSBjcmVhdGVFYXNpbmdGdW5jdGlvbihlYXNpbmcsIGVhc2luZ1BhdHRlcm4pO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIGNvbnRpbnVpbmcgYmFzZWQgb24gcHJldmlvdXMgYW5pbWF0aW9uIHdlIGNob29zZSBhbiBlYXNlLW91dCBhbmltYXRpb24gaW5zdGVhZCBvZiBlYXNlLWluLW91dFxuICAgICAgc2VsZi5fX2lzQW5pbWF0aW5nID0gY29yZS5lZmZlY3QuQW5pbWF0ZS5zdGFydChzdGVwLCB2ZXJpZnksIGNvbXBsZXRlZCwgc3BlZWQgfHwgc2VsZi5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLCB3YXNBbmltYXRpbmcgPyBlYXNpbmdGdW5jdGlvbiA6IG5vQW5pbWF0aW5nTWV0aG9kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fX3NjaGVkdWxlZExlZnQgPSBzZWxmLl9fc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICBzZWxmLl9fc2NoZWR1bGVkVG9wID0gc2VsZi5fX3Njcm9sbFRvcCA9IHRvcDtcbiAgICAgIHNlbGYuX19zY2hlZHVsZWRab29tID0gc2VsZi5fX3pvb21MZXZlbCA9IHpvb207XG5cbiAgICAgIC8vIFB1c2ggdmFsdWVzIG91dFxuICAgICAgaWYgKHNlbGYuX19jYWxsYmFjaykge1xuICAgICAgICBzZWxmLl9fY2FsbGJhY2sobGVmdCwgdG9wLCB6b29tKTtcbiAgICAgICAgc2VsZi5vblNjcm9sbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXggbWF4IHNjcm9sbCByYW5nZXNcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuem9vbWluZykge1xuICAgICAgICBzZWxmLl9fY29tcHV0ZVNjcm9sbE1heCgpO1xuICAgICAgICBpZiAoc2VsZi5fX3pvb21Db21wbGV0ZSkge1xuICAgICAgICAgIHNlbGYuX196b29tQ29tcGxldGUoKTtcbiAgICAgICAgICBzZWxmLl9fem9vbUNvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5fX3JlZnJlc2hCZWZvcmVEZWFjdGl2ZVN0YXJ0ZWQpIHtcbiAgICAgICAgc2VsZi5fX3JlZnJlc2hCZWZvcmVEZWFjdGl2ZVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNlbGYuX19yZWZyZXNoRGVhY3RpdmF0ZSkgc2VsZi5fX3JlZnJlc2hEZWFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLl9fbG9hZEJlZm9yZURlYWN0aXZlU3RhcnRlZCkge1xuICAgICAgICBzZWxmLl9fbG9hZEJlZm9yZURlYWN0aXZlU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2VsZi5fX2xvYWREZWFjdGl2YXRlKSBzZWxmLl9fbG9hZERlYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29tcHV0ZXMgc2Nyb2xsIG1pbmltdW0gdmFsdWVzIGJhc2VkIG9uIGNsaWVudCBkaW1lbnNpb25zIGFuZCBjb250ZW50IGRpbWVuc2lvbnMuXG4gICAqL1xuICBfX2NvbXB1dGVTY3JvbGxNYXg6IGZ1bmN0aW9uIF9fY29tcHV0ZVNjcm9sbE1heCh6b29tTGV2ZWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoem9vbUxldmVsID09IG51bGwpIHtcbiAgICAgIHpvb21MZXZlbCA9IHNlbGYuX196b29tTGV2ZWw7XG4gICAgfVxuXG4gICAgc2VsZi5fX21heFNjcm9sbExlZnQgPSBNYXRoLm1heChzZWxmLl9fY29udGVudFdpZHRoICogem9vbUxldmVsIC0gc2VsZi5fX2NsaWVudFdpZHRoLCAwKTtcbiAgICBzZWxmLl9fbWF4U2Nyb2xsVG9wID0gTWF0aC5tYXgoc2VsZi5fX2NvbnRlbnRIZWlnaHQgKiB6b29tTGV2ZWwgLSBzZWxmLl9fY2xpZW50SGVpZ2h0LCAwKTtcbiAgfSxcbiAgLyoqIGNvbXB1dGUgY3VycmVudCBwYWdlIHRvdGFsIHBhZ2UgKi9cbiAgX19jb21wdXRlUGFnZTogZnVuY3Rpb24gX19jb21wdXRlUGFnZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNsaWVudFdpZHRoID0gc2VsZi5fX2NsaWVudFdpZHRoO1xuICAgIHZhciBjbGllbnRIZWlnaHQgPSBzZWxmLl9fY2xpZW50SGVpZ2h0O1xuICAgIHZhciBsZWZ0ID0gc2VsZi5fX3Njcm9sbExlZnQ7XG4gICAgdmFyIHRvcCA9IHNlbGYuX19zY3JvbGxUb3A7XG4gICAgc2VsZi5fX3RvdGFsWFBhZ2UgPSBNYXRoLmNlaWwoc2VsZi5fX2NvbnRlbnRXaWR0aCAvIGNsaWVudFdpZHRoKTtcbiAgICBzZWxmLl9fY3VycmVudFBhZ2VYID0gTWF0aC5jZWlsKGxlZnQgLyBjbGllbnRXaWR0aCArIDEpO1xuICAgIHNlbGYuX190b3RhbFlQYWdlID0gTWF0aC5jZWlsKHNlbGYuX19jb250ZW50SGVpZ2h0IC8gY2xpZW50SGVpZ2h0KTtcbiAgICBzZWxmLl9fY3VycmVudFBhZ2VZID0gTWF0aC5jZWlsKHRvcCAvIGNsaWVudEhlaWdodCArIDEpO1xuICB9LFxuICAvKiogY29tcGxldGUgc2Nyb2xsKi9cbiAgX19zY3JvbGxDb21wbGV0ZTogZnVuY3Rpb24gX19zY3JvbGxDb21wbGV0ZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5vcHRpb25zLnNjcm9sbGluZ0NvbXBsZXRlKCk7XG4gIH0sXG4gIC8qXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBBTklNQVRJT04gKERFQ0VMRVJBVElPTikgU1VQUE9SVFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgKi9cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0b3VjaCBzZXF1ZW5jZSBlbmQgYW5kIHRoZSBzcGVlZCBvZiB0aGUgZmluZ2VyIHdhcyBoaWdoIGVub3VnaFxuICAgKiB0byBzd2l0Y2ggaW50byBkZWNlbGVyYXRpb24gbW9kZS5cbiAgICovXG4gIF9fc3RhcnREZWNlbGVyYXRpb246IGZ1bmN0aW9uIF9fc3RhcnREZWNlbGVyYXRpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHNlbGYub3B0aW9ucy5wYWdpbmcpIHtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4oc2VsZi5fX3Njcm9sbExlZnQsIHNlbGYuX19tYXhTY3JvbGxMZWZ0KSwgMCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gTWF0aC5tYXgoTWF0aC5taW4oc2VsZi5fX3Njcm9sbFRvcCwgc2VsZi5fX21heFNjcm9sbFRvcCksIDApO1xuICAgICAgdmFyIGNsaWVudFdpZHRoID0gc2VsZi5fX2NsaWVudFdpZHRoO1xuICAgICAgdmFyIGNsaWVudEhlaWdodCA9IHNlbGYuX19jbGllbnRIZWlnaHQ7XG5cbiAgICAgIC8vIFdlIGxpbWl0IGRlY2VsZXJhdGlvbiBub3QgdG8gdGhlIG1pbi9tYXggdmFsdWVzIG9mIHRoZSBhbGxvd2VkIHJhbmdlLCBidXQgdG8gdGhlIHNpemUgb2YgdGhlIHZpc2libGUgY2xpZW50IGFyZWEuXG4gICAgICAvLyBFYWNoIHBhZ2Ugc2hvdWxkIGhhdmUgZXhhY3RseSB0aGUgc2l6ZSBvZiB0aGUgY2xpZW50IGFyZWEuXG4gICAgICBzZWxmLl9fbWluRGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCA9IE1hdGguZmxvb3Ioc2Nyb2xsTGVmdCAvIGNsaWVudFdpZHRoKSAqIGNsaWVudFdpZHRoO1xuICAgICAgc2VsZi5fX21pbkRlY2VsZXJhdGlvblNjcm9sbFRvcCA9IE1hdGguZmxvb3Ioc2Nyb2xsVG9wIC8gY2xpZW50SGVpZ2h0KSAqIGNsaWVudEhlaWdodDtcbiAgICAgIHNlbGYuX19tYXhEZWNlbGVyYXRpb25TY3JvbGxMZWZ0ID0gTWF0aC5jZWlsKHNjcm9sbExlZnQgLyBjbGllbnRXaWR0aCkgKiBjbGllbnRXaWR0aDtcbiAgICAgIHNlbGYuX19tYXhEZWNlbGVyYXRpb25TY3JvbGxUb3AgPSBNYXRoLmNlaWwoc2Nyb2xsVG9wIC8gY2xpZW50SGVpZ2h0KSAqIGNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fX21pbkRlY2VsZXJhdGlvblNjcm9sbExlZnQgPSAwO1xuICAgICAgc2VsZi5fX21pbkRlY2VsZXJhdGlvblNjcm9sbFRvcCA9IDA7XG4gICAgICBzZWxmLl9fbWF4RGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCA9IHNlbGYuX19tYXhTY3JvbGxMZWZ0O1xuICAgICAgc2VsZi5fX21heERlY2VsZXJhdGlvblNjcm9sbFRvcCA9IHNlbGYuX19tYXhTY3JvbGxUb3A7XG4gICAgfVxuXG4gICAgLy8gV3JhcCBjbGFzcyBtZXRob2RcbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uIHN0ZXAocGVyY2VudCwgbm93LCByZW5kZXIpIHtcbiAgICAgIHNlbGYuX19zdGVwVGhyb3VnaERlY2VsZXJhdGlvbihyZW5kZXIpO1xuICAgIH07XG5cbiAgICAvLyBIb3cgbXVjaCB2ZWxvY2l0eSBpcyByZXF1aXJlZCB0byBrZWVwIHRoZSBkZWNlbGVyYXRpb24gcnVubmluZ1xuICAgIHZhciBtaW5WZWxvY2l0eVRvS2VlcERlY2VsZXJhdGluZyA9IHNlbGYub3B0aW9ucy5zbmFwcGluZyA/IDQgOiAwLjAwMTtcblxuICAgIC8vIERldGVjdCB3aGV0aGVyIGl0J3Mgc3RpbGwgd29ydGggdG8gY29udGludWUgYW5pbWF0aW5nIHN0ZXBzXG4gICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgc2xvdyBlbm91Z2ggdG8gbm90IGJlaW5nIHVzZXIgcGVyY2VpdmFibGUgYW55bW9yZSwgd2Ugc3RvcCB0aGUgd2hvbGUgcHJvY2VzcyBoZXJlLlxuICAgIHZhciB2ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gICAgICB2YXIgc2hvdWxkQ29udGludWUgPSBNYXRoLmFicyhzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlYKSA+PSBtaW5WZWxvY2l0eVRvS2VlcERlY2VsZXJhdGluZyB8fCBNYXRoLmFicyhzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZKSA+PSBtaW5WZWxvY2l0eVRvS2VlcERlY2VsZXJhdGluZztcbiAgICAgIGlmICghc2hvdWxkQ29udGludWUpIHtcbiAgICAgICAgc2VsZi5fX2RpZERlY2VsZXJhdGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRDb250aW51ZTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICAgIGlmICghc2VsZi5fX2lzRGVjZWxlcmF0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGYuX19pc0RlY2VsZXJhdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKHNlbGYuX19kaWREZWNlbGVyYXRpb25Db21wbGV0ZSkge1xuICAgICAgICBzZWxmLl9fc2Nyb2xsQ29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQW5pbWF0ZSB0byBncmlkIHdoZW4gc25hcHBpbmcgaXMgYWN0aXZlLCBvdGhlcndpc2UganVzdCBmaXggb3V0LW9mLWJvdW5kYXJ5IHBvc2l0aW9uc1xuICAgICAgc2VsZi5zY3JvbGxUbyhzZWxmLl9fc2Nyb2xsTGVmdCwgc2VsZi5fX3Njcm9sbFRvcCwgc2VsZi5vcHRpb25zLnNuYXBwaW5nKTtcbiAgICB9O1xuXG4gICAgLy8gU3RhcnQgYW5pbWF0aW9uIGFuZCBzd2l0Y2ggb24gZmxhZ1xuICAgIHNlbGYuX19pc0RlY2VsZXJhdGluZyA9IGNvcmUuZWZmZWN0LkFuaW1hdGUuc3RhcnQoc3RlcCwgdmVyaWZ5LCBjb21wbGV0ZWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gZXZlcnkgc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBpbk1lbW9yeSB7Qm9vbGVhbj9mYWxzZX0gV2hldGhlciB0byBub3QgcmVuZGVyIHRoZSBjdXJyZW50IHN0ZXAsIGJ1dCBrZWVwIGl0IGluIG1lbW9yeSBvbmx5LiBVc2VkIGludGVybmFsbHkgb25seSFcbiAgICovXG4gIF9fc3RlcFRocm91Z2hEZWNlbGVyYXRpb246IGZ1bmN0aW9uIF9fc3RlcFRocm91Z2hEZWNlbGVyYXRpb24ocmVuZGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBib3VuY2luZyA9IHNlbGYub3B0aW9ucy5ib3VuY2luZztcbiAgICB2YXIgbWluTGVmdCA9IHNlbGYuX19taW5EZWNlbGVyYXRpb25TY3JvbGxMZWZ0O1xuICAgIHZhciBtYXhMZWZ0ID0gc2VsZi5fX21heERlY2VsZXJhdGlvblNjcm9sbExlZnQ7XG4gICAgdmFyIG1pblRvcCA9IHNlbGYuX19taW5EZWNlbGVyYXRpb25TY3JvbGxUb3A7XG4gICAgdmFyIG1heFRvcCA9IHNlbGYuX19tYXhEZWNlbGVyYXRpb25TY3JvbGxUb3A7XG4gICAgLy8gQWRkIGRlY2VsZXJhdGlvbiB0byBzY3JvbGwgcG9zaXRpb25cbiAgICB2YXIgc2Nyb2xsTGVmdCA9IHNlbGYuX19zY3JvbGxMZWZ0ICsgc2VsZi5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WDtcbiAgICB2YXIgc2Nyb2xsVG9wID0gc2VsZi5fX3Njcm9sbFRvcCArIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVk7XG5cbiAgICB2YXIgYm91bmNlWCA9IHNjcm9sbExlZnQgPCBtaW5MZWZ0IHx8IHNjcm9sbExlZnQgPiBtYXhMZWZ0O1xuICAgIHZhciBib3VuY2VZID0gc2Nyb2xsVG9wIDwgbWluVG9wIHx8IHNjcm9sbFRvcCA+IG1heFRvcDtcblxuICAgIC8vIGZpeCBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3BcbiAgICB2YXIgZml4ZWRTY3JvbGxMZWZ0ID0gTWF0aC5taW4oTWF0aC5tYXgobWluTGVmdCAtIGJvdW5jaW5nLmxlZnQsIHNjcm9sbExlZnQpLCBtYXhMZWZ0ICsgYm91bmNpbmcucmlnaHQpO1xuXG4gICAgdmFyIGZpeGVkU2Nyb2xsVG9wID0gTWF0aC5taW4oTWF0aC5tYXgobWluVG9wIC0gYm91bmNpbmcudG9wLCBzY3JvbGxUb3ApLCBtYXhUb3AgKyBib3VuY2luZy5ib3R0b20pO1xuXG4gICAgLy9cbiAgICAvLyBVUERBVEUgU0NST0xMIFBPU0lUSU9OXG4gICAgLy9cbiAgICBpZiAocmVuZGVyKSB7XG4gICAgICBzZWxmLl9fcHVibGlzaChmaXhlZFNjcm9sbExlZnQsIGZpeGVkU2Nyb2xsVG9wLCBzZWxmLl9fem9vbUxldmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fX3Njcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgc2VsZi5fX3Njcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFNMT1cgRE9XTlxuICAgIC8vXG5cbiAgICAvLyBTbG93IGRvd24gdmVsb2NpdHkgb24gZXZlcnkgaXRlcmF0aW9uXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMucGFnaW5nKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmYWN0b3IgYXBwbGllZCB0byBldmVyeSBpdGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvblxuICAgICAgLy8gdG8gc2xvdyBkb3duIHRoZSBwcm9jZXNzLiBUaGlzIHNob3VsZCBlbXVsYXRlIG5hdHVyYWwgYmVoYXZpb3Igd2hlcmVcbiAgICAgIC8vIG9iamVjdHMgc2xvdyBkb3duIHdoZW4gdGhlIGluaXRpYXRvciBvZiB0aGUgbW92ZW1lbnQgaXMgcmVtb3ZlZFxuICAgICAgdmFyIGZyaWN0aW9uRmFjdG9yID0gMC45NTtcblxuICAgICAgc2VsZi5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WCAqPSBmcmljdGlvbkZhY3RvcjtcbiAgICAgIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVkgKj0gZnJpY3Rpb25GYWN0b3I7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBCT1VOQ0lORyBTVVBQT1JUXG4gICAgLy9cblxuICAgIHZhciBzY3JvbGxPdXRzaWRlWCA9IDA7XG4gICAgdmFyIHNjcm9sbE91dHNpZGVZID0gMDtcblxuICAgIC8vIFRoaXMgY29uZmlndXJlcyB0aGUgYW1vdW50IG9mIGNoYW5nZSBhcHBsaWVkIHRvIGRlY2VsZXJhdGlvbi9hY2NlbGVyYXRpb24gd2hlbiByZWFjaGluZyBib3VuZGFyaWVzXG4gICAgdmFyIHBlbmV0cmF0aW9uRGVjZWxlcmF0aW9uID0gc2VsZi5vcHRpb25zLnBlbmV0cmF0aW9uRGVjZWxlcmF0aW9uO1xuICAgIHZhciBwZW5ldHJhdGlvbkFjY2VsZXJhdGlvbiA9IHNlbGYub3B0aW9ucy5wZW5ldHJhdGlvbkFjY2VsZXJhdGlvbjtcblxuICAgIGlmIChib3VuY2VYKSB7XG4gICAgICAvLyBDaGVjayBsaW1pdHNcbiAgICAgIGlmIChzY3JvbGxMZWZ0IDwgc2VsZi5fX21pbkRlY2VsZXJhdGlvblNjcm9sbExlZnQpIHtcbiAgICAgICAgc2Nyb2xsT3V0c2lkZVggPSBzZWxmLl9fbWluRGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCAtIHNjcm9sbExlZnQ7XG4gICAgICB9IGVsc2UgaWYgKHNjcm9sbExlZnQgPiBzZWxmLl9fbWF4RGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCkge1xuICAgICAgICBzY3JvbGxPdXRzaWRlWCA9IHNlbGYuX19tYXhEZWNlbGVyYXRpb25TY3JvbGxMZWZ0IC0gc2Nyb2xsTGVmdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmNlWSkge1xuICAgICAgaWYgKHNjcm9sbFRvcCA8IHNlbGYuX19taW5EZWNlbGVyYXRpb25TY3JvbGxUb3ApIHtcbiAgICAgICAgc2Nyb2xsT3V0c2lkZVkgPSBzZWxmLl9fbWluRGVjZWxlcmF0aW9uU2Nyb2xsVG9wIC0gc2Nyb2xsVG9wO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb3AgPiBzZWxmLl9fbWF4RGVjZWxlcmF0aW9uU2Nyb2xsVG9wKSB7XG4gICAgICAgIHNjcm9sbE91dHNpZGVZID0gc2VsZi5fX21heERlY2VsZXJhdGlvblNjcm9sbFRvcCAtIHNjcm9sbFRvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsT3V0c2lkZVggIT09IDApIHtcbiAgICAgIGlmIChzY3JvbGxPdXRzaWRlWCAqIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVggPD0gMCkge1xuICAgICAgICBzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlYICs9IHNjcm9sbE91dHNpZGVYICogcGVuZXRyYXRpb25EZWNlbGVyYXRpb247XG4gICAgICAgIGlmIChzY3JvbGxPdXRzaWRlWCA8IDAgJiYgLXNjcm9sbE91dHNpZGVYID49IGJvdW5jaW5nLnJpZ2h0ICYmIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVggPiAwKSB7XG4gICAgICAgICAgc2VsZi5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WCA9IC1ib3VuY2luZy5yaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbE91dHNpZGVYID4gMCAmJiBzY3JvbGxPdXRzaWRlWCA+PSBib3VuY2luZy5sZWZ0ICYmIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVggPCAwKSB7XG4gICAgICAgICAgc2VsZi5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WCA9IGJvdW5jaW5nLmxlZnQgLyAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlYID0gc2Nyb2xsT3V0c2lkZVggKiBwZW5ldHJhdGlvbkFjY2VsZXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsT3V0c2lkZVkgIT09IDApIHtcbiAgICAgIGlmIChzY3JvbGxPdXRzaWRlWSAqIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVkgPD0gMCkge1xuICAgICAgICBzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZICs9IHNjcm9sbE91dHNpZGVZICogcGVuZXRyYXRpb25EZWNlbGVyYXRpb247XG4gICAgICAgIGlmIChzY3JvbGxPdXRzaWRlWSA8IDAgJiYgLXNjcm9sbE91dHNpZGVZID49IGJvdW5jaW5nLmJvdHRvbSAmJiBzZWxmLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZID4gMCkge1xuICAgICAgICAgIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVkgPSAtYm91bmNpbmcuYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxPdXRzaWRlWSA+IDAgJiYgc2Nyb2xsT3V0c2lkZVkgPj0gYm91bmNpbmcudG9wICYmIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVkgPCAwKSB7XG4gICAgICAgICAgc2VsZi5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WSA9IGJvdW5jaW5nLnRvcCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX19kZWNlbGVyYXRpb25WZWxvY2l0eVkgPSBzY3JvbGxPdXRzaWRlWSAqIHBlbmV0cmF0aW9uQWNjZWxlcmF0aW9uIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIENvcHkgb3ZlciBtZW1iZXJzIHRvIHByb3RvdHlwZVxuZm9yICh2YXIga2V5IGluIG1lbWJlcnMpIHtcbiAgU2Nyb2xsZXIucHJvdG90eXBlW2tleV0gPSBtZW1iZXJzW2tleV07XG59XG5cbi8qIERPTS1iYXNlZCByZW5kZXJpbmcgKFVzZXMgM0Qgd2hlbiBhdmFpbGFibGUsIGZhbGxzIGJhY2sgb24gbWFyZ2luIHdoZW4gdHJhbnNmb3JtIG5vdCBhdmFpbGFibGUpICovXG5mdW5jdGlvbiByZW5kZXIoY29udGVudCwgZ2xvYmFsLCBzdWZmaXgsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gJ3Bvc2l0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAobGVmdCwgdG9wKSB7XG4gICAgICBjb250ZW50LnN0eWxlLmxlZnQgPSAtbGVmdCArICdweCc7XG4gICAgICBjb250ZW50LnN0eWxlLnRvcCA9IC10b3AgKyAncHgnO1xuICAgIH07XG4gIH1cblxuICB2YXIgdmVuZG9yUHJlZml4ID0gZ2V0UHJlZml4KGdsb2JhbCk7XG5cbiAgdmFyIGhlbHBlckVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHVuZGVmO1xuXG4gIHZhciBwZXJzcGVjdGl2ZVByb3BlcnR5ID0gdmVuZG9yUHJlZml4ICsgJ1BlcnNwZWN0aXZlJztcbiAgdmFyIHRyYW5zZm9ybVByb3BlcnR5ID0gJ3RyYW5zZm9ybSc7IC8vdmVuZG9yUHJlZml4ICsgJ1RyYW5zZm9ybSc7XG5cbiAgaWYgKGhlbHBlckVsZW0uc3R5bGVbcGVyc3BlY3RpdmVQcm9wZXJ0eV0gIT09IHVuZGVmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCB0b3AsIHpvb20pIHtcbiAgICAgIGNvbnRlbnQuc3R5bGVbdHJhbnNmb3JtUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyAtbGVmdCArIHN1ZmZpeCArICcsJyArIC10b3AgKyBzdWZmaXggKyAnLDApIHNjYWxlKCcgKyB6b29tICsgJyknO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoaGVscGVyRWxlbS5zdHlsZVt0cmFuc2Zvcm1Qcm9wZXJ0eV0gIT09IHVuZGVmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCB0b3AsIHpvb20pIHtcbiAgICAgIGNvbnRlbnQuc3R5bGVbdHJhbnNmb3JtUHJvcGVydHldID0gJ3RyYW5zbGF0ZSgnICsgLWxlZnQgKyBzdWZmaXggKyAnLCcgKyAtdG9wICsgc3VmZml4ICsgJykgc2NhbGUoJyArIHpvb20gKyAnKSc7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsaXN0ZW5Db250YWluZXIoY29udGFpbmVyLCBzY3JvbGxlciwgZXZlbnRDYWxsYmFjaywgem9vbWluZywgcHJldmVudERlZmF1bHQsIHByZXZlbnREZWZhdWx0T25Nb3ZlKSB7XG4gIHZhciBkZXN0cm95ID0gbnVsbDtcbiAgLy8gZm9yIHRvdWNoXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnQoZSkge1xuICAgIC8vIERvbid0IHJlYWN0IGlmIGluaXRpYWwgZG93biBoYXBwZW5zIG9uIGEgZm9ybSBlbGVtZW50XG4gICAgaWYgKGUudG91Y2hlc1swXSAmJiBlLnRvdWNoZXNbMF0udGFyZ2V0ICYmIGUudG91Y2hlc1swXS50YXJnZXQudGFnTmFtZS5tYXRjaCgvaW5wdXR8dGV4dGFyZWF8c2VsZWN0L2kpIHx8IHNjcm9sbGVyLl9fZGlzYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudENhbGxiYWNrKCdtb3VzZWRvd24nKTtcbiAgICBzY3JvbGxlci5kb1RvdWNoU3RhcnQoZS50b3VjaGVzLCBlLnRpbWVTdGFtcCk7XG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAvLyBoZXJlICwgd2Ugd2FudCB0byBtYW51bGx5IHByZXZlbnQgZGVmYXVsdCwgc28gd2VcbiAgICAvLyBzZXQgcGFzc2l2ZSB0byBmYWxzZVxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgfVxuICBmdW5jdGlvbiB0b3VjaG1vdmUoZSkge1xuICAgIGlmIChzY3JvbGxlci5fX2Rpc2FibGUpIHJldHVybjtcblxuICAgIGV2ZW50Q2FsbGJhY2soJ21vdXNlbW92ZScpO1xuICAgIHNjcm9sbGVyLmRvVG91Y2hNb3ZlKGUudG91Y2hlcywgZS50aW1lU3RhbXAsIGUuc2NhbGUpO1xuICAgIGlmIChwcmV2ZW50RGVmYXVsdE9uTW92ZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaGVuZChlKSB7XG4gICAgZXZlbnRDYWxsYmFjaygnbW91c2V1cCcpO1xuICAgIHNjcm9sbGVyLmRvVG91Y2hFbmQoZS50aW1lU3RhbXApO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hjYW5jZWwoZSkge1xuICAgIHNjcm9sbGVyLmRvVG91Y2hFbmQoZS50aW1lU3RhbXApO1xuICB9XG5cbiAgLy8gZm9yIG1vdXNlXG4gIGZ1bmN0aW9uIG1vdXNlZG93bkV2ZW50KGUpIHtcbiAgICBpZiAoZS50YXJnZXQudGFnTmFtZS5tYXRjaCgvaW5wdXR8dGV4dGFyZWF8c2VsZWN0L2kpIHx8IHNjcm9sbGVyLl9fZGlzYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBldmVudENhbGxiYWNrKCdtb3VzZWRvd24nKTtcbiAgICBzY3JvbGxlci5kb1RvdWNoU3RhcnQoW3tcbiAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgcGFnZVk6IGUucGFnZVlcbiAgICB9XSwgZS50aW1lU3RhbXApO1xuXG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgbW91c2Vkb3duID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBtb3VzZW1vdmUoZSkge1xuICAgIGlmICghbW91c2Vkb3duIHx8IHNjcm9sbGVyLl9fZGlzYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudENhbGxiYWNrKCdtb3VzZW1vdmUnKTtcbiAgICBzY3JvbGxlci5kb1RvdWNoTW92ZShbe1xuICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICBwYWdlWTogZS5wYWdlWVxuICAgIH1dLCBlLnRpbWVTdGFtcCk7XG4gICAgaWYgKHByZXZlbnREZWZhdWx0T25Nb3ZlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG1vdXNlZG93biA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbW91c2V1cChlKSB7XG4gICAgaWYgKCFtb3VzZWRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnRDYWxsYmFjaygnbW91c2V1cCcpO1xuICAgIHNjcm9sbGVyLmRvVG91Y2hFbmQoZS50aW1lU3RhbXApO1xuXG4gICAgbW91c2Vkb3duID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gem9vbUhhbmRsZShlKSB7XG4gICAgc2Nyb2xsZXIuZG9Nb3VzZVpvb20oZS5kZXRhaWwgPyBlLmRldGFpbCAqIC0xMjAgOiBlLndoZWVsRGVsdGEsIGUudGltZVN0YW1wLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcbiAgfVxuICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsLCBmYWxzZSk7XG5cbiAgICBkZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWwsIGZhbHNlKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBtb3VzZWRvd24gPSBmYWxzZTtcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZWRvd25FdmVudCwgZmFsc2UpO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlLCBmYWxzZSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCwgZmFsc2UpO1xuICAgIGlmICh6b29taW5nKSB7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xID8gJ0RPTU1vdXNlU2Nyb2xsJyA6ICdtb3VzZXdoZWVsJywgem9vbUhhbmRsZSwgZmFsc2UpO1xuICAgIH1cbiAgICAvLyBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTEgPyBcIkRPTU1vdXNlU2Nyb2xsXCIgOiAgXCJtb3VzZXdoZWVsXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAvLyAgICAgc2Nyb2xsZXIuZG9Nb3VzZVpvb20oZS5kZXRhaWwgPyAoZS5kZXRhaWwgKiAtMTIwKSA6IGUud2hlZWxEZWx0YSwgZS50aW1lU3RhbXAsIGUucGFnZVgsIGUucGFnZVkpO1xuICAgIC8vIH0sIGZhbHNlKTtcbiAgICBkZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZWRvd25FdmVudCwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCwgZmFsc2UpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSA/ICdET01Nb3VzZVNjcm9sbCcgOiAnbW91c2V3aGVlbCcsIHpvb21IYW5kbGUsIGZhbHNlKTtcbiAgICB9O1xuICB9XG4gIC8vIGhhbmRsZSBfX3B1Ymxpc2ggZXZlbnRcbiAgc2Nyb2xsZXIub25TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRDYWxsYmFjaygnb25zY3JvbGwnKTtcbiAgfTtcbiAgcmV0dXJuIGRlc3Ryb3k7XG59XG5cbi8qKlxuICogVGhlc2UgbWl4ZXMgaXMgZXhjbHVzaXZlIGZvciBzbGlkZSBtb2RlXG4gKi9cblxuY3JlYXRlU2xpZGVNb2RlU3R5bGUoKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uIHJlZnJlc2ggYW5kIGxvYWQgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RhdGVDYWxsYmFja3ModHlwZSwgc3RhZ2VUeXBlLCB2bSwgdGlwRG9tKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kbGlzdGVuZXJzO1xuXG4gIHZhciBhY3RpdmF0ZUNhbGxiYWNrID0gZnVuY3Rpb24gYWN0aXZhdGVDYWxsYmFjaygpIHtcbiAgICB2bS52dWVzY3JvbGwuc3RhdGVbc3RhZ2VUeXBlXSA9ICdhY3RpdmUnO1xuICAgIHZtLiRlbWl0KHR5cGUgKyAnLWFjdGl2YXRlJywgdm0sIHRpcERvbSk7XG4gIH07XG5cbiAgdmFyIGRlYWN0aXZhdGVDYWxsYmFjayA9IGZ1bmN0aW9uIGRlYWN0aXZhdGVDYWxsYmFjaygpIHtcbiAgICB2bS52dWVzY3JvbGwuc3RhdGVbc3RhZ2VUeXBlXSA9ICdkZWFjdGl2ZSc7XG4gICAgdm0uJGVtaXQodHlwZSArICctZGVhY3RpdmF0ZScsIHZtLCB0aXBEb20pO1xuICB9O1xuXG4gIHZhciBiZWZvcmVEZWFjdGl2ZUVuZCA9IGZ1bmN0aW9uIGJlZm9yZURlYWN0aXZlRW5kKCkge1xuICAgIHZtLnZ1ZXNjcm9sbC5zdGF0ZVtzdGFnZVR5cGVdID0gJ2JlZm9yZURlYWN0aXZlRW5kJztcbiAgICB2bS4kZW1pdCh0eXBlICsgJy1iZWZvcmUtZGVhY3RpdmF0ZS1lbmQnLCB2bSwgdGlwRG9tKTtcbiAgfTtcblxuICB2YXIgc3RhcnRDYWxsYmFjayA9IGZ1bmN0aW9uIHN0YXJ0Q2FsbGJhY2soKSB7XG4gICAgdm0udnVlc2Nyb2xsLnN0YXRlW3N0YWdlVHlwZV0gPSAnc3RhcnQnO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdm0uc2Nyb2xsZXIuZmluaXNoUmVmcmVzaE9yTG9hZCgpO1xuICAgIH0sIDIwMDApOyAvLyBEZWZhdWx0IHN0YXJ0IHN0YWdlIGR1cmF0aW9uXG4gIH07XG5cbiAgLy8gbGV0IGJlZm9yZURlYWN0aXZhdGVDYWxsYmFjayA9IGRvbmUgPT4ge1xuICAvLyAgIHZtLnZ1ZXNjcm9sbC5zdGF0ZVtzdGFnZVR5cGVdID0gJ2JlZm9yZURlYWN0aXZlJztcbiAgLy8gICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAvLyAgICAgZG9uZSgpO1xuICAvLyAgIH0sIDUwMCk7IC8vIERlZmF1bHQgYmVmb3JlLWRlYWN0aXZhdGVkIHN0YWdlIGR1cmF0aW9uXG4gIC8vIH07XG4gIHZhciBiZWZvcmVEZWFjdGl2YXRlQ2FsbGJhY2sgPSB2b2lkIDA7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChsaXN0ZW5lcnNbdHlwZSArICctYmVmb3JlLWRlYWN0aXZhdGUnXSkge1xuICAgIGJlZm9yZURlYWN0aXZhdGVDYWxsYmFjayA9IGZ1bmN0aW9uIGJlZm9yZURlYWN0aXZhdGVDYWxsYmFjayhkb25lKSB7XG4gICAgICB2bS52dWVzY3JvbGwuc3RhdGVbc3RhZ2VUeXBlXSA9ICdiZWZvcmVEZWFjdGl2ZSc7XG4gICAgICB2bS4kZW1pdCh0eXBlICsgJy1iZWZvcmUtZGVhY3RpdmF0ZScsIHZtLCB0aXBEb20sIGRvbmUuYmluZCh2bS5zY3JvbGxlcikpO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGxpc3RlbmVyc1t0eXBlICsgJy1zdGFydCddKSB7XG4gICAgc3RhcnRDYWxsYmFjayA9IGZ1bmN0aW9uIHN0YXJ0Q2FsbGJhY2soKSB7XG4gICAgICB2bS52dWVzY3JvbGwuc3RhdGVbc3RhZ2VUeXBlXSA9ICdzdGFydCc7XG4gICAgICB2bS4kZW1pdCh0eXBlICsgJy1zdGFydCcsIHZtLCB0aXBEb20sIHZtLnNjcm9sbGVyLmZpbmlzaFJlZnJlc2hPckxvYWQuYmluZCh2bS5zY3JvbGxlcikpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFjdGl2YXRlQ2FsbGJhY2s6IGFjdGl2YXRlQ2FsbGJhY2ssXG4gICAgZGVhY3RpdmF0ZUNhbGxiYWNrOiBkZWFjdGl2YXRlQ2FsbGJhY2ssXG4gICAgc3RhcnRDYWxsYmFjazogc3RhcnRDYWxsYmFjayxcbiAgICBiZWZvcmVEZWFjdGl2YXRlQ2FsbGJhY2s6IGJlZm9yZURlYWN0aXZhdGVDYWxsYmFjayxcbiAgICBiZWZvcmVEZWFjdGl2ZUVuZDogYmVmb3JlRGVhY3RpdmVFbmRcbiAgfTtcbn1cblxudmFyIHNsaWRlTWl4ID0ge1xuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMudnNNb3VudGVkID0gdHJ1ZTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHB1bGxSZWZyZXNoVGlwOiBmdW5jdGlvbiBwdWxsUmVmcmVzaFRpcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1bGxSZWZyZXNoLnRpcHNbdGhpcy52dWVzY3JvbGwuc3RhdGUucmVmcmVzaFN0YWdlXTtcbiAgICB9LFxuICAgIHB1c2hMb2FkVGlwOiBmdW5jdGlvbiBwdXNoTG9hZFRpcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1c2hMb2FkLnRpcHNbdGhpcy52dWVzY3JvbGwuc3RhdGUubG9hZFN0YWdlXTtcbiAgICB9LFxuICAgIHJlZnJlc2hMb2FkOiBmdW5jdGlvbiByZWZyZXNoTG9hZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1bGxSZWZyZXNoLmVuYWJsZSB8fCB0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1c2hMb2FkLmVuYWJsZTtcbiAgICB9LFxuICAgIHJlZnJlaERvbVZpc2lhYmxlOiBmdW5jdGlvbiByZWZyZWhEb21WaXNpYWJsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZzTW91bnRlZCAmJiB0aGlzLm91dFRoZVRvcEJvdW5kYXJ5O1xuICAgIH0sXG4gICAgbG9hZERvbVZpc2lhYmxlOiBmdW5jdGlvbiBsb2FkRG9tVmlzaWFibGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52c01vdW50ZWQgJiYgdGhpcy5vdXRUaGVCb3R0b21Cb3VuZGFyeTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZ1ZXNjcm9sbDoge1xuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIC8qKiBEZWZhdWx0IHRpcHMgb2YgcmVmcmVzaCBhbmQgbG9hZCAqL1xuICAgICAgICAgIHJlZnJlc2hTdGFnZTogJ2RlYWN0aXZlJyxcbiAgICAgICAgICBsb2FkU3RhZ2U6ICdkZWFjdGl2ZSdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZzTW91bnRlZDogZmFsc2UsXG4gICAgICBvdXRUaGVUb3BCb3VuZGFyeTogZmFsc2UsXG4gICAgICBvdXRUaGVCb3R0b21Cb3VuZGFyeTogZmFsc2VcbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICAvLyBVcGRhdGU6XG4gICAgLy8gMS4gdXBkYXRlIGhlaWdodC93aWR0aFxuICAgIC8vIDIuIHVwZGF0ZSByZWZyZXNoIG9yIGxvYWRcbiAgICB1cGRhdGVTY3JvbGxlcjogZnVuY3Rpb24gdXBkYXRlU2Nyb2xsZXIoKSB7XG4gICAgICB0aGlzLnVwZGF0ZURpbWVzaW9uKCk7XG4gICAgICB0aGlzLnJlZ2lzdHJ5UmVmcmVzaExvYWQoKTtcbiAgICB9LFxuICAgIHVwZGF0ZURpbWVzaW9uOiBmdW5jdGlvbiB1cGRhdGVEaW1lc2lvbigpIHtcbiAgICAgIHZhciBjbGllbnRXaWR0aCA9IHRoaXMuJGVsLmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGNsaWVudEhlaWdodCA9IHRoaXMuJGVsLmNsaWVudEhlaWdodDtcbiAgICAgIHZhciBjb250ZW50V2lkdGggPSB0aGlzLnNjcm9sbFBhbmVsRWxtLnNjcm9sbFdpZHRoO1xuICAgICAgdmFyIGNvbnRlbnRIZWlnaHQgPSB0aGlzLnNjcm9sbFBhbmVsRWxtLnNjcm9sbEhlaWdodDtcbiAgICAgIHZhciByZWZyZXNoSGVpZ2h0ID0gMDtcbiAgICAgIHZhciBsb2FkSGVpZ2h0ID0gMDtcbiAgICAgIC8vIElmIHRoZSByZWZyZXNoIG9wdGlvbiBpcyB0cnVlLGxldCdzICBnaXZlIGEgXCJtYXJnaW4tdG9wXCIgc3R5bGUgdG9cbiAgICAgIC8vIHRoZSByZWZyZXNoLXRpcCBkb20uIGxldCBpdCB0byBiZSBpbnZpc2libGUgd2hlbiBkb2Vzbid0IHRyaWdnZXJcbiAgICAgIC8vIHJlZnJlc2guXG4gICAgICBpZiAodGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5wdWxsUmVmcmVzaC5lbmFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMudnNNb3VudGVkKSB7XG4gICAgICAgICAgdmFyIHJlZnJlc2hEb20gPSB0aGlzLiRyZWZzW19fUkVGUkVTSF9ET01fTkFNRV0uZWxtIHx8IHRoaXMuJHJlZnNbX19SRUZSRVNIX0RPTV9OQU1FXTtcbiAgICAgICAgICByZWZyZXNoSGVpZ2h0ID0gcmVmcmVzaERvbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgcmVmcmVzaERvbS5zdHlsZS5tYXJnaW5Ub3AgPSAtcmVmcmVzaEhlaWdodCArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1c2hMb2FkLmVuYWJsZSkge1xuICAgICAgICBpZiAodGhpcy52c01vdW50ZWQpIHtcbiAgICAgICAgICB2YXIgbG9hZERvbSA9IHRoaXMuJHJlZnNbX19MT0FEX0RPTV9OQU1FXS5lbG0gfHwgdGhpcy4kcmVmc1tfX0xPQURfRE9NX05BTUVdO1xuICAgICAgICAgIGxvYWRIZWlnaHQgPSBsb2FkRG9tLm9mZnNldEhlaWdodDtcbiAgICAgICAgICBjb250ZW50SGVpZ2h0IC09IGxvYWRIZWlnaHQ7XG4gICAgICAgICAgbG9hZERvbS5zdHlsZS5ib3R0b20gPSAnLScgKyBsb2FkSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxlci5zZXREaW1lbnNpb25zKGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQsIGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVnaXN0cnlSZWZyZXNoTG9hZDogZnVuY3Rpb24gcmVnaXN0cnlSZWZyZXNoTG9hZCgpIHtcbiAgICAgIC8vIHJlZ2lzdHJ5IHJlZnJlc2hcbiAgICAgIGlmICh0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1bGxSZWZyZXNoLmVuYWJsZSkge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5RXZlbnQoJ3JlZnJlc2gnKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdHJ5IGxvYWRcbiAgICAgIGlmICh0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnB1c2hMb2FkLmVuYWJsZSkge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5RXZlbnQoJ2xvYWQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZ2lzdHJ5U2Nyb2xsZXI6IGZ1bmN0aW9uIHJlZ2lzdHJ5U2Nyb2xsZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgICAgIGxlZnQgPSBfcmVmJGxlZnQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGxlZnQsXG4gICAgICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgICAgIF9yZWYkem9vbSA9IF9yZWYuem9vbSxcbiAgICAgICAgICB6b29tID0gX3JlZiR6b29tID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiR6b29tO1xuXG4gICAgICB2YXIgX21lcmdlZE9wdGlvbnMkdnVlc2NyID0gdGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5zY3JvbGxlcixcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IF9tZXJnZWRPcHRpb25zJHZ1ZXNjci5wcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdE9uTW92ZSA9IF9tZXJnZWRPcHRpb25zJHZ1ZXNjci5wcmV2ZW50RGVmYXVsdE9uTW92ZTtcbiAgICAgIHZhciBfbWVyZ2VkT3B0aW9ucyR2dWVzY3IyID0gdGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbCxcbiAgICAgICAgICBwYWdpbmcgPSBfbWVyZ2VkT3B0aW9ucyR2dWVzY3IyLnBhZ2luZyxcbiAgICAgICAgICBzbmFwcGluZyA9IF9tZXJnZWRPcHRpb25zJHZ1ZXNjcjIuc25hcHBpbmcuZW5hYmxlLFxuICAgICAgICAgIHJlbmRlck1ldGhvZCA9IF9tZXJnZWRPcHRpb25zJHZ1ZXNjcjIucmVuZGVyTWV0aG9kLFxuICAgICAgICAgIHpvb21pbmcgPSBfbWVyZ2VkT3B0aW9ucyR2dWVzY3IyLnpvb21pbmc7XG4gICAgICAvLyBkaXNhbGUgem9vbWluZyB3aGVuIHJlZnJlc2ggb3IgbG9hZCBlbmFibGVkXG5cbiAgICAgIHpvb21pbmcgPSAhdGhpcy5yZWZyZXNoTG9hZCAmJiAhcGFnaW5nICYmICFzbmFwcGluZyAmJiB6b29taW5nO1xuICAgICAgdmFyIF9tZXJnZWRPcHRpb25zJHNjcm9sbCA9IHRoaXMubWVyZ2VkT3B0aW9ucy5zY3JvbGxQYW5lbCxcbiAgICAgICAgICBzY3JvbGxpbmdZID0gX21lcmdlZE9wdGlvbnMkc2Nyb2xsLnNjcm9sbGluZ1ksXG4gICAgICAgICAgc2Nyb2xsaW5nWCA9IF9tZXJnZWRPcHRpb25zJHNjcm9sbC5zY3JvbGxpbmdYO1xuXG5cbiAgICAgIHZhciBzY3JvbGxpbmdDb21wbGV0ZSA9IHRoaXMuc2Nyb2xsaW5nQ29tcGxldGUuYmluZCh0aGlzKTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBTY3JvbGxlclxuICAgICAgdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcihyZW5kZXIodGhpcy5zY3JvbGxQYW5lbEVsbSwgd2luZG93LCAncHgnLCByZW5kZXJNZXRob2QpLCBfZXh0ZW5kcyh7fSwgdGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5zY3JvbGxlciwge1xuICAgICAgICB6b29taW5nOiB6b29taW5nLFxuICAgICAgICBzY3JvbGxpbmdZOiBzY3JvbGxpbmdZLFxuICAgICAgICBzY3JvbGxpbmdYOiBzY3JvbGxpbmdYICYmICF0aGlzLnJlZnJlc2hMb2FkLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogdGhpcy5tZXJnZWRPcHRpb25zLnNjcm9sbFBhbmVsLnNwZWVkLFxuICAgICAgICBwYWdpbmc6IHBhZ2luZyxcbiAgICAgICAgc25hcHBpbmc6IHNuYXBwaW5nLFxuICAgICAgICBzY3JvbGxpbmdDb21wbGV0ZTogc2Nyb2xsaW5nQ29tcGxldGVcbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5zY3JvbGxlci5fX2Rpc2FibGUgPSB0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnNjcm9sbGVyLmRpc2FibGU7XG4gICAgICB0aGlzLnNjcm9sbGVyLl9fc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICB0aGlzLnNjcm9sbGVyLl9fc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgdGhpcy5zY3JvbGxlci5fX3pvb21MZXZlbCA9IHpvb207XG5cbiAgICAgIC8vIFNldCBzbmFwXG4gICAgICBpZiAoc25hcHBpbmcpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRTbmFwU2l6ZSh0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnNuYXBwaW5nLndpZHRoLCB0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnNuYXBwaW5nLmhlaWdodCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5zY3JvbGxlci5zZXRQb3NpdGlvbihyZWN0LmxlZnQgKyB0aGlzLiRlbC5jbGllbnRMZWZ0LCByZWN0LnRvcCArIHRoaXMuJGVsLmNsaWVudFRvcCk7XG5cbiAgICAgIC8vIEdldCBkZXN0cm95IGNhbGxiYWNrXG4gICAgICB2YXIgY2IgPSBsaXN0ZW5Db250YWluZXIodGhpcy4kZWwsIHRoaXMuc2Nyb2xsZXIsIGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgLy8gVGhpZSBpcyB0byBkaXNwYXRjaCB0aGUgZXZlbnQgZnJvbSB0aGUgc2Nyb2xsZXIuXG4gICAgICAgIC8vIHRvIGxldCB2dWVzY3JvbGwgcmVmcmVzaCB0aGUgZG9tXG4gICAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgIF90aGlzLnZ1ZXNjcm9sbC5zdGF0ZS5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29uc2Nyb2xsJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVHJpZ2dlciBhdXRvIGxvYWRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgdmFyIHN0YWdlID0gX3RoaXMudnVlc2Nyb2xsLnN0YXRlWydsb2FkU3RhZ2UnXTtcbiAgICAgICAgICAgICAgdmFyIF9tZXJnZWRPcHRpb25zJHZ1ZXNjcjMgPSBfdGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5wdXNoTG9hZCxcbiAgICAgICAgICAgICAgICAgIGVuYWJsZSA9IF9tZXJnZWRPcHRpb25zJHZ1ZXNjcjMuZW5hYmxlLFxuICAgICAgICAgICAgICAgICAgYXV0byA9IF9tZXJnZWRPcHRpb25zJHZ1ZXNjcjMuYXV0byxcbiAgICAgICAgICAgICAgICAgIGF1dG9Mb2FkRGlzdGFuY2UgPSBfbWVyZ2VkT3B0aW9ucyR2dWVzY3IzLmF1dG9Mb2FkRGlzdGFuY2U7XG4gICAgICAgICAgICAgIHZhciBfc2Nyb2xsZXIgPSBfdGhpcy5zY3JvbGxlcixcbiAgICAgICAgICAgICAgICAgIF9fc2Nyb2xsVG9wID0gX3Njcm9sbGVyLl9fc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgICAgX19tYXhTY3JvbGxUb3AgPSBfc2Nyb2xsZXIuX19tYXhTY3JvbGxUb3A7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YWdlICE9ICdzdGFydCcgJiYgZW5hYmxlICYmIGF1dG8gJiYgIV90aGlzLmxvY2tBdXRvTG9hZCAmJiAvLyBhdXRvIGxvYWQgZGVib3VuY2VcbiAgICAgICAgICAgICAgYXV0b0xvYWREaXN0YW5jZSA+PSBfX21heFNjcm9sbFRvcCAtIF9fc2Nyb2xsVG9wICYmIF9fc2Nyb2xsVG9wID4gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvY2tBdXRvTG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlclJlZnJlc2hPckxvYWQoJ2xvYWQnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhdXRvTG9hZERpc3RhbmNlIDwgX19tYXhTY3JvbGxUb3AgLSBfX3Njcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvY2tBdXRvTG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICBfdGhpcy52dWVzY3JvbGwuc3RhdGUuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIHpvb21pbmcsIHByZXZlbnREZWZhdWx0LCBwcmV2ZW50RGVmYXVsdE9uTW92ZSk7XG5cbiAgICAgIHRoaXMudXBkYXRlU2Nyb2xsZXIoKTtcblxuICAgICAgcmV0dXJuIGNiO1xuICAgIH0sXG4gICAgdXBkYXRlU2xpZGVNb2RlQmFyU3RhdGU6IGZ1bmN0aW9uIHVwZGF0ZVNsaWRlTW9kZUJhclN0YXRlKCkge1xuICAgICAgLy8gdXBkYXRlIHNsaWRlIG1vZGUgc2Nyb2xsYmFycycgc3RhdGVcbiAgICAgIHZhciBoZWlnaHRQZXJjZW50YWdlID0gdm9pZCAwLFxuICAgICAgICAgIHdpZHRoUGVyY2VudGFnZSA9IHZvaWQgMDtcbiAgICAgIHZhciB2dWVzY3JvbGwgPSB0aGlzLiRlbDtcbiAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuc2Nyb2xsZXI7XG5cbiAgICAgIHZhciBvdXRlckxlZnQgPSAwO1xuICAgICAgdmFyIG91dGVyVG9wID0gMDtcblxuICAgICAgdmFyIF8kZWwgPSB0aGlzLiRlbCxcbiAgICAgICAgICBjbGllbnRXaWR0aCA9IF8kZWwuY2xpZW50V2lkdGgsXG4gICAgICAgICAgY2xpZW50SGVpZ2h0ID0gXyRlbC5jbGllbnRIZWlnaHQ7XG5cblxuICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNsaWVudFdpZHRoICsgdGhpcy5zY3JvbGxlci5fX21heFNjcm9sbExlZnQ7XG4gICAgICB2YXIgY29udGVudEhlaWdodCA9IGNsaWVudEhlaWdodCArIHRoaXMuc2Nyb2xsZXIuX19tYXhTY3JvbGxUb3A7XG5cbiAgICAgIC8vIFdlIHNob3VsZCBhZGQgdGhlIHRoZSBoZWlnaHQgb3Igd2lkdGggdGhhdCBpc1xuICAgICAgLy8gb3V0IG9mIGhvcml6b250YWwgYm91bnRyeSAgdG8gdGhlIHRvdGFsIGxlbmd0aFxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChzY3JvbGxlci5fX3Njcm9sbExlZnQgPCAwKSB7XG4gICAgICAgIG91dGVyTGVmdCA9IC1zY3JvbGxlci5fX3Njcm9sbExlZnQ7XG4gICAgICB9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovZWxzZSBpZiAoc2Nyb2xsZXIuX19zY3JvbGxMZWZ0ID4gc2Nyb2xsZXIuX19tYXhTY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgb3V0ZXJMZWZ0ID0gc2Nyb2xsZXIuX19zY3JvbGxMZWZ0IC0gc2Nyb2xsZXIuX19tYXhTY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgIC8vIG91dCBvZiB2ZXJ0aWNhbCBib3VudHJ5XG4gICAgICBpZiAoc2Nyb2xsZXIuX19zY3JvbGxUb3AgPCAwKSB7XG4gICAgICAgIG91dGVyVG9wID0gLXNjcm9sbGVyLl9fc2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLm91dFRoZUJvdHRvbUJvdW5kYXJ5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0VGhlVG9wQm91bmRhcnkgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxlci5fX3Njcm9sbFRvcCA+IHNjcm9sbGVyLl9fbWF4U2Nyb2xsVG9wKSB7XG4gICAgICAgIG91dGVyVG9wID0gc2Nyb2xsZXIuX19zY3JvbGxUb3AgLSBzY3JvbGxlci5fX21heFNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5vdXRUaGVUb3BCb3VuZGFyeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm91dFRoZUJvdHRvbUJvdW5kYXJ5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0VGhlVG9wQm91bmRhcnkgPSB0aGlzLm91dFRoZUJvdHRvbUJvdW5kYXJ5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGhlaWdodFBlcmNlbnRhZ2UgPSBjbGllbnRIZWlnaHQgLyAoY29udGVudEhlaWdodCArIG91dGVyVG9wKTtcbiAgICAgIHdpZHRoUGVyY2VudGFnZSA9IGNsaWVudFdpZHRoIC8gKGNvbnRlbnRXaWR0aCArIG91dGVyTGVmdCk7XG5cbiAgICAgIHZhciBzY3JvbGxUb3AgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBzY3JvbGxlci5fX3Njcm9sbFRvcCksIHNjcm9sbGVyLl9fbWF4U2Nyb2xsVG9wKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgc2Nyb2xsZXIuX19zY3JvbGxMZWZ0KSwgc2Nyb2xsZXIuX19tYXhTY3JvbGxMZWZ0KTtcblxuICAgICAgdGhpcy5iYXIudkJhci5zdGF0ZS5wb3NWYWx1ZSA9IChzY3JvbGxUb3AgKyBvdXRlclRvcCkgKiAxMDAgLyB2dWVzY3JvbGwuY2xpZW50SGVpZ2h0O1xuICAgICAgdGhpcy5iYXIuaEJhci5zdGF0ZS5wb3NWYWx1ZSA9IChzY3JvbGxMZWZ0ICsgb3V0ZXJMZWZ0KSAqIDEwMCAvIHZ1ZXNjcm9sbC5jbGllbnRXaWR0aDtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoc2Nyb2xsZXIuX19zY3JvbGxMZWZ0IDwgMCkge1xuICAgICAgICB0aGlzLmJhci5oQmFyLnN0YXRlLnBvc1ZhbHVlID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxlci5fX3Njcm9sbFRvcCA8IDApIHtcbiAgICAgICAgdGhpcy5iYXIudkJhci5zdGF0ZS5wb3NWYWx1ZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmFyLnZCYXIuc3RhdGUuc2l6ZSA9IGhlaWdodFBlcmNlbnRhZ2UgPCAxID8gaGVpZ2h0UGVyY2VudGFnZSA6IDA7XG4gICAgICB0aGlzLmJhci5oQmFyLnN0YXRlLnNpemUgPSB3aWR0aFBlcmNlbnRhZ2UgPCAxID8gd2lkdGhQZXJjZW50YWdlIDogMDtcbiAgICB9LFxuICAgIHJlZ2lzdHJ5RXZlbnQ6IGZ1bmN0aW9uIHJlZ2lzdHJ5RXZlbnQodHlwZSkge1xuICAgICAgdmFyIGRvbU5hbWUgPSB0eXBlID09ICdyZWZyZXNoJyA/IF9fUkVGUkVTSF9ET01fTkFNRSA6IF9fTE9BRF9ET01fTkFNRTtcbiAgICAgIHZhciBhY3RpdmF0ZUZ1bmMgPSB0eXBlID09ICdyZWZyZXNoJyA/IHRoaXMuc2Nyb2xsZXIuYWN0aXZhdGVQdWxsVG9SZWZyZXNoIDogdGhpcy5zY3JvbGxlci5hY3RpdmF0ZVB1c2hUb0xvYWQ7XG4gICAgICB2YXIgc3RhZ2VUeXBlID0gdHlwZSA9PSAncmVmcmVzaCcgPyAncmVmcmVzaFN0YWdlJyA6ICdsb2FkU3RhZ2UnO1xuICAgICAgdmFyIHRpcERvbSA9IHRoaXMuJHJlZnNbZG9tTmFtZV0uZWxtIHx8IHRoaXMuJHJlZnNbZG9tTmFtZV07XG4gICAgICB2YXIgY2JzID0gY3JlYXRlU3RhdGVDYWxsYmFja3ModHlwZSwgc3RhZ2VUeXBlLCB0aGlzLCB0aXBEb20pO1xuICAgICAgdmFyIGhlaWdodCA9IHRpcERvbS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIGFjdGl2YXRlRnVuYy5iaW5kKHRoaXMuc2Nyb2xsZXIpKGhlaWdodCwgY2JzKTtcbiAgICB9LFxuICAgIGdldFNsaWRlUG9zaXRpb246IGZ1bmN0aW9uIGdldFNsaWRlUG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JvbGxMZWZ0OiB0aGlzLnNjcm9sbGVyLl9fc2Nyb2xsTGVmdCxcbiAgICAgICAgc2Nyb2xsVG9wOiB0aGlzLnNjcm9sbGVyLl9fc2Nyb2xsVG9wXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUaGVzZSBtaXhlcyBpcyBleGNsdXNpdmUgZm9yIG5hdGl2ZSBtb2RlXG4gKi9cblxudmFyIG5hdGl2ZU1peCA9IHtcbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZU5hdGl2ZU1vZGVCYXJTdGF0ZTogZnVuY3Rpb24gdXBkYXRlTmF0aXZlTW9kZUJhclN0YXRlKCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuc2Nyb2xsUGFuZWxFbG07XG4gICAgICB2YXIgaXNQZXJjZW50ID0gdGhpcy52dWVzY3JvbGwuc3RhdGUuY3VycmVudFNpemVTdHJhdGVneSA9PSAncGVyY2VudCc7XG4gICAgICB2YXIgY2xpZW50V2lkdGggPSBpc1BlcmNlbnQgPyBjb250YWluZXIuY2xpZW50V2lkdGggOiB0aGlzLnZ1ZXNjcm9sbC5zdGF0ZS53aWR0aC5zbGljZSgwLCAtMik7IC8vIHh4eHB4ID09PiB4eHhcbiAgICAgIHZhciBjbGllbnRIZWlnaHQgPSBpc1BlcmNlbnQgPyBjb250YWluZXIuY2xpZW50SGVpZ2h0IDogdGhpcy52dWVzY3JvbGwuc3RhdGUuaGVpZ2h0LnNsaWNlKDAsIC0yKTtcblxuICAgICAgdmFyIGhlaWdodFBlcmNlbnRhZ2UgPSBjbGllbnRIZWlnaHQgLyBjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgdmFyIHdpZHRoUGVyY2VudGFnZSA9IGNsaWVudFdpZHRoIC8gY29udGFpbmVyLnNjcm9sbFdpZHRoO1xuXG4gICAgICB0aGlzLmJhci52QmFyLnN0YXRlLnBvc1ZhbHVlID0gY29udGFpbmVyLnNjcm9sbFRvcCAqIDEwMCAvIGNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMuYmFyLmhCYXIuc3RhdGUucG9zVmFsdWUgPSBjb250YWluZXIuc2Nyb2xsTGVmdCAqIDEwMCAvIGNsaWVudFdpZHRoO1xuXG4gICAgICB0aGlzLmJhci52QmFyLnN0YXRlLnNpemUgPSBoZWlnaHRQZXJjZW50YWdlIDwgMSA/IGhlaWdodFBlcmNlbnRhZ2UgOiAwO1xuICAgICAgdGhpcy5iYXIuaEJhci5zdGF0ZS5zaXplID0gd2lkdGhQZXJjZW50YWdlIDwgMSA/IHdpZHRoUGVyY2VudGFnZSA6IDA7XG4gICAgfSxcbiAgICBnZXROYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gZ2V0TmF0aXZlUG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JvbGxUb3A6IHRoaXMuc2Nyb2xsUGFuZWxFbG0uc2Nyb2xsVG9wLFxuICAgICAgICBzY3JvbGxMZWZ0OiB0aGlzLnNjcm9sbFBhbmVsRWxtLnNjcm9sbExlZnRcbiAgICAgIH07XG4gICAgfSxcbiAgICBvbk1vdXNlV2hlZWw6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi97XG4gICAgICB2YXIgZGVsdGEgPSAwO1xuICAgICAgdmFyIGRpciA9IHZvaWQgMDtcbiAgICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAgIGlmIChldmVudC5kZWx0YVkpIHtcbiAgICAgICAgICBkaXIgPSAnZHknO1xuICAgICAgICAgIGRlbHRhID0gZXZlbnQuZGVsdGFZO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRlbHRhWVgpIHtcbiAgICAgICAgICBkZWx0YSA9IGV2ZW50LmRlbHRhWDtcbiAgICAgICAgICBkaXIgPSAnZHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgZGlyID0gJ2R4JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlyID0gJ2R5JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWx0YSA9IC0xICogZXZlbnQud2hlZWxEZWx0YSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgc2Nyb2xsXG4gICAgICAgIGlmIChldmVudC5heGlzID09IDEpIHtcbiAgICAgICAgICBkaXIgPSAnZHgnO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmF4aXMgPT0gMikge1xuICAgICAgICAgIC8vIHZlcnRpY2FsIHNjcm9sbFxuICAgICAgICAgIGRpciA9ICdkeSc7XG4gICAgICAgIH1cbiAgICAgICAgZGVsdGEgPSBldmVudC5kZXRhaWwgKiAxNjtcbiAgICAgIH1cbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMubWVyZ2VkT3B0aW9ucy52dWVzY3JvbGwud2hlZWxTY3JvbGxEdXJhdGlvbjtcbiAgICAgIGlmIChkdXJhdGlvbiAmJiAodGhpcy5zY3JvbGxYRW5hYmxlICYmIGRpciA9PSAnZHgnIHx8IHRoaXMuc2Nyb2xsWUVuYWJsZSAmJiBkaXIgPT0gJ2R5JykpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQnkoZGVmaW5lUHJvcGVydHkoe30sIGRpciwgZGVsdGEpLCBkdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHNjcm9sbENvbnRlbnRFbG06IGZ1bmN0aW9uIHNjcm9sbENvbnRlbnRFbG0oKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcmVmc1snc2Nyb2xsQ29udGVudCddLl9pc1Z1ZSA/IHRoaXMuJHJlZnNbJ3Njcm9sbENvbnRlbnQnXS4kZWwgOiB0aGlzLiRyZWZzWydzY3JvbGxDb250ZW50J107XG4gICAgfVxuICB9XG59O1xuXG52YXIgdXBkYXRlID0gW3NsaWRlTWl4LCBuYXRpdmVNaXhdO1xuXG52YXIgbWl4aW5zID0gW2FwaSQxXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkodXBkYXRlKSk7XG5cbnZhciBjb3JlJDEgPSB7XG4gIG1peGluczogbWl4aW5zLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIGlmICghdGhpcy5faXNEZXN0cm95ZWQgJiYgIXRoaXMucmVuZGVyRXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT0gJ3NsaWRlJykge1xuICAgICAgICB0aGlzLnVwZGF0ZWRDYnMucHVzaCh0aGlzLnVwZGF0ZVNjcm9sbGVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kd2F0Y2goJ21lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLnNjcm9sbGVyLmRpc2FibGUnLCB7XG4gICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobmV3VmFsKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuX19kaXNhYmxlID0gbmV3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgbW9kZTogZnVuY3Rpb24gbW9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lcmdlZE9wdGlvbnMudnVlc2Nyb2xsLm1vZGU7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3lTY3JvbGxlcikge1xuICAgICAgICB0aGlzLnNjcm9sbGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKHRoaXMuZGVzdHJveVJlc2l6ZSkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lSZXNpemUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVNjcm9sbDogZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKG5hdGl2ZUV2ZW50KSB7XG4gICAgICB0aGlzLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCdoYW5kbGUtc2Nyb2xsJywgbmF0aXZlRXZlbnQpO1xuICAgIH0sXG4gICAgdXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQ6IGZ1bmN0aW9uIHVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KGV2ZW50VHlwZSkge1xuICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICBpZiAodGhpcy5tb2RlID09ICduYXRpdmUnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTmF0aXZlTW9kZUJhclN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PSAnc2xpZGUnKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlTW9kZUJhclN0YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KGV2ZW50VHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVyZ2VkT3B0aW9ucy5iYXIub25seVNob3dCYXJPblNjcm9sbCkge1xuICAgICAgICBpZiAoZXZlbnRUeXBlID09ICdoYW5kbGUtc2Nyb2xsJyB8fCBldmVudFR5cGUgPT0gJ2hhbmRsZS1yZXNpemUnIHx8IGV2ZW50VHlwZSA9PSAncmVmcmVzaC1zdGF0dXMnIHx8IGV2ZW50VHlwZSA9PSAnd2luZG93LXJlc2l6ZScgfHwgZXZlbnRUeXBlID09ICdvcHRpb25zLWNoYW5nZScpIHtcbiAgICAgICAgICB0aGlzLnNob3dBbmREZWZmZXJlZEhpZGVCYXIodHJ1ZSAvKiBmb3JjZUhpZGVCYXI6IHRydWUgKi8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dBbmREZWZmZXJlZEhpZGVCYXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtaXRFdmVudDogZnVuY3Rpb24gZW1pdEV2ZW50KGV2ZW50VHlwZSkge1xuICAgICAgdmFyIG5hdGl2ZUV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIF9zY3JvbGxQYW5lbEVsbSA9IHRoaXMuc2Nyb2xsUGFuZWxFbG0sXG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gX3Njcm9sbFBhbmVsRWxtLnNjcm9sbEhlaWdodCxcbiAgICAgICAgICBzY3JvbGxXaWR0aCA9IF9zY3JvbGxQYW5lbEVsbS5zY3JvbGxXaWR0aCxcbiAgICAgICAgICBjbGllbnRIZWlnaHQgPSBfc2Nyb2xsUGFuZWxFbG0uY2xpZW50SGVpZ2h0LFxuICAgICAgICAgIGNsaWVudFdpZHRoID0gX3Njcm9sbFBhbmVsRWxtLmNsaWVudFdpZHRoLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF9zY3JvbGxQYW5lbEVsbS5zY3JvbGxUb3AsXG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IF9zY3JvbGxQYW5lbEVsbS5zY3JvbGxMZWZ0O1xuXG5cbiAgICAgIHZhciB2ZXJ0aWNhbCA9IHtcbiAgICAgICAgdHlwZTogJ3ZlcnRpY2FsJ1xuICAgICAgfTtcbiAgICAgIHZhciBob3Jpem9udGFsID0ge1xuICAgICAgICB0eXBlOiAnaG9yaXpvbnRhbCdcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1vZGUgPT0gJ3NsaWRlJykge1xuICAgICAgICBzY3JvbGxIZWlnaHQgPSB0aGlzLnNjcm9sbGVyLl9fY29udGVudEhlaWdodDtcbiAgICAgICAgc2Nyb2xsV2lkdGggPSB0aGlzLnNjcm9sbGVyLl9fY29udGVudFdpZHRoO1xuICAgICAgICBzY3JvbGxUb3AgPSB0aGlzLnNjcm9sbGVyLl9fc2Nyb2xsVG9wO1xuICAgICAgICBzY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxlci5fX3Njcm9sbExlZnQ7XG4gICAgICAgIGNsaWVudEhlaWdodCA9IHRoaXMuJGVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgY2xpZW50V2lkdGggPSB0aGlzLiRlbC5jbGllbnRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgdmVydGljYWxbJ3Byb2Nlc3MnXSA9IE1hdGgubWluKHNjcm9sbFRvcCAvIChzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQpLCAxKTtcbiAgICAgIGhvcml6b250YWxbJ3Byb2Nlc3MnXSA9IE1hdGgubWluKHNjcm9sbExlZnQgLyAoc2Nyb2xsV2lkdGggLSBjbGllbnRXaWR0aCksIDEpO1xuXG4gICAgICB2ZXJ0aWNhbFsnYmFyU2l6ZSddID0gdGhpcy5iYXIudkJhci5zdGF0ZS5zaXplO1xuICAgICAgaG9yaXpvbnRhbFsnYmFyU2l6ZSddID0gdGhpcy5iYXIuaEJhci5zdGF0ZS5zaXplO1xuICAgICAgdmVydGljYWxbJ3Njcm9sbFRvcCddID0gc2Nyb2xsVG9wO1xuICAgICAgaG9yaXpvbnRhbFsnc2Nyb2xsTGVmdCddID0gc2Nyb2xsTGVmdDtcblxuICAgICAgdGhpcy4kZW1pdChldmVudFR5cGUsIHZlcnRpY2FsLCBob3Jpem9udGFsLCBuYXRpdmVFdmVudCk7XG4gICAgfSxcbiAgICBpbml0VmFyaWFibGVzOiBmdW5jdGlvbiBpbml0VmFyaWFibGVzKCkge1xuICAgICAgdGhpcy5sYXN0TW9kZSA9IHRoaXMubW9kZTtcbiAgICAgIHRoaXMuJGVsLl9pc1Z1ZXNjcm9sbCA9IHRydWU7XG4gICAgfSxcbiAgICByZWZyZXNoTW9kZTogZnVuY3Rpb24gcmVmcmVzaE1vZGUoKSB7XG4gICAgICB2YXIgaW5pdFBvcyA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnNjcm9sbGVyKSB7XG4gICAgICAgIGluaXRQb3MgPSB0aGlzLnNjcm9sbGVyLmdldFZhbHVlcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kZXN0cm95U2Nyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbGVyKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbGVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubW9kZSA9PSAnc2xpZGUnKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbGVyID0gdGhpcy5yZWdpc3RyeVNjcm9sbGVyKGluaXRQb3MpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT0gJ25hdGl2ZScpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBsZWdhY3kgdHJhbnNmb3JtIHN0eWxlIGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLnNjcm9sbFBhbmVsRWxtLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICB0aGlzLnNjcm9sbFBhbmVsRWxtLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcnO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVmcmVzaEludGVybmFsU3RhdHVzOiBmdW5jdGlvbiByZWZyZXNoSW50ZXJuYWxTdGF0dXMoKSB7XG4gICAgICAvLyAxLnNldCB2dWVzY3JvbGwgaGVpZ2h0IG9yIHdpZHRoIGFjY29yZGluZyB0b1xuICAgICAgLy8gc2l6ZVN0cmF0ZWd5XG4gICAgICB0aGlzLnNldFZzU2l6ZSgpO1xuICAgICAgLy8gMi4gcmVnaXN0cnkgcmVzaXplIGV2ZW50XG4gICAgICB0aGlzLnJlZ2lzdHJ5UmVzaXplKCk7XG4gICAgICAvLyAzLiByZWdpc3RyeSBzY3JvbGxlciBpZiBtb2RlIGlzICdzbGlkZSdcbiAgICAgIC8vIG9yIHJlbW92ZSAndHJhbnNmb3JtIG9yaWdpbicgaXMgdGhlIG1vZGUgaXMgbm90IGBzbGlkZWBcbiAgICAgIHRoaXMucmVmcmVzaE1vZGUoKTtcbiAgICAgIC8vIDQuIHVwZGF0ZSBzY3JvbGxiYXIncyBoZWlnaHQvd2lkdGhcbiAgICAgIHRoaXMudXBkYXRlQmFyU3RhdGVBbmRFbWl0RXZlbnQoJ3JlZnJlc2gtc3RhdHVzJyk7XG4gICAgfSxcbiAgICByZWdpc3RyeVJlc2l6ZTogZnVuY3Rpb24gcmVnaXN0cnlSZXNpemUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVzaXplRW5hYmxlID0gdGhpcy5tZXJnZWRPcHRpb25zLnZ1ZXNjcm9sbC5kZXRlY3RSZXNpemU7XG4gICAgICB2YXIgbW9kZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMubGFzdE1vZGUgIT0gdGhpcy5tb2RlKSB7XG4gICAgICAgIG1vZGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0TW9kZSA9IHRoaXMubW9kZTtcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmICh0aGlzLmRlc3Ryb3lSZXNpemUgJiYgcmVzaXplRW5hYmxlICYmICFtb2RlQ2hhbmdlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRlc3Ryb3lSZXNpemUpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95UmVzaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzaXplRW5hYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnRFbG0gPSBudWxsO1xuICAgICAgaWYgKHRoaXMubW9kZSA9PSAnc2xpZGUnKSB7XG4gICAgICAgIGNvbnRlbnRFbG0gPSB0aGlzLnNjcm9sbFBhbmVsRWxtO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT0gJ25hdGl2ZScpIHtcbiAgICAgICAgLy8gc2Nyb2xsQ29udGVudCBtYXliZSBhIHZ1ZS1jb21wb25lbnQgb3IgYSBwdXJlLWRvbVxuICAgICAgICBjb250ZW50RWxtID0gdGhpcy5zY3JvbGxDb250ZW50RWxtO1xuICAgICAgfVxuXG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgdmFyIGhhbmRsZVdpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uIGhhbmRsZVdpbmRvd1Jlc2l6ZSgpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICove1xuICAgICAgICB2bS51cGRhdGVCYXJTdGF0ZUFuZEVtaXRFdmVudCgnd2luZG93LXJlc2l6ZScpO1xuICAgICAgICBpZiAodm0ubW9kZSA9PSAnc2xpZGUnKSB7XG4gICAgICAgICAgdm0udXBkYXRlZENicy5wdXNoKHZtLnVwZGF0ZVNjcm9sbGVyKTtcbiAgICAgICAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGhhbmRsZURvbVJlc2l6ZSA9IGZ1bmN0aW9uIGhhbmRsZURvbVJlc2l6ZSgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTaXplID0ge307XG4gICAgICAgIGlmIChfdGhpcy5tb2RlID09ICdzbGlkZScpIHtcbiAgICAgICAgICBjdXJyZW50U2l6ZVsnd2lkdGgnXSA9IF90aGlzLnNjcm9sbGVyLl9fY29udGVudFdpZHRoO1xuICAgICAgICAgIGN1cnJlbnRTaXplWydoZWlnaHQnXSA9IF90aGlzLnNjcm9sbGVyLl9fY29udGVudEhlaWdodDtcbiAgICAgICAgICBfdGhpcy51cGRhdGVCYXJTdGF0ZUFuZEVtaXRFdmVudCgnaGFuZGxlLXJlc2l6ZScsIGN1cnJlbnRTaXplKTtcbiAgICAgICAgICAvLyB1cGRhdGUgc2Nyb2xsZXIgc2hvdWxkIGFmdGVyIHJlbmRlcmluZ1xuICAgICAgICAgIF90aGlzLnVwZGF0ZWRDYnMucHVzaChfdGhpcy51cGRhdGVTY3JvbGxlcik7XG4gICAgICAgICAgX3RoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMubW9kZSA9PSAnbmF0aXZlJykge1xuICAgICAgICAgIGN1cnJlbnRTaXplWyd3aWR0aCddID0gX3RoaXMuc2Nyb2xsUGFuZWxFbG0uc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgY3VycmVudFNpemVbJ2hlaWdodCddID0gX3RoaXMuc2Nyb2xsUGFuZWxFbG0uc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIF90aGlzLnVwZGF0ZUJhclN0YXRlQW5kRW1pdEV2ZW50KCdoYW5kbGUtcmVzaXplJywgY3VycmVudFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luY2UgY29udGVudCBzaWUgY2hhbmdlcywgd2Ugc2hvdWxkIHRlbGwgcGFyZW50IHRvIHNldFxuICAgICAgICAvLyBjb3JyZWN0IHNpemUgdG8gZml0IGNvbnRlbnQncyBzaXplXG4gICAgICAgIC8vICB0aGlzLnNldFZzU2l6ZSgpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVXaW5kb3dSZXNpemUsIGZhbHNlKTtcblxuICAgICAgdmFyIGRlc3Ryb3lEb21SZXNpemUgPSBpbnN0YWxsUmVzaXplRGV0ZWN0aW9uKGNvbnRlbnRFbG0sIGhhbmRsZURvbVJlc2l6ZSk7XG5cbiAgICAgIHZhciBkZXN0cm95V2luZG93UmVzaXplID0gZnVuY3Rpb24gZGVzdHJveVdpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVdpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5kZXN0cm95UmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXN0cm95V2luZG93UmVzaXplKCk7XG4gICAgICAgIGRlc3Ryb3lEb21SZXNpemUoKTtcblxuICAgICAgICBfdGhpcy5kZXN0cm95UmVzaXplID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG4gICAgICBpZiAodGhpcy5tb2RlID09ICdzbGlkZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2xpZGVQb3NpdGlvbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT0gJ25hdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlUG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIHNsaWRlIG1vZGUgY29uZmlnXG4gKi9cbnZhciBjb25maWcgPSB7XG4gIC8vIHZ1ZXNjcm9sbFxuICB2dWVzY3JvbGw6IHtcbiAgICAvLyBwb3NpdGlvbiBvciB0cmFuc2Zvcm1cbiAgICByZW5kZXJNZXRob2Q6ICd0cmFuc2Zvcm0nLFxuICAgIC8vIHB1bGxSZWZyZXNoIG9yIHB1c2hMb2FkIGlzIG9ubHkgZm9yIHRoZSBzbGlkZSBtb2RlLi4uXG4gICAgcHVsbFJlZnJlc2g6IHtcbiAgICAgIGVuYWJsZTogZmFsc2UsXG4gICAgICB0aXBzOiB7XG4gICAgICAgIGRlYWN0aXZlOiAnUHVsbCB0byBSZWZyZXNoJyxcbiAgICAgICAgYWN0aXZlOiAnUmVsZWFzZSB0byBSZWZyZXNoJyxcbiAgICAgICAgc3RhcnQ6ICdSZWZyZXNoaW5nLi4uJyxcbiAgICAgICAgYmVmb3JlRGVhY3RpdmU6ICdSZWZyZXNoIFN1Y2Nlc3NmdWxseSEnXG4gICAgICB9XG4gICAgfSxcbiAgICBwdXNoTG9hZDoge1xuICAgICAgZW5hYmxlOiBmYWxzZSxcbiAgICAgIHRpcHM6IHtcbiAgICAgICAgZGVhY3RpdmU6ICdQdXNoIHRvIExvYWQnLFxuICAgICAgICBhY3RpdmU6ICdSZWxlYXNlIHRvIExvYWQnLFxuICAgICAgICBzdGFydDogJ0xvYWRpbmcuLi4nLFxuICAgICAgICBiZWZvcmVEZWFjdGl2ZTogJ0xvYWQgU3VjY2Vzc2Z1bGx5ISdcbiAgICAgIH0sXG4gICAgICBhdXRvOiBmYWxzZSxcbiAgICAgIGF1dG9Mb2FkRGlzdGFuY2U6IDBcbiAgICB9LFxuICAgIHBhZ2luZzogZmFsc2UsXG4gICAgem9vbWluZzogdHJ1ZSxcbiAgICBzbmFwcGluZzoge1xuICAgICAgZW5hYmxlOiBmYWxzZSxcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICBoZWlnaHQ6IDEwMFxuICAgIH0sXG4gICAgLyogc29tZSBzY3JvbGxlciBvcHRpb25zICovXG4gICAgc2Nyb2xsZXI6IHtcbiAgICAgIC8qKiBFbmFibGUgYm91bmNpbmcgKGNvbnRlbnQgY2FuIGJlIHNsb3dseSBtb3ZlZCBvdXRzaWRlIGFuZCBqdW1wcyBiYWNrIGFmdGVyIHJlbGVhc2luZykgKi9cbiAgICAgIGJvdW5jaW5nOiB7XG4gICAgICAgIHRvcDogMTAwLFxuICAgICAgICBib3R0b206IDEwMCxcbiAgICAgICAgbGVmdDogMTAwLFxuICAgICAgICByaWdodDogMTAwXG4gICAgICB9LFxuICAgICAgLyoqIEVuYWJsZSBsb2NraW5nIHRvIHRoZSBtYWluIGF4aXMgaWYgdXNlciBtb3ZlcyBvbmx5IHNsaWdodGx5IG9uIG9uZSBvZiB0aGVtIGF0IHN0YXJ0ICovXG4gICAgICBsb2NraW5nOiB0cnVlLFxuICAgICAgLyoqIE1pbmltdW0gem9vbSBsZXZlbCAqL1xuICAgICAgbWluWm9vbTogMC41LFxuICAgICAgLyoqIE1heGltdW0gem9vbSBsZXZlbCAqL1xuICAgICAgbWF4Wm9vbTogMyxcbiAgICAgIC8qKiBNdWx0aXBseSBvciBkZWNyZWFzZSBzY3JvbGxpbmcgc3BlZWQgKiovXG4gICAgICBzcGVlZE11bHRpcGxpZXI6IDEsXG4gICAgICAvKiogVGhpcyBjb25maWd1cmVzIHRoZSBhbW91bnQgb2YgY2hhbmdlIGFwcGxpZWQgdG8gZGVjZWxlcmF0aW9uIHdoZW4gcmVhY2hpbmcgYm91bmRhcmllcyAgKiovXG4gICAgICBwZW5ldHJhdGlvbkRlY2VsZXJhdGlvbjogMC4wMyxcbiAgICAgIC8qKiBUaGlzIGNvbmZpZ3VyZXMgdGhlIGFtb3VudCBvZiBjaGFuZ2UgYXBwbGllZCB0byBhY2NlbGVyYXRpb24gd2hlbiByZWFjaGluZyBib3VuZGFyaWVzICAqKi9cbiAgICAgIHBlbmV0cmF0aW9uQWNjZWxlcmF0aW9uOiAwLjA4LFxuICAgICAgLyoqIFdoZXRoZXIgY2FsbCBlLnByZXZlbnREZWZhdWx0IGV2ZW50IHdoZW4gc2xpZGluZyB0aGUgY29udGVudCBvciBub3QgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcbiAgICAgIC8qKiBXaGV0aGVyIGNhbGwgcHJldmVudERlZmF1bHQgd2hlbiAobW91c2UvdG91Y2gpbW92ZSovXG4gICAgICBwcmV2ZW50RGVmYXVsdE9uTW92ZTogdHJ1ZSxcbiAgICAgIGRpc2FibGU6IGZhbHNlXG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiB2YWxpZGF0ZSB0aGUgb3B0aW9uc1xuICogQGV4cG9ydFxuICogQHBhcmFtIHthbnl9IG9wc1xuICovXG5mdW5jdGlvbiBjb25maWdWYWxpZGF0b3Iob3BzKSB7XG4gIHZhciByZW5kZXJFcnJvciA9IGZhbHNlO1xuICB2YXIgdnVlc2Nyb2xsID0gb3BzLnZ1ZXNjcm9sbDtcblxuICAvLyB2YWxpZGF0ZSBwdXNoTG9hZCwgcHVsbFJlcmVzaCwgc25hcHBpbmdcblxuICBpZiAodnVlc2Nyb2xsLnBhZ2luZyA9PSB2dWVzY3JvbGwuc25hcHBpbmcuZW5hYmxlICYmIHZ1ZXNjcm9sbC5wYWdpbmcgJiYgKHZ1ZXNjcm9sbC5wdWxsUmVmcmVzaCB8fCB2dWVzY3JvbGwucHVzaExvYWQpKSB7XG4gICAgZXJyb3IoJ3BhZ2luZywgc25hcHBpbmcsIChwdWxsUmVmcmVzaCB3aXRoIHB1c2hMb2FkKSBjYW4gb25seSBvbmUgb2YgdGhlbSB0byBiZSB0cnVlLicpO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlckVycm9yO1xufVxuXG52YXIgY29uZmlnJDEgPSB7XG4gIHZ1ZXNjcm9sbDoge1xuICAgIHdoZWVsU2Nyb2xsRHVyYXRpb246IDBcbiAgfVxufTtcblxudmFyIGNvbmZpZyQyID0ge1xuICAvLyB2dWVzY3JvbGxcbiAgdnVlc2Nyb2xsOiB7XG4gICAgbW9kZTogJ25hdGl2ZSdcbiAgfVxufTtcbi8qKlxuICogdmFsaWRhdGUgdGhlIG9wdGlvbnNcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7YW55fSBvcHNcbiAqL1xuZnVuY3Rpb24gY29uZmlnVmFsaWRhdG9yJDEob3BzKSB7XG4gIHZhciByZW5kZXJFcnJvciA9IGZhbHNlO1xuICB2YXIgdnVlc2Nyb2xsID0gb3BzLnZ1ZXNjcm9sbDtcblxuICAvLyB2YWxpZGF0ZSBtb2Rlc1xuXG4gIGlmICghfm1vZGVzLmluZGV4T2YodnVlc2Nyb2xsLm1vZGUpKSB7XG4gICAgZXJyb3IoJ1Vua25vd24gbW9kZTogJyArIHZ1ZXNjcm9sbC5tb2RlICsgJyx0aGUgdnVlc2Nyb2xsXFwncyBvcHRpb24gXCJtb2RlXCIgc2hvdWxkIGJlIG9uZSBvZiB0aGUgJyArIG1vZGVzKTtcbiAgICByZW5kZXJFcnJvciA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyRXJyb3I7XG59XG5cbnZhciBjb25maWdzID0gW2NvbmZpZyQyLCBjb25maWcsIGNvbmZpZyQxXTtcbnZhciBjb25maWdWYWxpZGF0b3JzID0gW2NvbmZpZ1ZhbGlkYXRvciQxLCBjb25maWdWYWxpZGF0b3JdO1xuXG52YXIgY29tcG9uZW50ID0gX2luc3RhbGwoY29yZSQxLCBjcmVhdGVQYW5lbCQyLCBjb25maWdzLCBjb25maWdWYWxpZGF0b3JzKTtcblxuZnVuY3Rpb24gaW5zdGFsbChWdWUkJDEpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIFZ1ZSQkMS5jb21wb25lbnQob3B0cy5uYW1lIHx8IGNvbXBvbmVudC5uYW1lLCBjb21wb25lbnQpO1xuICBWdWUkJDEucHJvdG90eXBlLiR2dWVzY3JvbGxDb25maWcgPSBvcHRzLm9wcyB8fCB7fTtcbn1cblxudmFyIFZ1ZXNjcm9sbCA9IF9leHRlbmRzKHtcbiAgaW5zdGFsbDogaW5zdGFsbCxcbiAgdmVyc2lvbjogJzQuMTIuMCcsXG4gIHJlZnJlc2hBbGw6IHJlZnJlc2hBbGwsXG4gIHNjcm9sbFRvOiBzY3JvbGxUb1xufSwgY29tcG9uZW50KTtcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShWdWVzY3JvbGwpO1xufVxuXG5yZXR1cm4gVnVlc2Nyb2xsO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vuescroll/dist/vuescroll.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZSIsIndpbmRvdyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLENBQUosQyxDQUVBOztBQUNBQSxDQUFDLEdBQUksWUFBVztBQUNmLFNBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsR0FBQyxHQUFHQSxDQUFDLElBQUksSUFBSUMsUUFBSixDQUFhLGFBQWIsR0FBVDtBQUNBLENBSEQsQ0FHRSxPQUFPQyxDQUFQLEVBQVU7QUFDWDtBQUNBLE1BQUksT0FBT0MsTUFBUCxLQUFrQixRQUF0QixFQUFnQ0gsQ0FBQyxHQUFHRyxNQUFKO0FBQ2hDLEMsQ0FFRDtBQUNBO0FBQ0E7OztBQUVBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLENBQWpCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/script/main.js":
/*!****************************!*\
  !*** ./src/script/main.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style/main.css */ \"./src/style/main.css\");\n/* harmony import */ var _style_main_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_main_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\");\n/* harmony import */ var _vue_main_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vue/main.vue */ \"./src/vue/main.vue\");\n/* harmony import */ var vuescroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vuescroll */ \"./node_modules/vuescroll/dist/vuescroll.js\");\n/* harmony import */ var vuescroll__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(vuescroll__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nnew vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n  el: '#root',\n  template: '<Content/>',\n  components: {\n    Content: _vue_main_vue__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n  }\n});\nvue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].use(vuescroll__WEBPACK_IMPORTED_MODULE_3___default.a, {\n  ops: {},\n  // 在这里设置全局默认配置\n  name: 'vueScroll' // 在这里自定义组件名字，默认是vueScroll\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0L21haW4uanM/NmU1ZiJdLCJuYW1lcyI6WyJWdWUiLCJlbCIsInRlbXBsYXRlIiwiY29tcG9uZW50cyIsIkNvbnRlbnQiLCJ1c2UiLCJWdWVTY3JvbGwiLCJvcHMiLCJuYW1lIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSUEsMkNBQUosQ0FBUTtBQUNKQyxJQUFFLEVBQUMsT0FEQztBQUVKQyxVQUFRLEVBQUMsWUFGTDtBQUdKQyxZQUFVLEVBQUM7QUFBRUMsa0VBQU9BO0FBQVQ7QUFIUCxDQUFSO0FBTUFKLDJDQUFHLENBQUNLLEdBQUosQ0FBUUMsZ0RBQVIsRUFBbUI7QUFDZkMsS0FBRyxFQUFFLEVBRFU7QUFDYTtBQUM1QkMsTUFBSSxFQUFFLFdBRlMsQ0FFYTs7QUFGYixDQUFuQiIsImZpbGUiOiIuL3NyYy9zY3JpcHQvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vc3R5bGUvbWFpbi5jc3MnO1xyXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XHJcbmltcG9ydCBDb250ZW50IGZyb20gJy4uL3Z1ZS9tYWluLnZ1ZSc7XHJcbmltcG9ydCBWdWVTY3JvbGwgZnJvbSAndnVlc2Nyb2xsJztcclxuXHJcbm5ldyBWdWUoe1xyXG4gICAgZWw6JyNyb290JyxcclxuICAgIHRlbXBsYXRlOic8Q29udGVudC8+JyxcclxuICAgIGNvbXBvbmVudHM6eyBDb250ZW50IH1cclxufSk7XHJcblxyXG5WdWUudXNlKFZ1ZVNjcm9sbCwge1xyXG4gICAgb3BzOiB7fSwgICAgICAgICAgICAgICAgICAgIC8vIOWcqOi/memHjOiuvue9ruWFqOWxgOm7mOiupOmFjee9rlxyXG4gICAgbmFtZTogJ3Z1ZVNjcm9sbCcgICAgICAgICAgIC8vIOWcqOi/memHjOiHquWumuS5iee7hOS7tuWQjeWtl++8jOm7mOiupOaYr3Z1ZVNjcm9sbFxyXG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/script/main.js\n");

/***/ }),

/***/ "./src/style/main.css":
/*!****************************!*\
  !*** ./src/style/main.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./main.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style/main.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGUvbWFpbi5jc3M/YTI2YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHlIQUF3RDs7QUFFOUUsNENBQTRDLFFBQVM7O0FBRXJEO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHNHQUFtRDs7QUFFeEU7O0FBRUEsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiLi9zcmMvc3R5bGUvbWFpbi5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9tYWluLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9tYWluLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/style/main.css\n");

/***/ }),

/***/ "./src/vue/main.vue":
/*!**************************!*\
  !*** ./src/vue/main.vue ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main_vue_vue_type_template_id_1adb287b_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.vue?vue&type=template&id=1adb287b&scoped=true& */ \"./src/vue/main.vue?vue&type=template&id=1adb287b&scoped=true&\");\n/* harmony import */ var _main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main.vue?vue&type=script&lang=js& */ \"./src/vue/main.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _main_vue_vue_type_style_index_0_id_1adb287b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css& */ \"./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  _main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _main_vue_vue_type_template_id_1adb287b_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _main_vue_vue_type_template_id_1adb287b_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  \"1adb287b\",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/vue/main.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlL21haW4udnVlP2YyMWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErRjtBQUN2QztBQUNMO0FBQ3FDOzs7QUFHeEY7QUFDMEY7QUFDMUYsZ0JBQWdCLDJHQUFVO0FBQzFCLEVBQUUsMEVBQU07QUFDUixFQUFFLDJGQUFNO0FBQ1IsRUFBRSxvR0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBVSxFQUFFLFlBaUJmO0FBQ0Q7QUFDZSxnRiIsImZpbGUiOiIuL3NyYy92dWUvbWFpbi52dWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL21haW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFhZGIyODdiJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL21haW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9tYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9tYWluLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFhZGIyODdiJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIxYWRiMjg3YlwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIkU6XFxcXHFxd3Fxa1xcXFxHaXRcXFxccXF3cXFrXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcxYWRiMjg3YicsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcxYWRiMjg3YicsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vbWFpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWFkYjI4N2Imc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignMWFkYjI4N2InLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy92dWUvbWFpbi52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vue/main.vue\n");

/***/ }),

/***/ "./src/vue/main.vue?vue&type=script&lang=js&":
/*!***************************************************!*\
  !*** ./src/vue/main.vue?vue&type=script&lang=js& ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib!../../node_modules/vue-loader/lib??vue-loader-options!./main.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlL21haW4udnVlPzg2Y2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBLHdDQUFvSyxDQUFnQix3T0FBRyxFQUFDIiwiZmlsZSI6Ii4vc3JjL3Z1ZS9tYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9tYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/vue/main.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&":
/*!***********************************************************************************!*\
  !*** ./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css& ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_style_index_0_id_1adb287b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib??vue-loader-options!./main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css& */ \"./node_modules/style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&\");\n/* harmony import */ var _node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_style_index_0_id_1adb287b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_style_index_0_id_1adb287b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_style_index_0_id_1adb287b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_style_index_0_id_1adb287b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_style_index_0_id_1adb287b_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlL21haW4udnVlPzRjMzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdVMsQ0FBZ0IsOFZBQUcsRUFBQyIsImZpbGUiOiIuL3NyYy92dWUvbWFpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xYWRiMjg3YiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbWFpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xYWRiMjg3YiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL21haW4udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWFkYjI4N2Imc2NvcGVkPXRydWUmbGFuZz1jc3MmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vue/main.vue?vue&type=style&index=0&id=1adb287b&scoped=true&lang=css&\n");

/***/ }),

/***/ "./src/vue/main.vue?vue&type=template&id=1adb287b&scoped=true&":
/*!*********************************************************************!*\
  !*** ./src/vue/main.vue?vue&type=template&id=1adb287b&scoped=true& ***!
  \*********************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_template_id_1adb287b_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib??vue-loader-options!./main.vue?vue&type=template&id=1adb287b&scoped=true& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/vue/main.vue?vue&type=template&id=1adb287b&scoped=true&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_template_id_1adb287b_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_main_vue_vue_type_template_id_1adb287b_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlL21haW4udnVlP2QwMmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwiZmlsZSI6Ii4vc3JjL3Z1ZS9tYWluLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xYWRiMjg3YiZzY29wZWQ9dHJ1ZSYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbWFpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWFkYjI4N2Imc2NvcGVkPXRydWUmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vue/main.vue?vue&type=template&id=1adb287b&scoped=true&\n");

/***/ })

/******/ });